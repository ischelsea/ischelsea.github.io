<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一章 认识软件测试管理</title>
      <link href="/posts/40593.html"/>
      <url>/posts/40593.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-软件质量与测试"><a href="#1-1-软件质量与测试" class="headerlink" title="1.1 软件质量与测试"></a>1.1 软件质量与测试</h2><h3 id="软件质量的概念"><a href="#软件质量的概念" class="headerlink" title="软件质量的概念"></a>软件质量的概念</h3><ul><li>软件质量越来越受到重视</li><li>ANSI/IEEE&lt;软件工程术语的IEEE标准术语表&gt;定义软件质量为<ul><li>“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”</li></ul></li></ul><h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><ul><li><p>软件产品各种质量特性的组合称为软件质量模型</p></li><li><p>常见的软件质量模型</p><ul><li>Boehm模型 1976年</li><li>MCCALL模型 1978年</li><li>ISO9126软件质量模型 1993年</li></ul></li></ul><h3 id="Boehm质量模型"><a href="#Boehm质量模型" class="headerlink" title="Boehm质量模型"></a>Boehm质量模型</h3><ul><li>1976年由Boehm等提出的分层方案</li><li>将软件的质量定义为分层的模型</li></ul><h4 id="boehm质量模型内容"><a href="#boehm质量模型内容" class="headerlink" title="boehm质量模型内容"></a>boehm质量模型内容</h4><ul><li><strong>可维护性</strong><ul><li><strong>可修改性</strong><ul><li><strong>可扩充性</strong></li><li><strong>结构化性</strong></li></ul></li><li><strong>可理解性</strong><ul><li><strong>清晰性</strong></li><li><strong>简单性</strong></li><li><strong>结构化性</strong></li><li><strong>自描述性</strong> 不需要其他培训 软件上的说明足以指引完成使用</li></ul></li><li><strong>可测试性</strong><ul><li><strong>结构化性</strong></li><li><strong>自描述性</strong></li><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>可测试性</strong></li></ul></li></ul></li><li><strong>可用性</strong><ul><li><strong>人类工程</strong><ul><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>健壮性</strong></li></ul></li><li><strong>效率</strong><ul><li><strong>可存取性</strong></li><li><strong>设备效率</strong></li><li><strong>可测试性</strong></li></ul></li><li><strong>可靠性</strong><ul><li><strong>一致性</strong></li><li><strong>健壮性</strong></li><li><strong>完备性</strong></li><li><strong>正确性</strong></li><li><strong>自包含性</strong></li></ul></li></ul></li><li><strong>可移植性</strong><ul><li><strong>自包含性</strong></li><li><strong>设备独立性</strong></li></ul></li></ul><h3 id="MCCALL质量模型"><a href="#MCCALL质量模型" class="headerlink" title="MCCALL质量模型"></a>MCCALL质量模型</h3><ul><li>1979年由McCall等人提出的软件质量模型</li><li>将软件质量的概念建立在11个质量特性之上</li><li>这些质量特性分别是面向软件产品的运行、修正和转移的</li></ul><h3 id="ISO9126质量模型"><a href="#ISO9126质量模型" class="headerlink" title="ISO9126质量模型"></a>ISO9126质量模型</h3><ul><li>软件质量模型可以分为：<ul><li>内部质量和外部质量模型、<ul><li>功能性</li><li>可靠性</li><li>易用性</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li>使用质量模型<ul><li>有效性</li><li>生产性</li><li>安全性</li><li>满意度</li></ul></li></ul></li></ul><h3 id="常见的软件质量特性"><a href="#常见的软件质量特性" class="headerlink" title="常见的软件质量特性"></a>常见的软件质量特性</h3><ol><li>性能Performance<ol><li>系统的响应能力</li><li>即 要经过多长时间才能对某个时间做出响应</li><li>或者在某段时间内系统所能处理的事件个数</li></ol></li><li>可用性Availability<ol><li>系统能正常运行的时间比例</li></ol></li><li>可靠性Rvailability<ol><li>系统在应用或错误面前，在意外或者错误使用的情况下维持软件系统功能特性的能力</li></ol></li><li>健壮性Robustness<ol><li>在处理或者环境中系统能够承受的压力或者变更能力</li></ol></li><li>安全性Security<ol><li>系统向合法用户提供服务的同时能够阻止非授权用户使用企图或拒绝服务的能力</li></ol></li></ol><h3 id="软件质量保证的手段"><a href="#软件质量保证的手段" class="headerlink" title="软件质量保证的手段"></a>软件质量保证的手段</h3><ul><li>软件测试</li><li>软件研发过程保证</li><li>软件研发配置管理</li><li>…</li></ul><h3 id="软件测试-vs-软件质量"><a href="#软件测试-vs-软件质量" class="headerlink" title="软件测试 vs 软件质量"></a>软件测试 vs 软件质量</h3><ul><li>软件测试是保证软件质量的重要手段之一</li><li>软件测试是有计划有组织的活动</li><li>软件测试管理确保测试活动的顺利开展</li></ul><h2 id="1-2-软件测试管理概述"><a href="#1-2-软件测试管理概述" class="headerlink" title="1.2 软件测试管理概述"></a>1.2 软件测试管理概述</h2><h3 id="项目与项目管理"><a href="#项目与项目管理" class="headerlink" title="项目与项目管理"></a>项目与项目管理</h3><ul><li>项目：<ul><li>一系列复杂的并相互关联的活动</li><li>有着一个明确的目标</li><li>必须在特定的时间、预算、资源限定内，依据规范完成</li></ul></li><li>项目管理：<ul><li>在项目活动中运用专门的知识、技能、工具或方法</li><li>使项目能够在有限资源限定条件下，实现预定的目标</li></ul></li><li>范畴：<ul><li>范围管理</li><li>时间管理</li><li>费用管理</li><li>质量管理</li><li>人力资源管理</li><li>风险管理</li><li>沟通管理</li><li>采购与合同管理</li></ul></li></ul><h3 id="软件测试管理-vs-软件项目管理"><a href="#软件测试管理-vs-软件项目管理" class="headerlink" title="软件测试管理 vs 软件项目管理"></a>软件测试管理 vs 软件项目管理</h3><ul><li>软件测试管理是忒数的软件项目管理<ul><li>与软件项目管理密切相关，有时从属于软件项目管理的一部分</li><li>可以借用软件项目管理的办法</li><li>因任务特点有自身特殊的知识、流程、方法、工具</li></ul></li></ul><h3 id="软件测试管理的要素"><a href="#软件测试管理的要素" class="headerlink" title="软件测试管理的要素"></a>软件测试管理的要素</h3><ul><li>测试过程与测试资产管理<ul><li>建立并维护测试的过程</li><li>建立并维护测试过程中建立的指南、模板、评审单等</li><li>管理测试工作相关的资产</li></ul></li><li>测试需求管理<ul><li>收集需求</li><li>分析需求</li><li>测试需求跟踪</li></ul></li><li>测试计划管理<ul><li>制定计划</li><li>执行计划</li><li>监控计划</li></ul></li><li>测试缺陷管理<ul><li>报告测试缺陷</li><li>回归测试发现的缺陷</li><li>缺陷分析</li></ul></li><li>测试工具管理<ul><li>选择测试工具</li><li>维护测试工具</li></ul></li><li>测试团队管理<ul><li>建立并维护测试团队</li><li>团队日常管理</li><li>团队绩效管理</li></ul></li></ul><h2 id="1-3-软件测试管理工具"><a href="#1-3-软件测试管理工具" class="headerlink" title="1.3 软件测试管理工具"></a>1.3 软件测试管理工具</h2><h3 id="软件测试工具"><a href="#软件测试工具" class="headerlink" title="软件测试工具"></a>软件测试工具</h3><ul><li>自动化测试工具<ul><li>单元测试工具</li><li>性能测试工具</li><li>功能测试工具</li><li>…</li></ul></li><li>软件测试管理工具<ul><li>ALM</li><li>BUGzilla：<a href="https://www.bugzilla.org/" target="_blank" rel="noopener">https://www.bugzilla.org/</a></li><li>Jira</li><li>禅道：<a href="https://www.zentao.net/" target="_blank" rel="noopener">https://www.zentao.net/</a></li><li>…</li></ul></li></ul><h3 id="软件测试管理工具的分类"><a href="#软件测试管理工具的分类" class="headerlink" title="软件测试管理工具的分类"></a>软件测试管理工具的分类</h3><ul><li>专项测试管理工具<ul><li>只管理软件测试中的某项内容<ul><li>如缺陷管理工具、</li><li>用例管理工具</li></ul></li><li>如BUGzilla是缺陷管理工具</li></ul></li><li>专门测试管理工具<ul><li>对测试的整个流程进行管理</li><li>如IBM Rational Quality Manager</li><li>HP ALM(Application lifecycle Management)等</li></ul></li><li>覆盖开发和测试的项目管理工具<ul><li>覆盖整个研发周期的项目管理工具</li><li>特别适用于研发测试齐全的产品研发团队</li><li>如：禅道项目管理软件</li></ul></li><li>其他<ul><li>借助办公软件和文档管理软件完成测试管理</li><li>办公软件:Office Project\Word\Excel</li><li>文档管理软件：如TortoiseSVN\TortoiseHg</li></ul></li></ul><h3 id="软件测试管理工具的选择"><a href="#软件测试管理工具的选择" class="headerlink" title="软件测试管理工具的选择"></a>软件测试管理工具的选择</h3><ul><li><p>选择测试管理工具应该综合考虑</p><ul><li>项目大小</li><li>团队规模</li><li>团队结构</li><li>成本预算</li></ul></li><li><p>工具是一个载体，</p><ul><li><p>可以提高工作效率，减少错误发生</p></li><li><p>更重要的是，利用知识和规范的流程完成项目，从而灵活运用工具</p></li></ul></li></ul><table><thead><tr><th>团队种类</th><th>建议选择</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td>小规模初创团队（如创业项目、学生项目等）</td><td>专项管理的开源工具或办公软件</td><td>节省成本、简单易用</td><td>Bugzilla      jira免费版 Office、Wps   文档管理软件TortoiseSVN  各种在线缺陷管理工具</td></tr><tr><td>第三方测试团队（专门提供测试服务的机构）</td><td>专门的测试管理工具</td><td>对测试全流程进行管理</td><td>IBM Rational Quality Manager       Hp ALM (Application Lifecycle Management)</td></tr><tr><td>产品研发团队（包括开发和测试人员）</td><td>软件项目管理工具</td><td>对软件开发进行全流程管理</td><td>有非常多的此类商业软件、不再举例，也有很多公司用的是自己研发的产品</td></tr></tbody></table><h3 id="软件测试管理工具的功能"><a href="#软件测试管理工具的功能" class="headerlink" title="软件测试管理工具的功能"></a>软件测试管理工具的功能</h3><ul><li>用户及权限管理</li><li>测试项目的创建</li><li>测试项目需求管理</li><li>测试任务分配和实施</li><li>测试项目缺陷管理</li><li>测试数据收集</li><li>测试项目数据分析统计和报告生成</li><li>测试项目用例管理</li><li>测试执行管理</li><li>测试文档管理</li></ul><h3 id="软件测试管理工具的发展趋势"><a href="#软件测试管理工具的发展趋势" class="headerlink" title="软件测试管理工具的发展趋势"></a>软件测试管理工具的发展趋势</h3><ul><li>与其他软件自动化测试工具集成<ul><li>如可以直接启动各种自动化测试</li></ul></li><li>与软件研发的其他环节集成越来越紧密<ul><li>如代码审查、产品版本管理等</li></ul></li><li>基于云的测试管理工具<ul><li>比如QASymphony开发的QTest是基于云计算的测试管理工具</li></ul></li></ul><h3 id="HP-ALM-测试管理工具简介"><a href="#HP-ALM-测试管理工具简介" class="headerlink" title="HP ALM 测试管理工具简介"></a>HP ALM 测试管理工具简介</h3><h4 id="ALM简介"><a href="#ALM简介" class="headerlink" title="ALM简介"></a>ALM简介</h4><ul><li>HP公司的软件测试管理工具</li><li>HP Application Lifecycle Management（ALM）<ul><li>可提供用于组织和跟踪应用程序版本的系统</li><li>帮助定义并维护需求及测试的库</li></ul></li><li>ALM具有缺陷跟踪系统<ul><li>能够从初始检测开始监控缺陷</li><li>直到问题解决</li></ul></li><li>ALM可以<ul><li>生成演示业务性能各个方面的叫糊涂</li><li>或使用任何截面数据定义报告</li><li>还可以通过在单个视图中并排排列多个图监控多个业务指标</li></ul></li></ul><h4 id="应用ALM优势"><a href="#应用ALM优势" class="headerlink" title="应用ALM优势"></a>应用ALM优势</h4><ul><li>加强开发人员、测试人员和业务分析师之间的协作</li><li>支持构建多级要求、任务、测试、缺陷、源代码和报告</li><li>任务管理有助于提高开发人员和测试人员的工作效率</li><li>同时支持瀑布式和敏捷式方法</li><li>与常见的开放源、商业开发管理解决方案完美集成</li></ul><h4 id="ALM功能"><a href="#ALM功能" class="headerlink" title="ALM功能"></a>ALM功能</h4><ul><li>版本规范</li><li>需求规范</li><li>测试计划</li><li>测试执行</li><li>缺陷跟踪</li></ul><h4 id="ALM服务器站点管理页面"><a href="#ALM服务器站点管理页面" class="headerlink" title="ALM服务器站点管理页面"></a>ALM服务器站点管理页面</h4><p><img src="/posts/40593/%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9.PNG" alt="1"></p><h4 id="ALM客户端登录界面"><a href="#ALM客户端登录界面" class="headerlink" title="ALM客户端登录界面"></a>ALM客户端登录界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.PNG" alt="登录界面"></p><p>登录时除了登录名和密码，还要选择登录的项目</p><p>每次只能登录一个固定的项目</p><h4 id="ALM客户端登陆后的界面"><a href="#ALM客户端登陆后的界面" class="headerlink" title="ALM客户端登陆后的界面"></a>ALM客户端登陆后的界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E5%90%8E%E7%95%8C%E9%9D%A2.PNG" alt="登陆后界面"></p><h4 id="ALM客户端-需求管理"><a href="#ALM客户端-需求管理" class="headerlink" title="ALM客户端-需求管理"></a>ALM客户端-需求管理</h4><p>可以创建需求</p><p>右下角为创建好的需求</p><h4 id="ALM客户端-用例管理"><a href="#ALM客户端-用例管理" class="headerlink" title="ALM客户端-用例管理"></a>ALM客户端-用例管理</h4><p>![用例管理](D:/github blog/ischelsea.github.io/source/_posts/第一章-认识软件测试管理/用例管理.PNG)</p><p>ALM客户端的用例管理称为测试计划</p><p>可以以树的形式来展现，也可以以列表的形式</p><p>可以对应到用例、可以对应到需求</p><p>每个用例有详细信息、设计步骤、参数、测试配置、附件等属性</p><h4 id="ALM客户端-测试实验室（执行管理）"><a href="#ALM客户端-测试实验室（执行管理）" class="headerlink" title="ALM客户端-测试实验室（执行管理）"></a>ALM客户端-测试实验室（执行管理）</h4><p><img src="/posts/40593/%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86.PNG" alt="执行管理"></p><p>实际上就是建立一些测试的集合</p><p>然后去执行这个测试集</p><p>测试集里会包含一群测试用例</p><p>之后可以执行并记录测试用例的执行结果，进行一些分析</p><h4 id="ALM客户端-缺陷管理"><a href="#ALM客户端-缺陷管理" class="headerlink" title="ALM客户端-缺陷管理"></a>ALM客户端-缺陷管理</h4><p><img src="/posts/40593/%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86.PNG" alt="缺陷管理"></p><p>因为缺陷有很多字段</p><p>所以缺陷建立后可以以列表的形式进行查看</p><p>缺陷可以向前关联到相应的测试用例</p><ul><li>缺陷的字段可以自己定义<ul><li>比如说缺陷的功能模块</li><li>每个产品的缺陷功能模块都是不同的</li><li>我们可以在客户端通过项目的自定义来定义缺陷的一些字段</li></ul></li></ul><p>综上</p><p>也就是说，ALM可以实现从需求、到用例、到缺陷的关联</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件测试实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 软件测试过程管理</title>
      <link href="/posts/5418.html"/>
      <url>/posts/5418.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件研发中的测试"><a href="#2-1-软件研发中的测试" class="headerlink" title="2.1 软件研发中的测试"></a>2.1 软件研发中的测试</h2><h3 id="1-软件研发中的测试活动"><a href="#1-软件研发中的测试活动" class="headerlink" title="1 软件研发中的测试活动"></a>1 软件研发中的测试活动</h3><h4 id="软件测试与软件研发"><a href="#软件测试与软件研发" class="headerlink" title="软件测试与软件研发"></a>软件测试与软件研发</h4><ul><li>软件测试和软件开发一样，都遵循软件工程的原理</li><li>测试是软件研发的一部分，测试和开发时密切相关的</li><li>测试活动是贯穿于软件项目开发的全过程的，和开发活动交互开展</li></ul><h4 id="软件研发生命周期的瀑布模型"><a href="#软件研发生命周期的瀑布模型" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h4><p><img src="/posts/5418/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><h4 id="尽早测试，越晚发现问题成本越高"><a href="#尽早测试，越晚发现问题成本越高" class="headerlink" title="尽早测试，越晚发现问题成本越高"></a>尽早测试，越晚发现问题成本越高</h4><p><img src="/posts/5418/%E5%8F%98%E5%8C%96.png" alt="变化"></p><h4 id="软件研发中的测试环节与测试活动"><a href="#软件研发中的测试环节与测试活动" class="headerlink" title="软件研发中的测试环节与测试活动"></a>软件研发中的测试环节与测试活动</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8.png" alt="测试活动"></p><h4 id="研发中的测试活动：软件需求评审及i系统测试方案制定"><a href="#研发中的测试活动：软件需求评审及i系统测试方案制定" class="headerlink" title="研发中的测试活动：软件需求评审及i系统测试方案制定"></a>研发中的测试活动：软件需求评审及i系统测试方案制定</h4><ol><li><p>软件需求完成后，需要进行需求的评审，此时测试人员可以：</p><ul><li>参与需求的评审</li><li>需求确定后进行系统测试方案及计划的制订</li></ul></li><li><p>软件总体设计完成后，进行总体设计方案评审，此时测试人员可以：</p><ul><li>参与总体设计方案的评审</li><li>开始进行集成测试方案的制定</li></ul></li><li><p>详细设计完成后，测试人员：</p><ul><li>参与详细设计的评审</li><li>开始进行模块测试方案的制定</li></ul></li><li><p>单元测试和编码一般是同步的，由开发人员自己完成的</p></li><li><p>整个模块开发完成后，测试人员开始进行模块测试，在这之前所有的模块测试用例应当已经准备完毕</p></li><li><p>模块测试后是执行集成测试和系统测试</p></li><li><p>软件运行维护期间则要对运行期间发现的问题进行记录和回归测试</p></li></ol><h3 id="2-按照开发阶段对软件测试分类"><a href="#2-按照开发阶段对软件测试分类" class="headerlink" title="2 按照开发阶段对软件测试分类"></a>2 按照开发阶段对软件测试分类</h3><ul><li><p>按照开发阶段划分，软件测试分为：</p><ul><li><p>单元测试</p></li><li><p>集成测试</p></li><li><p>系统测试</p></li><li><p>确认测试</p></li><li><p>验收测试</p></li></ul></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>单元测试又称为模块测试<ul><li>是针对软件设计的最小单位-程序模块进行正确性验证的测试工作</li></ul></li><li>检查程序单元是否满足详细设计说明中的：<ul><li>模块功能</li><li>性能</li><li>接口和设计约束</li><li>发现模块内部错误</li></ul></li><li>白盒和黑盒都会用到</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>集成测试<ul><li>也叫组装测试</li><li>或者联合测试</li></ul></li><li>每个单元正确<ul><li>组装起来不一定能正确工作</li><li>所以要开展集成测试</li></ul></li><li>主要检测单元的接口关系<ul><li>集成为符合概要设计要求的更大的组件</li></ul></li></ul><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><ul><li>检测软件是否满足软件需求说明书中规定的要求</li></ul><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>将同股集成测试的软件<ul><li>作为整个基于计算机系统的一个元素</li><li>与计算机硬件，外设，某些支持软件、数据和人员等其他元素结合在一起</li><li>在实际或模拟环境下进行测试</li></ul></li><li>目的是：<ul><li>通过与系统的需求定义作比较</li><li>发现与系统定义不一致的地方</li></ul></li></ul><h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul><li>按照项目任务书或合同的验收依据对整个系统进行测试与评审</li><li>决定是否接受系统</li></ul><h2 id="2-2-软件测试模型"><a href="#2-2-软件测试模型" class="headerlink" title="2.2 软件测试模型"></a>2.2 软件测试模型</h2><ul><li><h3 id="软件测试模型背景："><a href="#软件测试模型背景：" class="headerlink" title="软件测试模型背景："></a>软件测试模型背景：</h3><ul><li>测试与开发密切相关，通过实践产生了许多测试模型</li><li>这些模型将测试活动进行了抽象<ul><li>明确了测试与开发之间的关系</li><li>是测试管理的重要参考依据</li></ul></li></ul></li></ul><ul><li><h3 id="常见的软件测试模型"><a href="#常见的软件测试模型" class="headerlink" title="常见的软件测试模型"></a>常见的软件测试模型</h3><ul><li>V模型</li><li>W模型</li><li>H模型</li><li>X模型</li><li>前置测试模型</li></ul></li></ul><ul><li><h3 id="软件研发生命周期的瀑布模型-1"><a href="#软件研发生命周期的瀑布模型-1" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h3><ul><li>计划时期：<ul><li>问题定义</li><li>可行性研究</li></ul></li><li>开发时期：<ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>测试</li></ul></li><li>运行时期：<ul><li>运行与维护</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：V模型"><a href="#软件测试模型：V模型" class="headerlink" title="软件测试模型：V模型"></a>软件测试模型：V模型</h3><ul><li>来源：<ul><li>软件开发的瀑布模型</li></ul></li><li>特点：<ul><li>说明了基本的开发过程和测试行为</li><li>明确地标识了测试过程中存在的不同级别以及测试阶段和开发各阶段的关系</li></ul></li><li>局限性：<ul><li>测试对象只有程序代码</li><li>测试作为编码后的活动，未体现“尽早测试”的原则</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：W模型"><a href="#软件测试模型：W模型" class="headerlink" title="软件测试模型：W模型"></a>软件测试模型：W模型</h3><ul><li>演化来源：<ul><li>V模型</li></ul></li><li>与V模型区别：<ul><li>增加了与软件开发阶段同步进行的测试</li></ul></li><li>强调：<ul><li>测试伴随整个软件开发周期</li><li>测试对象不仅是程序，需求、功能和设计同样要测试</li><li>测试与开发同步进行，有利于尽早发现问题</li></ul></li><li>局限性：<ul><li>W与V模型<ul><li>均把软件开发视为需求、设计、编码等一系列串行的活动</li><li>无法支持迭代以及变更调整</li></ul></li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：H模型"><a href="#软件测试模型：H模型" class="headerlink" title="软件测试模型：H模型"></a>软件测试模型：H模型</h3><ul><li>强调：<ul><li>测试活动<ul><li>独立</li><li>贯穿于整个产品周期</li><li>与研发流程并发</li></ul></li><li>循环：<ul><li>测试点准备就绪即可执行测试</li></ul></li><li>测试<ul><li>可尽早进行</li><li>可对被测对象分层次、反复测试</li></ul></li></ul></li><li>某一次测试过程：<ul><li>测试准备</li><li>测试就绪点</li><li>其他流程</li><li>测试执行</li><li>测试流程</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：其他测试模型"><a href="#软件测试模型：其他测试模型" class="headerlink" title="软件测试模型：其他测试模型"></a>软件测试模型：其他测试模型</h3><ul><li>X测试模型:<ul><li>特点：<ul><li>认为”学院派的V模型“不能处理开发的实际时间过程</li><li>比如：<ul><li>频繁重复的集成</li><li>需求文档的缺乏</li></ul></li></ul></li><li>内容：<ul><li>针对单独程序片段所进行的相互分离的编码和测试</li><li>此后进行贫乏明年的交接</li><li>通过集成最终成为可执行的程序</li><li>然后再对这些可执行程序进行测试</li></ul></li></ul></li><li>前置测试模型：<ul><li>测试与开发紧密结合</li><li>对每个交付内容进行测试<ul><li>eg：<ul><li>设计文档</li><li>可行性报告</li></ul></li></ul></li><li>交付内容一旦完成，立即进行测试</li></ul></li></ul></li></ul><ul><li><h3 id="测试模型的使用："><a href="#测试模型的使用：" class="headerlink" title="测试模型的使用："></a>测试模型的使用：</h3><ul><li>模型对工作开展有重要意义<ul><li>但每个模型都不是完美的</li></ul></li><li>灵活运用各个模型的优点<ul><li>还要考虑项目的实际情况</li></ul></li></ul></li></ul><h2 id="2-3-软件测试的流程"><a href="#2-3-软件测试的流程" class="headerlink" title="2.3 软件测试的流程"></a>2.3 软件测试的流程</h2><h3 id="1-软件测试的流程"><a href="#1-软件测试的流程" class="headerlink" title="1.软件测试的流程"></a>1.软件测试的流程</h3><h4 id="测试流程内容："><a href="#测试流程内容：" class="headerlink" title="测试流程内容："></a>测试流程内容：</h4><ul><li>测试过程定义了<ul><li>企业在产品开发过程中在<ul><li>设计</li><li>开发与实现</li><li>维护</li><li>退出</li></ul></li><li>等阶段 与测试相关活动的<ul><li>内容</li><li>流程</li><li>规范</li></ul></li></ul></li><li>测试过程指导：<ul><li>项目如何开展各项测试活动</li><li>以及各项活动的输入输出</li></ul></li><li>测试过程<ul><li>约定活动中所设计的角色与职责</li><li>规范各个活动的内容和章程<ul><li>以及所使用到的统一的<ul><li>模版</li><li>表单</li><li>指导书</li><li>检查单</li></ul></li></ul></li></ul></li></ul><h4 id="测试流程的作用"><a href="#测试流程的作用" class="headerlink" title="测试流程的作用"></a>测试流程的作用</h4><ul><li>给公司在产品开发过程中测试相关的活动<ul><li>提供指导</li><li>确保产品可以真正满足用户要求</li></ul></li></ul><h4 id="测试与开发关系"><a href="#测试与开发关系" class="headerlink" title="测试与开发关系"></a>测试与开发关系</h4><ul><li>软件项目中测试与开发相互配合、同步推进<ul><li>软件项目的复杂性被测对象往往不断变化</li><li>实际项目中测试与开发的关系更加复杂</li></ul></li><li>虽然测试与开发关系复杂，但测试工作的开展有自己的过程要遵循</li><li>对单次测试来说，存在一个一般性的过程</li></ul><h4 id="软件测试一般性过程"><a href="#软件测试一般性过程" class="headerlink" title="软件测试一般性过程"></a>软件测试一般性过程</h4><ol><li>需求分析阶段<ul><li>收集相关资料</li><li>学习业务（测试对象）</li><li>分析测试需求点</li></ul></li><li>测试计划阶段：<ul><li>测试主管<ul><li>组织编写《测试计划》</li><li>该文档指明<ul><li>测试范围</li><li>方法</li><li>资源</li><li>相应测试活动人员时间进度安排</li></ul></li></ul></li><li>测试计划<ul><li>需要进行评审</li><li>测试计划一旦开始执行<ul><li>就要定期监控计划的执行情况</li></ul></li></ul></li></ul></li><li>测试设计与开发<ul><li>测试设计<ul><li>一般由对需求熟悉的资深测试工程师设计</li><li>为每个测试点设计出包括<ul><li>需求点简介</li><li>测试思路</li><li>详细测试方法</li></ul></li><li>三部分的方法</li></ul></li><li>测试开发主要完成：<ul><li>测试用例编写</li><li>测试数据准备</li><li>测试环境准备</li></ul></li><li>测试设计与测试用例完成后需要进行评审</li></ul></li><li>测试执行及报告<ul><li>执行测试用例</li><li>及时提交<ul><li>有质量的bug</li><li>测试阶段报告<ul><li>反馈测试情况</li></ul></li></ul></li></ul></li><li>软件评估报告及批准<ul><li>根据测试结果给出<ul><li>对软件的整体评估</li><li>是否通过测的建议</li></ul></li><li>一般决策部门<ul><li>会根据这份评估报告决定产品是否可以发布vy</li></ul></li></ul></li><li>测试总结及资产归档<ul><li>结项阶段<ul><li>对整个过程进行回顾总结</li><li>将项目相关资源进行整理归档</li></ul></li></ul></li></ol><h3 id="2-软件测试流程的建立和维护"><a href="#2-软件测试流程的建立和维护" class="headerlink" title="2 软件测试流程的建立和维护"></a>2 软件测试流程的建立和维护</h3><h4 id="创建软件测试流程注意事项"><a href="#创建软件测试流程注意事项" class="headerlink" title="创建软件测试流程注意事项"></a>创建软件测试流程注意事项</h4><ul><li>从实际情况出发<ul><li>优化流程</li><li>解决问题u</li></ul></li><li>重点考虑四个问题：<ul><li>哪些测试要做</li><li>谁做</li><li>什么时间做</li><li>如何做</li></ul></li></ul><h4 id="创建测试流程步骤"><a href="#创建测试流程步骤" class="headerlink" title="创建测试流程步骤"></a>创建测试流程步骤</h4><ul><li>对当前存在的问题进行收集、诊断分析</li><li>根据实际情况建立新的流程</li><li>流程发布和试运行</li><li>促进流程的执行、收集问题</li><li>流程更新和发布</li></ul><h4 id="测试执行-VS-测试过程执行"><a href="#测试执行-VS-测试过程执行" class="headerlink" title="测试执行 VS 测试过程执行"></a>测试执行 VS 测试过程执行</h4><ul><li>测试执行<ul><li>按照测试计划去执行测试活动</li></ul></li><li>测试过程执行<ul><li>是严格按照测试的过程去开展测试活动</li></ul></li></ul><h4 id="测试流程不是静止的"><a href="#测试流程不是静止的" class="headerlink" title="测试流程不是静止的"></a>测试流程不是静止的</h4><ul><li>测试过程创建后不是一成不变</li><li>而是根据实际实践情况不断改进和完善</li><li>进行修订后要及时进行过程发布</li></ul><h4 id="促进测试过程的执行"><a href="#促进测试过程的执行" class="headerlink" title="促进测试过程的执行"></a>促进测试过程的执行</h4><ul><li>一般在测试过程执行中<ul><li>要设置一定的机制</li><li>去保证测试人员按照测试过程开展测试活动</li></ul></li><li>促进测试的执行<ul><li>QA人员对项目的监督和指导</li><li>组织级审计</li></ul></li></ul><h4 id="测试流程的改进"><a href="#测试流程的改进" class="headerlink" title="测试流程的改进"></a>测试流程的改进</h4><ul><li>测试流程<ul><li>在每一轮执行完毕后</li><li>根据所执行情况对流程进行更新和完善</li><li>用好的实践去更新完善流程</li></ul></li></ul><h4 id="测试过程中涉及的文档等资产"><a href="#测试过程中涉及的文档等资产" class="headerlink" title="测试过程中涉及的文档等资产"></a>测试过程中涉及的文档等资产</h4><ul><li>测试计划文档</li><li>测试方案文档</li><li>测试用例</li><li>测试报告</li><li>测试缺陷库</li><li>其他<ul><li>新开发或引入的测试工具</li><li>测试工作会议记录<ul><li>测试计划</li><li>测试方案</li><li>测试用例<ul><li>的评审报告</li></ul></li></ul></li><li>测试总结</li><li>测试原始数据以及度量数据</li><li>测试日志<ul><li>每天测试日程记录</li></ul></li><li>周期性测试报告</li><li>任务报告：<ul><li>任务完成情况报告</li></ul></li></ul></li></ul><h4 id="测试方案文档"><a href="#测试方案文档" class="headerlink" title="测试方案文档"></a>测试方案文档</h4><ul><li>描述<ul><li>为完成软件特性的测试而采用的测试方法的细节</li></ul></li><li>主要内容：<ul><li>概述</li><li>被测对象</li><li>应测试的特性</li><li>不被测试的特性</li><li>测试模型</li><li>测试需求</li><li>测试设计</li></ul></li></ul><h4 id="测试用例文档"><a href="#测试用例文档" class="headerlink" title="测试用例文档"></a>测试用例文档</h4><ul><li>测试用例表描述测试用例<ul><li>测试项目</li><li>用例编号</li><li>用例级别：测试用例重要程度</li><li>用例可用性</li><li>输入值</li><li>预期输出</li><li>实测结果</li><li>特殊环境需求（可选）</li><li>特殊测试步骤（可选）</li></ul></li></ul><h4 id="测试报告文档"><a href="#测试报告文档" class="headerlink" title="测试报告文档"></a>测试报告文档</h4><ul><li>描述测试结果的文档</li><li>主要内容：<ul><li>概述</li><li>测试时间、地点、人员</li><li>测试环境</li><li>测试结果统计分析</li><li>测试评估</li><li>测试总结与改进</li><li>测试缺陷列表</li></ul></li></ul><h4 id="测试缺陷："><a href="#测试缺陷：" class="headerlink" title="测试缺陷："></a>测试缺陷：</h4><ul><li>描述测试缺陷</li><li>主要内容：<ul><li>缺陷简述</li><li>缺陷描述</li><li>缺陷级别</li><li>缺陷分析与对策</li></ul></li></ul><h3 id="企业测试流程样例"><a href="#企业测试流程样例" class="headerlink" title="企业测试流程样例"></a>企业测试流程样例</h3><h4 id="某企业测试过程样例-概览"><a href="#某企业测试过程样例-概览" class="headerlink" title="某企业测试过程样例-概览"></a>某企业测试过程样例-概览</h4><p><img src="/posts/5418/%E6%A6%82%E8%A7%88.PNG" alt="概览"></p><h4 id="测试过程描述"><a href="#测试过程描述" class="headerlink" title="测试过程描述"></a>测试过程描述</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0.PNG" alt="测试过程描述"></p><h4 id="活动流程定义"><a href="#活动流程定义" class="headerlink" title="活动流程定义"></a>活动流程定义</h4><p><img src="/posts/5418/%E6%B4%BB%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89.PNG" alt="活动流程定义"></p><h4 id="测试相关的文档模版"><a href="#测试相关的文档模版" class="headerlink" title="测试相关的文档模版"></a>测试相关的文档模版</h4><p><img src="/posts/5418/%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF.PNG" alt="文档模版"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件测试实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1-非功能性的系统测试需求</title>
      <link href="/posts/14723.html"/>
      <url>/posts/14723.html</url>
      
        <content type="html"><![CDATA[<h2 id="典型的遇到的问题"><a href="#典型的遇到的问题" class="headerlink" title="典型的遇到的问题"></a>典型的遇到的问题</h2><ol><li>系统性能问题</li><li>软件系统安全性受到挑战</li></ol><h2 id="什么是系统非功能性测试？"><a href="#什么是系统非功能性测试？" class="headerlink" title="什么是系统非功能性测试？"></a>什么是系统非功能性测试？</h2><ul><li><p>用户的需求</p><ul><li>分类：<ul><li>功能性需求</li><li>非功能性需求</li></ul></li></ul></li><li><p>非功能性需求：</p><ul><li>被归纳为：<ul><li>软件产品的各种质量特性</li><li>eg：<ul><li>安全性</li><li>兼容性</li><li>可靠性</li></ul></li></ul></li></ul></li><li><p>系统非功能性测试：</p><ul><li>针对于以上非功能特性展开</li><li>验证软件产品符合这些质量特性的要求<ul><li>从而满足用户和软件企业自身的非功能性需求</li></ul></li></ul></li><li><p>系统测试</p><ul><li>分类：<ul><li>负载测试</li><li>性能测试</li><li>容量测试</li><li>安全性测试</li><li>兼容性测试</li><li>可靠性测试</li></ul></li></ul></li></ul><h2 id="系统非功能特性"><a href="#系统非功能特性" class="headerlink" title="系统非功能特性"></a>系统非功能特性</h2><ul><li><p><strong>性能</strong></p><ul><li>指按用户负载条件对<ul><li>响应时间</li><li>吞吐量<ul><li>所做的度量<ul><li>（度量指的是一些指标进行计算后的统计结果）</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>可用性</strong>：</p><ul><li>指对<ul><li>系统资源</li><li>服务<ul><li>可供最终用户使用的程度度量</li></ul></li></ul></li><li>通常以系统的正常运行时间来表示</li></ul></li><li><p><strong>可伸缩性</strong>：</p><ul><li>指随时间推移为部署系统增加容量和用户的能力</li><li>通常涉及向系统添加资源</li><li>但不应要求对部署体系结构进行更改</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>指对系统及用户的完整性进行说明的复杂因素组合</li><li>包括<ul><li>用户的验证和授权</li><li>数据的安全</li><li>对已部署系统的安全访问</li></ul></li></ul></li><li><p><strong>潜在容量</strong>：</p><ul><li>指在不增加资源的情况下，系统处理异常峰值负载的能力</li><li>潜在容量是<ul><li>可用性</li><li>性能</li><li>可伸缩性<ul><li>特性中的一个因素</li></ul></li></ul></li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>指对已部署系统进行维护的难易度</li><li>其中包括：<ul><li>监视系统</li><li>修复出现的故障</li><li>升级硬件和软件组件</li></ul></li></ul></li></ul><h2 id="系统非功能性测试的内容"><a href="#系统非功能性测试的内容" class="headerlink" title="系统非功能性测试的内容"></a>系统非功能性测试的内容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter录制脚本</title>
      <link href="/posts/3679.html"/>
      <url>/posts/3679.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>file</code>目录中选择 templates..</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC1.png" alt="1"></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC2.png" alt="2"></p><p><code>select</code> <code>template</code>   中选择  <code>recording</code>  （在要做接口测试时）</p><p>如果要做性能测试，可以选择<code>recording with think time</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC3.png" alt="3"></p><p>选完后，<code>create</code> 确认</p><p>更改 <code>hostToRecord</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC4.png" alt="4"></p><p>因为是要测试自己的网站，而这个网站是部署在自己电脑上的，所以此处<code>hostToRecord</code>更改为<code>127.00.1</code></p><p><code>https</code> 改为 <code>http</code></p><p>再次选择 <code>create</code> 创建</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC5.png" alt="5"></p><ul><li><p>知识点：LogicController：</p><ul><li>用来控制TestPlan的执行，如循环、分支等，或者更简单一点，就是为了分组</li></ul></li><li><p>Thread Group下的Recording controller即是用于分组</p></li><li><p>view resultsTree：看执行结果</p></li><li><p>HTTP(S) Test Script Recorder:</p><ul><li>用于代理（浏览器请求需要通过这个代理再到网站，网站返回的相应也要通过这个代理，所以他要把这个请求给记下来）</li></ul></li></ul><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC6.png" alt="6"></p><p><code>port</code> 端口为8888，因为电脑上没有与这个冲突的，所以不用改</p><p>下面的 <code>Target Controller</code> 是指的存放所录制脚本的地方</p><p> <code>grouping</code>：一秒钟以内的请求</p><p>点击上面的 <code>start</code></p><p>再打开浏览器，打开设置栏，选择管理证书</p><p><img src="/posts/3679/7.png" alt="7"></p><p>选择证书颁发机构，选择导入</p><p><img src="/posts/3679/8.png" alt="8"></p><p>打开jmeter下的bin目录的apachejmetertemporaryrootca</p><p>后面一直点下一步、确定之类的即可</p><p>直到导入成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo s</code></p><p>图片引用：<img src="/posts/16107/%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="你想输入的替代文字"></p><p>emoji-》     ：smile：（冒号两边无空格）</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
