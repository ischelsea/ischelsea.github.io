<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>7-10-可靠性测试</title>
      <link href="/posts/41234.html"/>
      <url>/posts/41234.html</url>
      
        <content type="html"><![CDATA[<h1 id="软件可靠性定义"><a href="#软件可靠性定义" class="headerlink" title="软件可靠性定义"></a>软件可靠性定义</h1><ul><li>软件可靠性<ul><li>是软件系统在规定的时间内及规定的环境条件下</li><li>完成规定功能的能力</li></ul></li></ul><h1 id="软件可靠性三要素"><a href="#软件可靠性三要素" class="headerlink" title="软件可靠性三要素"></a>软件可靠性三要素</h1><ul><li>规定的时间</li><li>规定的运行环境条件</li><li>规定的功能</li></ul><h1 id="可靠性的度量"><a href="#可靠性的度量" class="headerlink" title="可靠性的度量"></a>可靠性的度量</h1><ul><li>可靠性的最常用的度量<ul><li>是平均无故障时间</li></ul></li><li>例如：<ul><li>通过压力测试</li><li>并借助<ul><li>软件失效模式</li><li>影响分析<ul><li>来获得有关可靠性数据</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.9 容错性测试</title>
      <link href="/posts/54896.html"/>
      <url>/posts/54896.html</url>
      
        <content type="html"><![CDATA[<h1 id="容错性测试的分类"><a href="#容错性测试的分类" class="headerlink" title="容错性测试的分类"></a>容错性测试的分类</h1><ul><li>负面测试</li><li>故障转移测试</li></ul><h1 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h1><ul><li><p>容错性测试就是</p><ul><li>在各种异常条件下对系统的功能进行测试</li><li>以检验系统是否具有防护性的举措或者某种灾难性恢复的手段或能力</li></ul></li><li><p>容错性可分为两个层次：</p><ul><li>功能层次的容错性测试<ul><li>也称 <strong>负面</strong> 测试<ul><li>negative test</li></ul></li><li>或 <strong>例外</strong> 测试<ul><li>exception test</li></ul></li></ul></li><li>系统层次的容错性测试<ul><li>主要是<ul><li>灾难恢复性测试</li><li>故障转移测试</li></ul></li></ul></li></ul></li></ul><h1 id="负面测试"><a href="#负面测试" class="headerlink" title="负面测试"></a>负面测试</h1><ul><li><p>负面测试</p><ul><li>是从<strong>逆向思维</strong>出发</li><li>检查系统在 <strong>异常条件</strong> 下或用户的 <strong>非法操作</strong> 下系统是如何 <strong>响应</strong> 的</li><li>是否有 <strong>异常行为</strong> 或执行了 <strong>不应该执行的动作</strong></li></ul></li><li><p>无效等价类的测试用例就是一种 <strong>负面的测试</strong></p></li><li><p>在一些 <strong>异常的</strong> 或 <strong>恶劣</strong>的条件下进行操作</p></li><li><p><strong>探索式</strong> 测试</p></li></ul><h1 id="故障转移机制"><a href="#故障转移机制" class="headerlink" title="故障转移机制"></a>故障转移机制</h1><p><img src="/posts/54896/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6.jpg" alt="故障转移机制"></p><h1 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h1><ul><li>故障转移测试<ul><li>就是验证 <strong>故障转移机制</strong> 能否 <strong>正常实现</strong>，满足事先的设计要求</li><li>是在 <strong>软件系统发生故障</strong> 的情况下<ul><li>去检验系统的恢复能力</li><li>验证系统已保存的用户数据是否丢失</li><li>系统和数据是否能尽快恢复或在指定时间内恢复</li><li>包括<ul><li>验证重新初始化</li><li>检查点</li><li>数据恢复</li><li>重新启动<ul><li>等机制的正确性</li></ul></li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美国文学绪论</title>
      <link href="/posts/28139.html"/>
      <url>/posts/28139.html</url>
      
        <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ol><li>The Literature of Colonial America<ul><li>Puritan Thoughts</li></ul></li><li>The Literature of Reason and Revolution<ul><li>American Enlightenment</li><li>Benjamin Franklin: The Autobiography</li><li>Philip Freneau:The Wild Honey Suckle </li></ul></li><li>The Literature of Romanticism<ul><li>American Romanticism</li><li>Washington Irving: The Legend of Sleepy Hollow</li><li>William Cullen Bryant:To a Waterfowl</li><li>Edgar Allan Poe: To Helen; Annabel Lee;The Fall of the House of Usher</li><li>Transcendentalism</li><li>Henry David Thoreau:Walden</li><li>Nathaniel Hawthorne :The Scarlet Letter</li><li>Herman Melville:Moby Dick</li><li>Henry Wadsworth Longfellow:A Psalm of Life</li></ul></li><li>The Literature of Realism<ul><li>American Realism</li><li>free verse</li><li>Walt Whitman: Song of Myself</li><li>Emily Dickinson:I heard a Fly buzz—when I died</li><li>Mark Twain:The Adventures of Tom Sawyer</li><li>Henry James:The Portrait of a Lady</li><li>American Naturalism</li><li>Jack London:The Sea-Wolf,Martin Eden</li><li>Theodore Dreiser:Sister Carrie</li></ul></li><li>Twentieth-Century Literature<ul><li>Modernism</li><li>Imagism</li><li>Ezra Pound:In a Station of the Metro</li><li>Robert Frost:The Road Not Taken;Stopping by Woods on a Snowy Evening</li><li>Carl Sandburg:Chicago</li><li>F.Scott Fitzgerald:The Great Gatsby</li><li>Ernest Hemingway:A Farewell to Arms</li><li>John Steinbeck:The Grapes of Wrath</li><li>William Faulkner:A Rose for Emily</li></ul></li></ol><h1 id="The-Literature-of-Colonial-America"><a href="#The-Literature-of-Colonial-America" class="headerlink" title="The Literature of Colonial America"></a>The Literature of Colonial America</h1><h2 id="historical-introduction"><a href="#historical-introduction" class="headerlink" title="historical introduction"></a>historical introduction</h2><ul><li><p>The colonial period stretched roughly from the settlement of America in the early 17th century through the end of the 18th.</p><ul><li>The first permanent settlement in America was established by English in 1607.</li><li>(A group of people was sent by the English <strong>King James I</strong> to hunt for <strong>gold</strong>.They arrived at Virginia in 1607.They named the <strong>James River</strong> and bulid the <strong>James town</strong>.)</li></ul></li><li><p>The pre-revolutionary writing in the colonies was essentially of two kinds:   分为两类</p><ol><li>Practical matter-of-fact accounts of farming,hunting,travel,etc.designed to inform people “at home” what life was like in the new world,and,often,to induce their immigration</li><li>Highly theoretical,generally polemical,discussions of religious questions</li></ol></li></ul><h2 id="The-first-American-writer"><a href="#The-first-American-writer" class="headerlink" title="The first American writer"></a>The first American writer</h2><ul><li><p>The first writings that we call American were the narratives and journals of these settlements.They wrote about their voyage to the new land,their lives in the new land,their dealings with indians.</p></li><li><p>Captain John Smith is the first American writer.</p></li><li><p>A true Relation of such Occurrences and Accidents of Note as Hath Happened in verginia since the First Planting of That Colony.(1608)</p></li><li><p>A Map of virginia: A Description of the Country(1612)</p></li><li><p>General History of Virginia(1624):the Indian princess Pocahontas.</p></li><li><p><strong>Captain John Smith</strong></p><ul><li>was one of the first early 17th century British settlers in North America.</li><li>One of the things he wrote about that has become an American legend was his capture by the Indians and his rescue by the famous Indian Princess,Pocahontas.</li><li>宝嘉康蒂</li></ul></li></ul><h2 id="Puritan-Thoughts-（重点）"><a href="#Puritan-Thoughts-（重点）" class="headerlink" title="Puritan Thoughts   （重点）"></a>Puritan Thoughts   （重点）</h2><ul><li>the origin of puritan<ul><li>in the mediaeval Europe,there was widespread religious revolution.In the 16th Century,the English King Henry VIII(At that time)，the Catholics were not allowed to divorce unless they have the Pope’s permission.</li><li>Henry VIII wanted to divorce his wife because she couldn‘t bear him a son.But the pope didn’t allow him    to divorce,so he broke away the roman catholics Church&amp;established the Church of England.</li><li>But there was no radical difference between the doctrines of the Church of England and the Catholic Church.A group of people thought the church of England was too Catholic and wanted to purify the church.</li><li>Then came the name Puritans.</li></ul></li></ul><ul><li>Puritanism is the practises and beliefs on the Puritans.<ul><li>The puritans were originally members of a division of the Protestant Church,who came into existence in the reigns of Queen Elizabeth and King James I.</li><li>The first settlers who became the founding fathers of the American nation were quite a few of them Puritans.</li><li>They came to America out of various reasons,but it should be remembered that they were a group of serious,religious people,advocating highly religious and moral principles.As the word itself hints,Puritans wanted to purify their religous beliefs and practices.They felt that the Church of England was too close to the Church of Rome in doctrine from worship,and organization of authority.</li></ul></li></ul><h3 id="主要教义-predestination"><a href="#主要教义-predestination" class="headerlink" title="主要教义 predestination"></a>主要教义 predestination</h3><ol><li>God’s elect<ul><li>Puritans believed they are predestined before they were born.</li><li>Nothing or no good work can change their fate.</li><li>They believed the success of one’s business is the sign to show he is the God‘s elect.So the Puritans works very hard,spend very little and invest more for the future business.They lived a very frugal life.This is their ethics.</li></ul></li><li>Original sin and total depravity<ul><li>Man is born sinful.This determines some puritans pessimistic attitude towards life.</li></ul></li><li>Limited atonement(the salvation of a selected few)</li><li>theocracy  政教合一<ul><li>They combined state with religion.Their government is at least not a liberal one</li><li>The puritans established American tradition–intolerant moralism.They strictly punished drunks,adultery&amp;heretics</li><li>Puritans changed gradually due to the severity of frontier environment.</li></ul></li></ol><h3 id="影响Influence"><a href="#影响Influence" class="headerlink" title="影响Influence"></a>影响Influence</h3><ol><li>its optimism<ul><li>American literature was from the outset conditioned by the Puritan heritage.It can be said American literature is based on the Biblical myth.After Adam and Eve were driven out of the Garden of Eden,man have on illusion to restore the paradise.The puritans,after arriving at America,believing that God must have sent them to this new land to restore the lost paradise,to build the wildness into a new Garden of Eden.Fired with such a strong sense of mission,they treated life with a tremendous amount of optimism.The optimistic Puritans has exerted a great influence on American literature.</li></ul></li><li>Puritan’s metaphorical mode of perception changed gradually into a literary symbolism.</li></ol><h2 id="American-Dream"><a href="#American-Dream" class="headerlink" title="American Dream"></a>American Dream</h2><ul><li><p>The <strong>American</strong> <strong>Dream</strong> is a national ethos of the United States,a set of ideals in which freedom includes….</p></li><li><p>The idea of the American Dream is rooted in the United States Declaration of Independence which proclaims that”all men are created equal” and that they are “endowed by their Creator with certain inalienable Rights”including “life,Liberty and the pursuit of Happiness.”</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美国文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.8 安全性测试</title>
      <link href="/posts/41073.html"/>
      <url>/posts/41073.html</url>
      
        <content type="html"><![CDATA[<h1 id="安全性测试定义"><a href="#安全性测试定义" class="headerlink" title="安全性测试定义"></a>安全性测试定义</h1><h2 id="软件安全性测试就是"><a href="#软件安全性测试就是" class="headerlink" title="软件安全性测试就是"></a>软件安全性测试就是</h2><ul><li>检验系统权限设置有效性</li><li>防范违法入侵的能力</li><li>数据备份和恢复能力等</li><li>设法找出各种安全性漏洞</li></ul><h2 id="漏洞举例："><a href="#漏洞举例：" class="headerlink" title="漏洞举例："></a>漏洞举例：</h2><ul><li>跨站点脚本(cross-site scripting , XSS)攻击</li><li>SQL注入式漏洞</li><li>缓冲区溢出</li><li>不安全的数据存储或传递</li><li>不安全的配置管理</li><li>有问题的访问控制、权限分配有问题</li><li>口令设置不严、包括长度、构成和更新频</li><li>暴露的端口或入口</li></ul><h1 id="安全性测试的范围"><a href="#安全性测试的范围" class="headerlink" title="安全性测试的范围"></a>安全性测试的范围</h1><ul><li>系统级别的安全性</li><li>应用程序级别的安全性（important）<ul><li>用户权限</li><li>数据输入验证</li><li>敏感数据加密</li><li>数据存储安全性</li><li>用户口令</li><li>验证系统的日志文件是否得到保护</li></ul></li></ul><h1 id="web安全性测试"><a href="#web安全性测试" class="headerlink" title="web安全性测试"></a>web安全性测试</h1><ul><li>跨站脚本攻击</li><li>SQL注入式攻击</li><li>URL和API的身份验证</li><li>其他</li></ul><h1 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h1><ul><li>在页面某些输入域中使用跨站脚本（写入一段javascript）来发送恶意代码给没有发觉的用户，让浏览器执行document.write等危险指令<ul><li>窃取用户的资料或者信息</li></ul></li></ul><h1 id="输入域验证"><a href="#输入域验证" class="headerlink" title="输入域验证"></a>输入域验证</h1><ul><li>防止<ul><li>HTML标签：&lt;…&gt;…&lt;/…&gt;</li><li>转义字符：&amp;amp(&amp;);&amp;lt(&lt;);&amp;gt(&lt;);&amp;nbsp(空格)</li><li>脚本语言，如javascript <script language="javascript">......</script></li><li>特殊字符： ‘ ‘ &lt;&gt; /</li></ul></li><li>最好进行更严格的保护和验证</li></ul><h1 id="SQL注入式攻击"><a href="#SQL注入式攻击" class="headerlink" title="SQL注入式攻击"></a>SQL注入式攻击</h1><ul><li>根据SQL语句的编写规则，附加一个永远为”真”的条件<ul><li>使系统中的某个认证条件总是成立</li><li>从而欺骗系统、躲过认证</li><li>进而侵入系统</li></ul></li></ul><h1 id="安全性测试工具的评估标准"><a href="#安全性测试工具的评估标准" class="headerlink" title="安全性测试工具的评估标准"></a>安全性测试工具的评估标准</h1><ul><li>支持常见的web服务器平台</li><li>能同时提供对源代码和二进制文件进行扫描的功能</li><li>漏洞检测和纠正分析</li><li>检测实时系统的问题</li><li>不改变被测试的软件，不影响代码</li><li>良好的报告</li><li>非安全专业认识也易于上手</li><li>可管理部署的多种扫描器、尽可能小的错误误差等</li></ul><h1 id="常见的安全性测试工具"><a href="#常见的安全性测试工具" class="headerlink" title="常见的安全性测试工具"></a>常见的安全性测试工具</h1><p><img src="/posts/41073/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.jpg" alt="安全性测试工具"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7 兼容性测试</title>
      <link href="/posts/14844.html"/>
      <url>/posts/14844.html</url>
      
        <content type="html"><![CDATA[<h1 id="兼容性测试的定义"><a href="#兼容性测试的定义" class="headerlink" title="兼容性测试的定义"></a>兼容性测试的定义</h1><p>兼容性测试</p><ul><li>是在 <strong>不同软硬件环境</strong> 下，验证软件系统能否正常地运行</li><li>这些软硬件一般有但不限于以下种类：<ul><li>硬件 hardware</li><li>操作系统 </li><li>数据库 </li><li>浏览器 </li><li>第三方系统</li><li>内部业务系统</li><li>自身系统的不同版本的用户数据</li></ul></li></ul><h1 id="兼容性测试的内容"><a href="#兼容性测试的内容" class="headerlink" title="兼容性测试的内容"></a>兼容性测试的内容</h1><ul><li>硬件兼容性的测试</li><li>数据兼容性的测试</li><li>系统版本之间的兼容性</li></ul><ul><li>向后兼容：<ul><li>指新发布的软件版本可以使用该软件的以前版本所产生的数据</li></ul></li><li>向前兼容：<ul><li>指在设计和开发一个新版本时，考虑如何和未来版本的数据兼容</li></ul></li></ul><h1 id="系统兼容性测试"><a href="#系统兼容性测试" class="headerlink" title="系统兼容性测试"></a>系统兼容性测试</h1><ul><li>B/S系统兼容性测试（考虑兼容哪个浏览器）</li><li>C/S系统兼容性测试（考虑兼容哪个客户端）</li></ul><h1 id="数据兼容性测试"><a href="#数据兼容性测试" class="headerlink" title="数据兼容性测试"></a>数据兼容性测试</h1><ul><li>是否遵守统一的国际标准、国家标准或业界认可的事实标准等</li><li>提供相应的导入、导出功能</li><li>剪贴板或ODBC等类似方法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 性能测试工具</title>
      <link href="/posts/30377.html"/>
      <url>/posts/30377.html</url>
      
        <content type="html"><![CDATA[<h1 id="特性及其使用"><a href="#特性及其使用" class="headerlink" title="特性及其使用"></a>特性及其使用</h1><ul><li>能模拟实际用户的 <strong>操作行为</strong>，<ul><li><strong>记录和回放</strong> <strong>多用户</strong> 测试中的 <strong>事务处理过程</strong></li><li><strong>自动生成</strong>相应的 <strong>测试脚本</strong></li></ul></li><li>能针对 <strong>脚本</strong> 进行修改<ul><li>增加 <strong>逻辑控制</strong></li><li>完成 <strong>参数化</strong> 和 <strong>数据关联</strong></li></ul></li><li>可以设置不同的 <strong>应用环境和场景</strong>，通过 <strong>虚拟用户</strong> 执行相应的测试脚本</li><li>通过 <strong>系统监控工具</strong> 获得系统性能的相关指标的值</li></ul><h1 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h1><h2 id="nGrinder"><a href="#nGrinder" class="headerlink" title="nGrinder"></a>nGrinder</h2><ul><li>是一个基于Grinder 开发的、易于管理和使用的、分布式性能测试系统</li></ul><h2 id="Flood"><a href="#Flood" class="headerlink" title="Flood"></a>Flood</h2><ul><li>是人们经常使用的一个Web性能测试工具</li></ul><h2 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h2><ul><li>是一个开源的web压力测试和评测系统</li></ul><h2 id="openSTA"><a href="#openSTA" class="headerlink" title="openSTA"></a>openSTA</h2><ul><li>可以模拟大量的虚拟用户来完成性能测试</li><li>并通过script来完成丰富的自定义设置</li></ul><h2 id="DBMonster"><a href="#DBMonster" class="headerlink" title="DBMonster"></a>DBMonster</h2><ul><li>是一个生成随机数据</li><li>用来测试SQL数据库的压力测试工具</li></ul><h2 id="LoadSim"><a href="#LoadSim" class="headerlink" title="LoadSim"></a>LoadSim</h2><ul><li>网络应用程序的负载模拟器</li></ul><h1 id="商业工具"><a href="#商业工具" class="headerlink" title="商业工具"></a>商业工具</h1><ul><li>HP LoadRunner</li><li>IBM Rational performance Tester</li><li>Radview webload</li><li>compuware QA Load</li><li>Quest Benchmark Factory</li><li>微软WAS (web access stress test)</li><li>Paessler Webserver Stress Tool</li><li>MINQ PureLoad</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 压力测试</title>
      <link href="/posts/27406.html"/>
      <url>/posts/27406.html</url>
      
        <content type="html"><![CDATA[<h1 id="压力测试的定义"><a href="#压力测试的定义" class="headerlink" title="压力测试的定义"></a>压力测试的定义</h1><ul><li>是在系统（eg：CPU、内存、网络带宽等）处于 <strong>饱和</strong> 状态下</li><li>测试系统<ul><li>是否还具有正常的 <strong>会话</strong> 能力、<strong>数据处理</strong> 能力</li><li>或 是否会 <strong>出现错误</strong></li></ul></li><li>以检查软件系统对 <strong>异常情况的抵抗</strong> 能力</li><li>找出 <strong>性能瓶颈</strong>、<strong>功能不稳定性</strong> 等问题</li></ul><h1 id="压力测试的类型"><a href="#压力测试的类型" class="headerlink" title="压力测试的类型"></a>压力测试的类型</h1><h2 id="稳定性压力测试"><a href="#稳定性压力测试" class="headerlink" title="稳定性压力测试"></a>稳定性压力测试</h2><ul><li>高负载下持续运行24小时以上的压力测试</li></ul><h2 id="破坏性压力测试"><a href="#破坏性压力测试" class="headerlink" title="破坏性压力测试"></a>破坏性压力测试</h2><ul><li>通过不断加载的手段</li><li>快速总成系统的崩溃</li><li>让问题尽快地暴露出来</li></ul><h2 id="渗入测试"><a href="#渗入测试" class="headerlink" title="渗入测试"></a>渗入测试</h2><ul><li><p><strong>soak</strong> <strong>test</strong></p></li><li><p>通过长时间运行</p></li><li><p>使问题逐渐渗透出来</p></li><li><p>从而发现</p><ul><li><p>内存泄漏</p></li><li><p>垃圾收集 <strong>GC</strong></p></li><li><p>或系统的其他问题</p><p>以检验系统的 <strong>健壮性</strong></p></li></ul></li></ul><h2 id="峰谷测试"><a href="#峰谷测试" class="headerlink" title="峰谷测试"></a>峰谷测试</h2><ul><li><strong>peak-rest test</strong></li><li>采用 <strong>高低突变加载方式</strong> 进行<ul><li>先加载到 <strong>高水平</strong> 的负载</li><li>然后 <strong>急剧降低</strong> 负载</li><li><strong>稍微平息</strong> 一段时间</li><li>再加载到 <strong>高水平</strong> 的负载</li></ul></li><li><strong>重复</strong> 这样的过程</li><li>容易发现问题的 <strong>蛛丝马迹</strong></li><li>最终找到问题的 <strong>根源</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 性能测试</title>
      <link href="/posts/11040.html"/>
      <url>/posts/11040.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何确定性能需求"><a href="#如何确定性能需求" class="headerlink" title="如何确定性能需求"></a>如何确定性能需求</h1><h2 id="性能指标预期来源"><a href="#性能指标预期来源" class="headerlink" title="性能指标预期来源"></a>性能指标预期来源</h2><ol><li><strong>最终用户的体验</strong>      eg:2-5-10原则</li><li><strong>商业需求</strong>        eg：”比竞争对手的产品好”</li><li><strong>技术需求</strong>        eg：”cpu使用率不超过70%”</li><li><strong>标准要求</strong></li></ol><h2 id="包含下列性能指标："><a href="#包含下列性能指标：" class="headerlink" title="包含下列性能指标："></a>包含下列性能指标：</h2><ol><li><strong>时间</strong> time<ul><li>响应时间</li><li>页面下载时间等等</li></ul></li><li><strong>容量</strong> capacity<ul><li>正常工作能承受的最大负载</li><li>eg：<ul><li>最大并发用户数</li><li>最大数据容量</li><li>最大在线用户数</li></ul></li></ul></li><li><strong>吞吐量</strong> throughput<ul><li>eg：<ul><li>每秒请求数RPS</li><li>每秒点击数HPS</li><li>每秒事务数TPS</li><li>每秒接受或发送的数据量等</li></ul></li></ul></li><li><strong>系统资源利用率</strong> utilization<ul><li>eg：<ul><li>cpu</li><li>memory<ul><li>使用率</li></ul></li><li>等等</li></ul></li></ul></li></ol><h2 id="不同角色对于性能指标关注什么"><a href="#不同角色对于性能指标关注什么" class="headerlink" title="不同角色对于性能指标关注什么"></a>不同角色对于性能指标关注什么</h2><h3 id="用户："><a href="#用户：" class="headerlink" title="用户："></a>用户：</h3><ul><li>响应时间</li></ul><h3 id="产品市场团队"><a href="#产品市场团队" class="headerlink" title="产品市场团队"></a>产品市场团队</h3><ul><li>容量</li><li>数据吞吐量</li></ul><h3 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h3><ul><li>系统资源占用率</li></ul><h1 id="性能测试类型"><a href="#性能测试类型" class="headerlink" title="性能测试类型"></a>性能测试类型</h1><h2 id="性能验证测试"><a href="#性能验证测试" class="headerlink" title="性能验证测试"></a>性能验证测试</h2><ul><li>验证事先已定义的系统性能指标、系统能否满足系统的性能需求</li></ul><h2 id="性能基准测试"><a href="#性能基准测试" class="headerlink" title="性能基准测试"></a>性能基准测试</h2><ul><li>在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线</li></ul><h2 id="性能规划测试"><a href="#性能规划测试" class="headerlink" title="性能规划测试"></a>性能规划测试</h2><ul><li>在多种 <strong>特定</strong> 的环境下，获得 <strong>不同配置</strong> 的系统的 <strong>性能指标</strong> ，从而决定在系统部署时采用什么样的 <strong>软</strong>、<strong>硬件配置</strong></li></ul><h2 id="容量测试"><a href="#容量测试" class="headerlink" title="容量测试"></a>容量测试</h2><ul><li>可以看作是 <strong>性能</strong> 的测试的一种</li><li>因为系统的容量可以看作 <strong>系统性能指标</strong> 之一</li></ul><h1 id="性能测试步骤"><a href="#性能测试步骤" class="headerlink" title="性能测试步骤"></a>性能测试步骤</h1><ol><li>确定性能测试 <strong>需求</strong></li><li><strong>计划和设计测试</strong> ；包括确定关键业务流程、测试类型和测试方法，选择合适的测试工具、设计测试场景等等</li><li><strong>测试工具</strong> 的选择</li><li>配置 <strong>测试环境</strong>、尽量接近实际运行环境、即建立仿真环境作为性能测试环境，测试结果才能可信</li><li>实现 <strong>测试设计</strong>（开发测试脚本）</li><li><strong>执行测试</strong></li><li><strong>分析</strong> 测试结果</li><li>重复4-6步骤，直至 <strong>测试计划完成</strong> ，结果 <strong>满意</strong></li><li>提交 <strong>性能测试报告</strong></li></ol><h1 id="一些常见的性能问题"><a href="#一些常见的性能问题" class="headerlink" title="一些常见的性能问题"></a>一些常见的性能问题</h1><ul><li><strong>资源泄漏</strong>，包括内存泄漏</li><li><strong>资源瓶颈</strong>，内部资源（线程、放入池的对象）变得稀疏</li><li>cpu使用率达到<strong>100</strong>%、系统 <strong>被锁定</strong> （eg：鼠标键盘不响应）等等</li><li>线程 <strong>死锁</strong>、线程 <strong>阻塞</strong> 等等</li><li><strong>数据库连接</strong> 成为性能瓶颈（数据库连接时间过长）</li><li>查询 <strong>速度慢</strong> 或 列表 <strong>效率低</strong>（eg:没用上索引）</li><li>受 <strong>外部系统影响</strong> 越来越大</li></ul><h1 id="容量测试-1"><a href="#容量测试-1" class="headerlink" title="容量测试"></a>容量测试</h1><h2 id="容量测试的定义"><a href="#容量测试的定义" class="headerlink" title="容量测试的定义"></a>容量测试的定义</h2><ul><li><p><strong>capacity</strong> test</p></li><li><p>通过负载测试或其它测试方法，预先分析出反应软件系统应用特征的某项指标的极限值（eg：最大并发用户数、数据库记录数等等）</p></li><li><p>在其极限值状态下系统主要功能还能保持正常运行</p></li></ul><h2 id="与其他测试的关系"><a href="#与其他测试的关系" class="headerlink" title="与其他测试的关系"></a>与其他测试的关系</h2><ul><li>属于性能测试的一种</li></ul><h2 id="采用的方法"><a href="#采用的方法" class="headerlink" title="采用的方法"></a>采用的方法</h2><ul><li>一般采用 逐步加载 的负载测试方法</li><li>也可以<ul><li>先采用 <strong>逐步加载</strong> 的方式</li><li>获得一个 基本的 <strong>容量值或容量范围</strong></li><li>再考虑用 <strong>一次性加载方式</strong></li><li>来决定 <strong>实际可支持</strong> 的 <strong>容量值</strong></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 负载测试技术</title>
      <link href="/posts/19168.html"/>
      <url>/posts/19168.html</url>
      
        <content type="html"><![CDATA[<h1 id="pre：演示一个使用JMETER的例子"><a href="#pre：演示一个使用JMETER的例子" class="headerlink" title="pre：演示一个使用JMETER的例子"></a>pre：演示一个使用JMETER的例子</h1><h2 id="背景要求："><a href="#背景要求：" class="headerlink" title="背景要求："></a>背景要求：</h2><p>当120个用户同时访问ecshop,其中所有的用户会访问首页并搜索商品</p><p>要求平均响应时间&lt;=2000ms,并且cpu的利用率&lt;=75%</p><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>先启动xapp，把apache和mysql打开</p><p><img src="/posts/19168/Xapp.png" alt="Xapp"></p><p>jmeter启动测试计划 <code>pre7.3</code></p><p><img src="/posts/19168/jmeter.png" alt="jmeter"></p><ul><li><code>User</code> <code>Defined</code> <code>Variable</code><ul><li>用户定义变量</li></ul></li><li><code>HTTP Request Defaults</code><ul><li>HTTP请求的默认值</li></ul></li><li><code>HTTP Cookie Manager</code><ul><li>http cookie管理器</li></ul></li><li><code>Thread Group</code><ul><li>线程</li><li>模仿用户给服务器发请求</li><li>![thread group](7-3-负载测试技术/thread group.png)<ul><li><code>number of threads</code>:<ul><li>线程数</li></ul></li><li><code>ramp-up preriod</code><ul><li>执行完这些线程所用的时间 （秒数）</li></ul></li><li><code>loop</code> <code>count</code><ul><li>循环次数</li><li>infinite:无限循环</li></ul></li></ul></li></ul></li></ul><p><img src="/posts/19168/%E9%87%87%E6%A0%B7%E5%99%A8.png" alt="采样器"></p><p><code>uniform random timer</code></p><p><img src="/posts/19168/%E5%AE%9A%E6%97%B6%E5%99%A8.png" alt="定时器"></p><ul><li>采样器 就是发请求出去</li><li>有请求发出去，则自然要有监听器</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 负载测试 压力测试 性能测试</title>
      <link href="/posts/60505.html"/>
      <url>/posts/60505.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景及其分析"><a href="#背景及其分析" class="headerlink" title="背景及其分析"></a>背景及其分析</h1><h2 id="性能调优："><a href="#性能调优：" class="headerlink" title="性能调优："></a>性能调优：</h2><ul><li>指系统性能改善是<ul><li>测试</li><li>调整</li><li>再测试</li><li>再调整</li><li>…<ul><li>一个持续改进的过程</li></ul></li></ul></li><li>需要借助负载测试方法</li></ul><h2 id="负载测试-load-test"><a href="#负载测试-load-test" class="headerlink" title="负载测试 load test"></a>负载测试 load test</h2><ul><li>可看成是 <strong>性能测试</strong> 采用的一种技术</li></ul><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>可看作 <strong>负载测试</strong> 的一种</li><li>即  <strong>高负载</strong> 下的 <strong>负载测试</strong></li></ul><h2 id="容量测试-capacity-test"><a href="#容量测试-capacity-test" class="headerlink" title="容量测试 capacity test"></a>容量测试 capacity test</h2><ul><li>用 <strong>负载测试</strong> 技术来实现</li><li><strong>压力测试</strong> 可附带做 <strong>容量测试</strong></li></ul><h2 id="负载测试与性能测试相似性"><a href="#负载测试与性能测试相似性" class="headerlink" title="负载测试与性能测试相似性"></a>负载测试与性能测试相似性</h2><ul><li>测试方法接近</li><li>都关注系统性能</li><li>多数情况下用相同测试工具</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="负载测试-load-rest"><a href="#负载测试-load-rest" class="headerlink" title="负载测试 load rest"></a>负载测试 load rest</h2><ul><li>通过模拟实际软件系统所承受的<ul><li>负载条件</li><li>改变系统负载大小</li><li>负载方式<ul><li>来发现系统中所存在的问题</li></ul></li></ul></li><li>负载大小可以是<ul><li>并发请求的数量(RPS 每秒请求数)</li><li>并发用户数量</li><li>数据库大小</li><li>收发数据大小</li><li>等等</li></ul></li></ul><h2 id="压力测试-1"><a href="#压力测试-1" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>是在 <strong>强负载</strong> 情况下稳定性进行测试</li><li>查看应用系统在 <strong>峰值</strong>（瞬间使用高峰）使用情况下的行为表现</li><li>更有效地发现系统 <strong>稳定性的隐患</strong> 和系统在负载峰值的条件下 <strong>功能隐患</strong> 等</li><li>确认系统是否具有良好的 <strong>容错</strong> 能力和 <strong>可恢复</strong> 能力</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>是为了 <strong>获取</strong> 或 <strong>验证</strong> 系统性能指标</li><li>或为了发现 <strong>性能瓶颈</strong> 而进行的测试</li></ul><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><h2 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>测试被测系统是否满足 <strong>预期性能目标</strong></li></ul><h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><ul><li>测试被测试系统</li><li>在 <strong>服务器安全范围</strong> 内的 <strong>最大负载值</strong></li></ul><h2 id="压力测试-2"><a href="#压力测试-2" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>测试被测试系统</li><li>在 <strong>超过服务器安全范围</strong> 所能承受的 <strong>最大压力值</strong></li></ul><h2 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h2><ul><li>测试被测系统在 <strong>长时间的压力</strong> 下的 <strong>稳定性</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程基础知识简介</title>
      <link href="/posts/18088.html"/>
      <url>/posts/18088.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h2><ul><li>包括：<ul><li>需求分析</li><li>系统设计</li><li>系统实现</li><li>测试</li><li>发布</li><li>运行和维护</li><li>升级</li><li>淘汰</li></ul></li></ul><h2 id="软件主要的测试工作"><a href="#软件主要的测试工作" class="headerlink" title="软件主要的测试工作"></a>软件主要的测试工作</h2><ul><li>随着 <strong>系统实现阶段</strong> 的展开而开始</li><li>一直持续到 <strong>产品发布</strong> 之后</li></ul><h2 id="软件的质量保证活动QA"><a href="#软件的质量保证活动QA" class="headerlink" title="软件的质量保证活动QA"></a>软件的质量保证活动QA</h2><ul><li>伴随着软件整个生命周期</li><li>原因：<ul><li>为了度量、跟踪、控制软件产品的质量</li></ul></li></ul><h1 id="2-软件开发流程简述"><a href="#2-软件开发流程简述" class="headerlink" title="2 软件开发流程简述"></a>2 软件开发流程简述</h1><h2 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h2><h3 id="需求分析的定义"><a href="#需求分析的定义" class="headerlink" title="需求分析的定义"></a>需求分析的定义</h3><ul><li>是开发人员经过深入细致的调研和分析，准确理解用户和项目的<ul><li>功能</li><li>性能</li><li>可靠性<ul><li>等具体要求</li></ul></li></ul></li><li>将用户 <strong>非形式的需求</strong> 转化为 <strong>完整的需求定义</strong> </li><li>从而确定系统 <strong>必须做什么</strong> 的过程</li></ul><h3 id="需求分析中需明白的几个概念"><a href="#需求分析中需明白的几个概念" class="headerlink" title="需求分析中需明白的几个概念"></a>需求分析中需明白的几个概念</h3><h4 id="业务需求："><a href="#业务需求：" class="headerlink" title="业务需求："></a>业务需求：</h4><ul><li>是由高层领导提出的业务上要满足的需求</li><li>目的：<ul><li>解决业务通电</li></ul></li><li>通常比较宏观</li></ul><h4 id="用户需求："><a href="#用户需求：" class="headerlink" title="用户需求："></a>用户需求：</h4><ul><li>使用户从自身角度出发，自己所认为的需求</li><li>也可以看作将业务需求具体化之后的需求</li></ul><h4 id="产品需求："><a href="#产品需求：" class="headerlink" title="产品需求："></a>产品需求：</h4><ul><li>是通过分析提炼得到的用户的真实需求</li><li>且符合产品定位的解决方案</li><li>一般来说，产品需求等同于系统需求</li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="系统设计的定义："><a href="#系统设计的定义：" class="headerlink" title="系统设计的定义："></a>系统设计的定义：</h3><ul><li>是根据需求分析的结果</li><li>是对软件的技术实现由粗到细进行设计的过程</li></ul><h3 id="系统设计的两个阶段："><a href="#系统设计的两个阶段：" class="headerlink" title="系统设计的两个阶段："></a>系统设计的两个阶段：</h3><ul><li>概要设计</li><li>详细设计</li></ul><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><h4 id="概要设计的任务："><a href="#概要设计的任务：" class="headerlink" title="概要设计的任务："></a>概要设计的任务：</h4><ul><li>根据系统需求分析得到的系统用例转换为软件结构和数据结构</li></ul><h4 id="概要设计的内容："><a href="#概要设计的内容：" class="headerlink" title="概要设计的内容："></a>概要设计的内容：</h4><ul><li>系统技术架构设计</li><li>功能模块划分和功能设计</li><li>数据库设计</li><li>接口设计</li><li>界面设计</li></ul><h3 id="详细设计："><a href="#详细设计：" class="headerlink" title="详细设计："></a>详细设计：</h3><h4 id="详细设计的定义："><a href="#详细设计的定义：" class="headerlink" title="详细设计的定义："></a>详细设计的定义：</h4><ul><li>对概要设计的细化</li></ul><h4 id="详细设计的内容："><a href="#详细设计的内容：" class="headerlink" title="详细设计的内容："></a>详细设计的内容：</h4><ul><li>算法设计</li><li>函数流程设计</li><li>等等</li></ul><h2 id="2-3-系统实现"><a href="#2-3-系统实现" class="headerlink" title="2.3 系统实现"></a>2.3 系统实现</h2><h3 id="系统实现的定义："><a href="#系统实现的定义：" class="headerlink" title="系统实现的定义："></a>系统实现的定义：</h3><ul><li>即编码</li><li>根据系统设计来进行实际的编码工作</li><li>并得到可以运行的软件产品</li></ul><h2 id="2-4-系统测试"><a href="#2-4-系统测试" class="headerlink" title="2.4 系统测试"></a>2.4 系统测试</h2><h3 id="系统测试的定义："><a href="#系统测试的定义：" class="headerlink" title="系统测试的定义："></a>系统测试的定义：</h3><ul><li>对源代码或可以运行的程序进行检查或执行</li><li>判断被测系统事都存在与需求中的预期不一致的地方</li><li>并加以记录的过程</li></ul><h2 id="2-5-产品发布和运维"><a href="#2-5-产品发布和运维" class="headerlink" title="2.5 产品发布和运维"></a>2.5 产品发布和运维</h2><p>原因：</p><ul><li>软件发布后，可能会产生问题：<ul><li>用户对产品不熟悉造成使用问题</li><li>开发测试不彻底遗留缺陷</li></ul></li></ul><p>因此：</p><ul><li>要对产品运行<ul><li>进行维护</li><li>进行用户培训</li><li>修复缺陷</li><li>等等</li></ul></li></ul><h2 id="2-6-产品升级"><a href="#2-6-产品升级" class="headerlink" title="2.6 产品升级"></a>2.6 产品升级</h2><p>原因：</p><ul><li>随着用户使用的深入</li><li>软件产品可能无法继续使用用户要求</li></ul><p>因此需要：</p><ul><li>对产品进行升级</li><li>增加新的功能和特性</li><li>优化产品性能</li><li>等等</li></ul><h2 id="2-7-产品淘汰"><a href="#2-7-产品淘汰" class="headerlink" title="2.7 产品淘汰"></a>2.7 产品淘汰</h2><p>原因：</p><ul><li>随着技术不断发展，软件产品可能无法适应业务发展</li></ul><p>因此：</p><ul><li>不得不将产品彻底报废、淘汰</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 质量保证与测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 认识软件测试管理</title>
      <link href="/posts/40593.html"/>
      <url>/posts/40593.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-软件质量与测试"><a href="#1-1-软件质量与测试" class="headerlink" title="1.1 软件质量与测试"></a>1.1 软件质量与测试</h2><h3 id="软件质量的概念"><a href="#软件质量的概念" class="headerlink" title="软件质量的概念"></a>软件质量的概念</h3><ul><li>软件质量越来越受到重视</li><li>ANSI/IEEE&lt;软件工程术语的IEEE标准术语表&gt;定义软件质量为<ul><li>“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”</li></ul></li></ul><h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><ul><li><p>软件产品各种质量特性的组合称为软件质量模型</p></li><li><p>常见的软件质量模型</p><ul><li>Boehm模型 1976年</li><li>MCCALL模型 1978年</li><li>ISO9126软件质量模型 1993年</li></ul></li></ul><h3 id="Boehm质量模型"><a href="#Boehm质量模型" class="headerlink" title="Boehm质量模型"></a>Boehm质量模型</h3><ul><li>1976年由Boehm等提出的分层方案</li><li>将软件的质量定义为分层的模型</li></ul><h4 id="boehm质量模型内容"><a href="#boehm质量模型内容" class="headerlink" title="boehm质量模型内容"></a>boehm质量模型内容</h4><ul><li><strong>可维护性</strong><ul><li><strong>可修改性</strong><ul><li><strong>可扩充性</strong></li><li><strong>结构化性</strong></li></ul></li><li><strong>可理解性</strong><ul><li><strong>清晰性</strong></li><li><strong>简单性</strong></li><li><strong>结构化性</strong></li><li><strong>自描述性</strong> 不需要其他培训 软件上的说明足以指引完成使用</li></ul></li><li><strong>可测试性</strong><ul><li><strong>结构化性</strong></li><li><strong>自描述性</strong></li><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>可测试性</strong></li></ul></li></ul></li><li><strong>可用性</strong><ul><li><strong>人类工程</strong><ul><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>健壮性</strong></li></ul></li><li><strong>效率</strong><ul><li><strong>可存取性</strong></li><li><strong>设备效率</strong></li><li><strong>可测试性</strong></li></ul></li><li><strong>可靠性</strong><ul><li><strong>一致性</strong></li><li><strong>健壮性</strong></li><li><strong>完备性</strong></li><li><strong>正确性</strong></li><li><strong>自包含性</strong></li></ul></li></ul></li><li><strong>可移植性</strong><ul><li><strong>自包含性</strong></li><li><strong>设备独立性</strong></li></ul></li></ul><h3 id="MCCALL质量模型"><a href="#MCCALL质量模型" class="headerlink" title="MCCALL质量模型"></a>MCCALL质量模型</h3><ul><li>1979年由McCall等人提出的软件质量模型</li><li>将软件质量的概念建立在11个质量特性之上</li><li>这些质量特性分别是面向软件产品的运行、修正和转移的</li></ul><h3 id="ISO9126质量模型"><a href="#ISO9126质量模型" class="headerlink" title="ISO9126质量模型"></a>ISO9126质量模型</h3><ul><li>软件质量模型可以分为：<ul><li>内部质量和外部质量模型、<ul><li>功能性</li><li>可靠性</li><li>易用性</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li>使用质量模型<ul><li>有效性</li><li>生产性</li><li>安全性</li><li>满意度</li></ul></li></ul></li></ul><h3 id="常见的软件质量特性"><a href="#常见的软件质量特性" class="headerlink" title="常见的软件质量特性"></a>常见的软件质量特性</h3><ol><li>性能Performance<ol><li>系统的响应能力</li><li>即 要经过多长时间才能对某个时间做出响应</li><li>或者在某段时间内系统所能处理的事件个数</li></ol></li><li>可用性Availability<ol><li>系统能正常运行的时间比例</li></ol></li><li>可靠性Rvailability<ol><li>系统在应用或错误面前，在意外或者错误使用的情况下维持软件系统功能特性的能力</li></ol></li><li>健壮性Robustness<ol><li>在处理或者环境中系统能够承受的压力或者变更能力</li></ol></li><li>安全性Security<ol><li>系统向合法用户提供服务的同时能够阻止非授权用户使用企图或拒绝服务的能力</li></ol></li></ol><h3 id="软件质量保证的手段"><a href="#软件质量保证的手段" class="headerlink" title="软件质量保证的手段"></a>软件质量保证的手段</h3><ul><li>软件测试</li><li>软件研发过程保证</li><li>软件研发配置管理</li><li>…</li></ul><h3 id="软件测试-vs-软件质量"><a href="#软件测试-vs-软件质量" class="headerlink" title="软件测试 vs 软件质量"></a>软件测试 vs 软件质量</h3><ul><li>软件测试是保证软件质量的重要手段之一</li><li>软件测试是有计划有组织的活动</li><li>软件测试管理确保测试活动的顺利开展</li></ul><h2 id="1-2-软件测试管理概述"><a href="#1-2-软件测试管理概述" class="headerlink" title="1.2 软件测试管理概述"></a>1.2 软件测试管理概述</h2><h3 id="项目与项目管理"><a href="#项目与项目管理" class="headerlink" title="项目与项目管理"></a>项目与项目管理</h3><ul><li>项目：<ul><li>一系列复杂的并相互关联的活动</li><li>有着一个明确的目标</li><li>必须在特定的时间、预算、资源限定内，依据规范完成</li></ul></li><li>项目管理：<ul><li>在项目活动中运用专门的知识、技能、工具或方法</li><li>使项目能够在有限资源限定条件下，实现预定的目标</li></ul></li><li>范畴：<ul><li>范围管理</li><li>时间管理</li><li>费用管理</li><li>质量管理</li><li>人力资源管理</li><li>风险管理</li><li>沟通管理</li><li>采购与合同管理</li></ul></li></ul><h3 id="软件测试管理-vs-软件项目管理"><a href="#软件测试管理-vs-软件项目管理" class="headerlink" title="软件测试管理 vs 软件项目管理"></a>软件测试管理 vs 软件项目管理</h3><ul><li>软件测试管理是忒数的软件项目管理<ul><li>与软件项目管理密切相关，有时从属于软件项目管理的一部分</li><li>可以借用软件项目管理的办法</li><li>因任务特点有自身特殊的知识、流程、方法、工具</li></ul></li></ul><h3 id="软件测试管理的要素"><a href="#软件测试管理的要素" class="headerlink" title="软件测试管理的要素"></a>软件测试管理的要素</h3><ul><li>测试过程与测试资产管理<ul><li>建立并维护测试的过程</li><li>建立并维护测试过程中建立的指南、模板、评审单等</li><li>管理测试工作相关的资产</li></ul></li><li>测试需求管理<ul><li>收集需求</li><li>分析需求</li><li>测试需求跟踪</li></ul></li><li>测试计划管理<ul><li>制定计划</li><li>执行计划</li><li>监控计划</li></ul></li><li>测试缺陷管理<ul><li>报告测试缺陷</li><li>回归测试发现的缺陷</li><li>缺陷分析</li></ul></li><li>测试工具管理<ul><li>选择测试工具</li><li>维护测试工具</li></ul></li><li>测试团队管理<ul><li>建立并维护测试团队</li><li>团队日常管理</li><li>团队绩效管理</li></ul></li></ul><h2 id="1-3-软件测试管理工具"><a href="#1-3-软件测试管理工具" class="headerlink" title="1.3 软件测试管理工具"></a>1.3 软件测试管理工具</h2><h3 id="软件测试工具"><a href="#软件测试工具" class="headerlink" title="软件测试工具"></a>软件测试工具</h3><ul><li>自动化测试工具<ul><li>单元测试工具</li><li>性能测试工具</li><li>功能测试工具</li><li>…</li></ul></li><li>软件测试管理工具<ul><li>ALM</li><li>BUGzilla：<a href="https://www.bugzilla.org/" target="_blank" rel="noopener">https://www.bugzilla.org/</a></li><li>Jira</li><li>禅道：<a href="https://www.zentao.net/" target="_blank" rel="noopener">https://www.zentao.net/</a></li><li>…</li></ul></li></ul><h3 id="软件测试管理工具的分类"><a href="#软件测试管理工具的分类" class="headerlink" title="软件测试管理工具的分类"></a>软件测试管理工具的分类</h3><ul><li>专项测试管理工具<ul><li>只管理软件测试中的某项内容<ul><li>如缺陷管理工具、</li><li>用例管理工具</li></ul></li><li>如BUGzilla是缺陷管理工具</li></ul></li><li>专门测试管理工具<ul><li>对测试的整个流程进行管理</li><li>如IBM Rational Quality Manager</li><li>HP ALM(Application lifecycle Management)等</li></ul></li><li>覆盖开发和测试的项目管理工具<ul><li>覆盖整个研发周期的项目管理工具</li><li>特别适用于研发测试齐全的产品研发团队</li><li>如：禅道项目管理软件</li></ul></li><li>其他<ul><li>借助办公软件和文档管理软件完成测试管理</li><li>办公软件:Office Project\Word\Excel</li><li>文档管理软件：如TortoiseSVN\TortoiseHg</li></ul></li></ul><h3 id="软件测试管理工具的选择"><a href="#软件测试管理工具的选择" class="headerlink" title="软件测试管理工具的选择"></a>软件测试管理工具的选择</h3><ul><li><p>选择测试管理工具应该综合考虑</p><ul><li>项目大小</li><li>团队规模</li><li>团队结构</li><li>成本预算</li></ul></li><li><p>工具是一个载体，</p><ul><li><p>可以提高工作效率，减少错误发生</p></li><li><p>更重要的是，利用知识和规范的流程完成项目，从而灵活运用工具</p></li></ul></li></ul><table><thead><tr><th>团队种类</th><th>建议选择</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td>小规模初创团队（如创业项目、学生项目等）</td><td>专项管理的开源工具或办公软件</td><td>节省成本、简单易用</td><td>Bugzilla      jira免费版 Office、Wps   文档管理软件TortoiseSVN  各种在线缺陷管理工具</td></tr><tr><td>第三方测试团队（专门提供测试服务的机构）</td><td>专门的测试管理工具</td><td>对测试全流程进行管理</td><td>IBM Rational Quality Manager       Hp ALM (Application Lifecycle Management)</td></tr><tr><td>产品研发团队（包括开发和测试人员）</td><td>软件项目管理工具</td><td>对软件开发进行全流程管理</td><td>有非常多的此类商业软件、不再举例，也有很多公司用的是自己研发的产品</td></tr></tbody></table><h3 id="软件测试管理工具的功能"><a href="#软件测试管理工具的功能" class="headerlink" title="软件测试管理工具的功能"></a>软件测试管理工具的功能</h3><ul><li>用户及权限管理</li><li>测试项目的创建</li><li>测试项目需求管理</li><li>测试任务分配和实施</li><li>测试项目缺陷管理</li><li>测试数据收集</li><li>测试项目数据分析统计和报告生成</li><li>测试项目用例管理</li><li>测试执行管理</li><li>测试文档管理</li></ul><h3 id="软件测试管理工具的发展趋势"><a href="#软件测试管理工具的发展趋势" class="headerlink" title="软件测试管理工具的发展趋势"></a>软件测试管理工具的发展趋势</h3><ul><li>与其他软件自动化测试工具集成<ul><li>如可以直接启动各种自动化测试</li></ul></li><li>与软件研发的其他环节集成越来越紧密<ul><li>如代码审查、产品版本管理等</li></ul></li><li>基于云的测试管理工具<ul><li>比如QASymphony开发的QTest是基于云计算的测试管理工具</li></ul></li></ul><h3 id="HP-ALM-测试管理工具简介"><a href="#HP-ALM-测试管理工具简介" class="headerlink" title="HP ALM 测试管理工具简介"></a>HP ALM 测试管理工具简介</h3><h4 id="ALM简介"><a href="#ALM简介" class="headerlink" title="ALM简介"></a>ALM简介</h4><ul><li>HP公司的软件测试管理工具</li><li>HP Application Lifecycle Management（ALM）<ul><li>可提供用于组织和跟踪应用程序版本的系统</li><li>帮助定义并维护需求及测试的库</li></ul></li><li>ALM具有缺陷跟踪系统<ul><li>能够从初始检测开始监控缺陷</li><li>直到问题解决</li></ul></li><li>ALM可以<ul><li>生成演示业务性能各个方面的叫糊涂</li><li>或使用任何截面数据定义报告</li><li>还可以通过在单个视图中并排排列多个图监控多个业务指标</li></ul></li></ul><h4 id="应用ALM优势"><a href="#应用ALM优势" class="headerlink" title="应用ALM优势"></a>应用ALM优势</h4><ul><li>加强开发人员、测试人员和业务分析师之间的协作</li><li>支持构建多级要求、任务、测试、缺陷、源代码和报告</li><li>任务管理有助于提高开发人员和测试人员的工作效率</li><li>同时支持瀑布式和敏捷式方法</li><li>与常见的开放源、商业开发管理解决方案完美集成</li></ul><h4 id="ALM功能"><a href="#ALM功能" class="headerlink" title="ALM功能"></a>ALM功能</h4><ul><li>版本规范</li><li>需求规范</li><li>测试计划</li><li>测试执行</li><li>缺陷跟踪</li></ul><h4 id="ALM服务器站点管理页面"><a href="#ALM服务器站点管理页面" class="headerlink" title="ALM服务器站点管理页面"></a>ALM服务器站点管理页面</h4><p><img src="/posts/40593/%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9.PNG" alt="1"></p><h4 id="ALM客户端登录界面"><a href="#ALM客户端登录界面" class="headerlink" title="ALM客户端登录界面"></a>ALM客户端登录界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.PNG" alt="登录界面"></p><p>登录时除了登录名和密码，还要选择登录的项目</p><p>每次只能登录一个固定的项目</p><h4 id="ALM客户端登陆后的界面"><a href="#ALM客户端登陆后的界面" class="headerlink" title="ALM客户端登陆后的界面"></a>ALM客户端登陆后的界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E5%90%8E%E7%95%8C%E9%9D%A2.PNG" alt="登陆后界面"></p><h4 id="ALM客户端-需求管理"><a href="#ALM客户端-需求管理" class="headerlink" title="ALM客户端-需求管理"></a>ALM客户端-需求管理</h4><p>可以创建需求</p><p>右下角为创建好的需求</p><h4 id="ALM客户端-用例管理"><a href="#ALM客户端-用例管理" class="headerlink" title="ALM客户端-用例管理"></a>ALM客户端-用例管理</h4><p>![用例管理](D:/github blog/ischelsea.github.io/source/_posts/第一章-认识软件测试管理/用例管理.PNG)</p><p>ALM客户端的用例管理称为测试计划</p><p>可以以树的形式来展现，也可以以列表的形式</p><p>可以对应到用例、可以对应到需求</p><p>每个用例有详细信息、设计步骤、参数、测试配置、附件等属性</p><h4 id="ALM客户端-测试实验室（执行管理）"><a href="#ALM客户端-测试实验室（执行管理）" class="headerlink" title="ALM客户端-测试实验室（执行管理）"></a>ALM客户端-测试实验室（执行管理）</h4><p><img src="/posts/40593/%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86.PNG" alt="执行管理"></p><p>实际上就是建立一些测试的集合</p><p>然后去执行这个测试集</p><p>测试集里会包含一群测试用例</p><p>之后可以执行并记录测试用例的执行结果，进行一些分析</p><h4 id="ALM客户端-缺陷管理"><a href="#ALM客户端-缺陷管理" class="headerlink" title="ALM客户端-缺陷管理"></a>ALM客户端-缺陷管理</h4><p><img src="/posts/40593/%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86.PNG" alt="缺陷管理"></p><p>因为缺陷有很多字段</p><p>所以缺陷建立后可以以列表的形式进行查看</p><p>缺陷可以向前关联到相应的测试用例</p><ul><li>缺陷的字段可以自己定义<ul><li>比如说缺陷的功能模块</li><li>每个产品的缺陷功能模块都是不同的</li><li>我们可以在客户端通过项目的自定义来定义缺陷的一些字段</li></ul></li></ul><p>综上</p><p>也就是说，ALM可以实现从需求、到用例、到缺陷的关联</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 软件测试过程管理</title>
      <link href="/posts/5418.html"/>
      <url>/posts/5418.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件研发中的测试"><a href="#2-1-软件研发中的测试" class="headerlink" title="2.1 软件研发中的测试"></a>2.1 软件研发中的测试</h2><h3 id="1-软件研发中的测试活动"><a href="#1-软件研发中的测试活动" class="headerlink" title="1 软件研发中的测试活动"></a>1 软件研发中的测试活动</h3><h4 id="软件测试与软件研发"><a href="#软件测试与软件研发" class="headerlink" title="软件测试与软件研发"></a>软件测试与软件研发</h4><ul><li>软件测试和软件开发一样，都遵循软件工程的原理</li><li>测试是软件研发的一部分，测试和开发时密切相关的</li><li>测试活动是贯穿于软件项目开发的全过程的，和开发活动交互开展</li></ul><h4 id="软件研发生命周期的瀑布模型"><a href="#软件研发生命周期的瀑布模型" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h4><p><img src="/posts/5418/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><h4 id="尽早测试，越晚发现问题成本越高"><a href="#尽早测试，越晚发现问题成本越高" class="headerlink" title="尽早测试，越晚发现问题成本越高"></a>尽早测试，越晚发现问题成本越高</h4><p><img src="/posts/5418/%E5%8F%98%E5%8C%96.png" alt="变化"></p><h4 id="软件研发中的测试环节与测试活动"><a href="#软件研发中的测试环节与测试活动" class="headerlink" title="软件研发中的测试环节与测试活动"></a>软件研发中的测试环节与测试活动</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8.png" alt="测试活动"></p><h4 id="研发中的测试活动：软件需求评审及i系统测试方案制定"><a href="#研发中的测试活动：软件需求评审及i系统测试方案制定" class="headerlink" title="研发中的测试活动：软件需求评审及i系统测试方案制定"></a>研发中的测试活动：软件需求评审及i系统测试方案制定</h4><ol><li><p>软件需求完成后，需要进行需求的评审，此时测试人员可以：</p><ul><li>参与需求的评审</li><li>需求确定后进行系统测试方案及计划的制订</li></ul></li><li><p>软件总体设计完成后，进行总体设计方案评审，此时测试人员可以：</p><ul><li>参与总体设计方案的评审</li><li>开始进行集成测试方案的制定</li></ul></li><li><p>详细设计完成后，测试人员：</p><ul><li>参与详细设计的评审</li><li>开始进行模块测试方案的制定</li></ul></li><li><p>单元测试和编码一般是同步的，由开发人员自己完成的</p></li><li><p>整个模块开发完成后，测试人员开始进行模块测试，在这之前所有的模块测试用例应当已经准备完毕</p></li><li><p>模块测试后是执行集成测试和系统测试</p></li><li><p>软件运行维护期间则要对运行期间发现的问题进行记录和回归测试</p></li></ol><h3 id="2-按照开发阶段对软件测试分类"><a href="#2-按照开发阶段对软件测试分类" class="headerlink" title="2 按照开发阶段对软件测试分类"></a>2 按照开发阶段对软件测试分类</h3><ul><li><p>按照开发阶段划分，软件测试分为：</p><ul><li><p>单元测试</p></li><li><p>集成测试</p></li><li><p>系统测试</p></li><li><p>确认测试</p></li><li><p>验收测试</p></li></ul></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>单元测试又称为模块测试<ul><li>是针对软件设计的最小单位-程序模块进行正确性验证的测试工作</li></ul></li><li>检查程序单元是否满足详细设计说明中的：<ul><li>模块功能</li><li>性能</li><li>接口和设计约束</li><li>发现模块内部错误</li></ul></li><li>白盒和黑盒都会用到</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>集成测试<ul><li>也叫组装测试</li><li>或者联合测试</li></ul></li><li>每个单元正确<ul><li>组装起来不一定能正确工作</li><li>所以要开展集成测试</li></ul></li><li>主要检测单元的接口关系<ul><li>集成为符合概要设计要求的更大的组件</li></ul></li></ul><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><ul><li>检测软件是否满足软件需求说明书中规定的要求</li></ul><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>将同股集成测试的软件<ul><li>作为整个基于计算机系统的一个元素</li><li>与计算机硬件，外设，某些支持软件、数据和人员等其他元素结合在一起</li><li>在实际或模拟环境下进行测试</li></ul></li><li>目的是：<ul><li>通过与系统的需求定义作比较</li><li>发现与系统定义不一致的地方</li></ul></li></ul><h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul><li>按照项目任务书或合同的验收依据对整个系统进行测试与评审</li><li>决定是否接受系统</li></ul><h2 id="2-2-软件测试模型"><a href="#2-2-软件测试模型" class="headerlink" title="2.2 软件测试模型"></a>2.2 软件测试模型</h2><ul><li><h3 id="软件测试模型背景："><a href="#软件测试模型背景：" class="headerlink" title="软件测试模型背景："></a>软件测试模型背景：</h3><ul><li>测试与开发密切相关，通过实践产生了许多测试模型</li><li>这些模型将测试活动进行了抽象<ul><li>明确了测试与开发之间的关系</li><li>是测试管理的重要参考依据</li></ul></li></ul></li></ul><ul><li><h3 id="常见的软件测试模型"><a href="#常见的软件测试模型" class="headerlink" title="常见的软件测试模型"></a>常见的软件测试模型</h3><ul><li>V模型</li><li>W模型</li><li>H模型</li><li>X模型</li><li>前置测试模型</li></ul></li></ul><ul><li><h3 id="软件研发生命周期的瀑布模型-1"><a href="#软件研发生命周期的瀑布模型-1" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h3><ul><li>计划时期：<ul><li>问题定义</li><li>可行性研究</li></ul></li><li>开发时期：<ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>测试</li></ul></li><li>运行时期：<ul><li>运行与维护</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：V模型"><a href="#软件测试模型：V模型" class="headerlink" title="软件测试模型：V模型"></a>软件测试模型：V模型</h3><ul><li>来源：<ul><li>软件开发的瀑布模型</li></ul></li><li>特点：<ul><li>说明了基本的开发过程和测试行为</li><li>明确地标识了测试过程中存在的不同级别以及测试阶段和开发各阶段的关系</li></ul></li><li>局限性：<ul><li>测试对象只有程序代码</li><li>测试作为编码后的活动，未体现“尽早测试”的原则</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：W模型"><a href="#软件测试模型：W模型" class="headerlink" title="软件测试模型：W模型"></a>软件测试模型：W模型</h3><ul><li>演化来源：<ul><li>V模型</li></ul></li><li>与V模型区别：<ul><li>增加了与软件开发阶段同步进行的测试</li></ul></li><li>强调：<ul><li>测试伴随整个软件开发周期</li><li>测试对象不仅是程序，需求、功能和设计同样要测试</li><li>测试与开发同步进行，有利于尽早发现问题</li></ul></li><li>局限性：<ul><li>W与V模型<ul><li>均把软件开发视为需求、设计、编码等一系列串行的活动</li><li>无法支持迭代以及变更调整</li></ul></li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：H模型"><a href="#软件测试模型：H模型" class="headerlink" title="软件测试模型：H模型"></a>软件测试模型：H模型</h3><ul><li>强调：<ul><li>测试活动<ul><li>独立</li><li>贯穿于整个产品周期</li><li>与研发流程并发</li></ul></li><li>循环：<ul><li>测试点准备就绪即可执行测试</li></ul></li><li>测试<ul><li>可尽早进行</li><li>可对被测对象分层次、反复测试</li></ul></li></ul></li><li>某一次测试过程：<ul><li>测试准备</li><li>测试就绪点</li><li>其他流程</li><li>测试执行</li><li>测试流程</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：其他测试模型"><a href="#软件测试模型：其他测试模型" class="headerlink" title="软件测试模型：其他测试模型"></a>软件测试模型：其他测试模型</h3><ul><li>X测试模型:<ul><li>特点：<ul><li>认为”学院派的V模型“不能处理开发的实际时间过程</li><li>比如：<ul><li>频繁重复的集成</li><li>需求文档的缺乏</li></ul></li></ul></li><li>内容：<ul><li>针对单独程序片段所进行的相互分离的编码和测试</li><li>此后进行贫乏明年的交接</li><li>通过集成最终成为可执行的程序</li><li>然后再对这些可执行程序进行测试</li></ul></li></ul></li><li>前置测试模型：<ul><li>测试与开发紧密结合</li><li>对每个交付内容进行测试<ul><li>eg：<ul><li>设计文档</li><li>可行性报告</li></ul></li></ul></li><li>交付内容一旦完成，立即进行测试</li></ul></li></ul></li></ul><ul><li><h3 id="测试模型的使用："><a href="#测试模型的使用：" class="headerlink" title="测试模型的使用："></a>测试模型的使用：</h3><ul><li>模型对工作开展有重要意义<ul><li>但每个模型都不是完美的</li></ul></li><li>灵活运用各个模型的优点<ul><li>还要考虑项目的实际情况</li></ul></li></ul></li></ul><h2 id="2-3-软件测试的流程"><a href="#2-3-软件测试的流程" class="headerlink" title="2.3 软件测试的流程"></a>2.3 软件测试的流程</h2><h3 id="1-软件测试的流程"><a href="#1-软件测试的流程" class="headerlink" title="1.软件测试的流程"></a>1.软件测试的流程</h3><h4 id="测试流程内容："><a href="#测试流程内容：" class="headerlink" title="测试流程内容："></a>测试流程内容：</h4><ul><li>测试过程定义了<ul><li>企业在产品开发过程中在<ul><li>设计</li><li>开发与实现</li><li>维护</li><li>退出</li></ul></li><li>等阶段 与测试相关活动的<ul><li>内容</li><li>流程</li><li>规范</li></ul></li></ul></li><li>测试过程指导：<ul><li>项目如何开展各项测试活动</li><li>以及各项活动的输入输出</li></ul></li><li>测试过程<ul><li>约定活动中所设计的角色与职责</li><li>规范各个活动的内容和章程<ul><li>以及所使用到的统一的<ul><li>模版</li><li>表单</li><li>指导书</li><li>检查单</li></ul></li></ul></li></ul></li></ul><h4 id="测试流程的作用"><a href="#测试流程的作用" class="headerlink" title="测试流程的作用"></a>测试流程的作用</h4><ul><li>给公司在产品开发过程中测试相关的活动<ul><li>提供指导</li><li>确保产品可以真正满足用户要求</li></ul></li></ul><h4 id="测试与开发关系"><a href="#测试与开发关系" class="headerlink" title="测试与开发关系"></a>测试与开发关系</h4><ul><li>软件项目中测试与开发相互配合、同步推进<ul><li>软件项目的复杂性被测对象往往不断变化</li><li>实际项目中测试与开发的关系更加复杂</li></ul></li><li>虽然测试与开发关系复杂，但测试工作的开展有自己的过程要遵循</li><li>对单次测试来说，存在一个一般性的过程</li></ul><h4 id="软件测试一般性过程"><a href="#软件测试一般性过程" class="headerlink" title="软件测试一般性过程"></a>软件测试一般性过程</h4><ol><li>需求分析阶段<ul><li>收集相关资料</li><li>学习业务（测试对象）</li><li>分析测试需求点</li></ul></li><li>测试计划阶段：<ul><li>测试主管<ul><li>组织编写《测试计划》</li><li>该文档指明<ul><li>测试范围</li><li>方法</li><li>资源</li><li>相应测试活动人员时间进度安排</li></ul></li></ul></li><li>测试计划<ul><li>需要进行评审</li><li>测试计划一旦开始执行<ul><li>就要定期监控计划的执行情况</li></ul></li></ul></li></ul></li><li>测试设计与开发<ul><li>测试设计<ul><li>一般由对需求熟悉的资深测试工程师设计</li><li>为每个测试点设计出包括<ul><li>需求点简介</li><li>测试思路</li><li>详细测试方法</li></ul></li><li>三部分的方法</li></ul></li><li>测试开发主要完成：<ul><li>测试用例编写</li><li>测试数据准备</li><li>测试环境准备</li></ul></li><li>测试设计与测试用例完成后需要进行评审</li></ul></li><li>测试执行及报告<ul><li>执行测试用例</li><li>及时提交<ul><li>有质量的bug</li><li>测试阶段报告<ul><li>反馈测试情况</li></ul></li></ul></li></ul></li><li>软件评估报告及批准<ul><li>根据测试结果给出<ul><li>对软件的整体评估</li><li>是否通过测的建议</li></ul></li><li>一般决策部门<ul><li>会根据这份评估报告决定产品是否可以发布vy</li></ul></li></ul></li><li>测试总结及资产归档<ul><li>结项阶段<ul><li>对整个过程进行回顾总结</li><li>将项目相关资源进行整理归档</li></ul></li></ul></li></ol><h3 id="2-软件测试流程的建立和维护"><a href="#2-软件测试流程的建立和维护" class="headerlink" title="2 软件测试流程的建立和维护"></a>2 软件测试流程的建立和维护</h3><h4 id="创建软件测试流程注意事项"><a href="#创建软件测试流程注意事项" class="headerlink" title="创建软件测试流程注意事项"></a>创建软件测试流程注意事项</h4><ul><li>从实际情况出发<ul><li>优化流程</li><li>解决问题u</li></ul></li><li>重点考虑四个问题：<ul><li>哪些测试要做</li><li>谁做</li><li>什么时间做</li><li>如何做</li></ul></li></ul><h4 id="创建测试流程步骤"><a href="#创建测试流程步骤" class="headerlink" title="创建测试流程步骤"></a>创建测试流程步骤</h4><ul><li>对当前存在的问题进行收集、诊断分析</li><li>根据实际情况建立新的流程</li><li>流程发布和试运行</li><li>促进流程的执行、收集问题</li><li>流程更新和发布</li></ul><h4 id="测试执行-VS-测试过程执行"><a href="#测试执行-VS-测试过程执行" class="headerlink" title="测试执行 VS 测试过程执行"></a>测试执行 VS 测试过程执行</h4><ul><li>测试执行<ul><li>按照测试计划去执行测试活动</li></ul></li><li>测试过程执行<ul><li>是严格按照测试的过程去开展测试活动</li></ul></li></ul><h4 id="测试流程不是静止的"><a href="#测试流程不是静止的" class="headerlink" title="测试流程不是静止的"></a>测试流程不是静止的</h4><ul><li>测试过程创建后不是一成不变</li><li>而是根据实际实践情况不断改进和完善</li><li>进行修订后要及时进行过程发布</li></ul><h4 id="促进测试过程的执行"><a href="#促进测试过程的执行" class="headerlink" title="促进测试过程的执行"></a>促进测试过程的执行</h4><ul><li>一般在测试过程执行中<ul><li>要设置一定的机制</li><li>去保证测试人员按照测试过程开展测试活动</li></ul></li><li>促进测试的执行<ul><li>QA人员对项目的监督和指导</li><li>组织级审计</li></ul></li></ul><h4 id="测试流程的改进"><a href="#测试流程的改进" class="headerlink" title="测试流程的改进"></a>测试流程的改进</h4><ul><li>测试流程<ul><li>在每一轮执行完毕后</li><li>根据所执行情况对流程进行更新和完善</li><li>用好的实践去更新完善流程</li></ul></li></ul><h4 id="测试过程中涉及的文档等资产"><a href="#测试过程中涉及的文档等资产" class="headerlink" title="测试过程中涉及的文档等资产"></a>测试过程中涉及的文档等资产</h4><ul><li>测试计划文档</li><li>测试方案文档</li><li>测试用例</li><li>测试报告</li><li>测试缺陷库</li><li>其他<ul><li>新开发或引入的测试工具</li><li>测试工作会议记录<ul><li>测试计划</li><li>测试方案</li><li>测试用例<ul><li>的评审报告</li></ul></li></ul></li><li>测试总结</li><li>测试原始数据以及度量数据</li><li>测试日志<ul><li>每天测试日程记录</li></ul></li><li>周期性测试报告</li><li>任务报告：<ul><li>任务完成情况报告</li></ul></li></ul></li></ul><h4 id="测试方案文档"><a href="#测试方案文档" class="headerlink" title="测试方案文档"></a>测试方案文档</h4><ul><li>描述<ul><li>为完成软件特性的测试而采用的测试方法的细节</li></ul></li><li>主要内容：<ul><li>概述</li><li>被测对象</li><li>应测试的特性</li><li>不被测试的特性</li><li>测试模型</li><li>测试需求</li><li>测试设计</li></ul></li></ul><h4 id="测试用例文档"><a href="#测试用例文档" class="headerlink" title="测试用例文档"></a>测试用例文档</h4><ul><li>测试用例表描述测试用例<ul><li>测试项目</li><li>用例编号</li><li>用例级别：测试用例重要程度</li><li>用例可用性</li><li>输入值</li><li>预期输出</li><li>实测结果</li><li>特殊环境需求（可选）</li><li>特殊测试步骤（可选）</li></ul></li></ul><h4 id="测试报告文档"><a href="#测试报告文档" class="headerlink" title="测试报告文档"></a>测试报告文档</h4><ul><li>描述测试结果的文档</li><li>主要内容：<ul><li>概述</li><li>测试时间、地点、人员</li><li>测试环境</li><li>测试结果统计分析</li><li>测试评估</li><li>测试总结与改进</li><li>测试缺陷列表</li></ul></li></ul><h4 id="测试缺陷："><a href="#测试缺陷：" class="headerlink" title="测试缺陷："></a>测试缺陷：</h4><ul><li>描述测试缺陷</li><li>主要内容：<ul><li>缺陷简述</li><li>缺陷描述</li><li>缺陷级别</li><li>缺陷分析与对策</li></ul></li></ul><h3 id="企业测试流程样例"><a href="#企业测试流程样例" class="headerlink" title="企业测试流程样例"></a>企业测试流程样例</h3><h4 id="某企业测试过程样例-概览"><a href="#某企业测试过程样例-概览" class="headerlink" title="某企业测试过程样例-概览"></a>某企业测试过程样例-概览</h4><p><img src="/posts/5418/%E6%A6%82%E8%A7%88.PNG" alt="概览"></p><h4 id="测试过程描述"><a href="#测试过程描述" class="headerlink" title="测试过程描述"></a>测试过程描述</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0.PNG" alt="测试过程描述"></p><h4 id="活动流程定义"><a href="#活动流程定义" class="headerlink" title="活动流程定义"></a>活动流程定义</h4><p><img src="/posts/5418/%E6%B4%BB%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89.PNG" alt="活动流程定义"></p><h4 id="测试相关的文档模版"><a href="#测试相关的文档模版" class="headerlink" title="测试相关的文档模版"></a>测试相关的文档模版</h4><p><img src="/posts/5418/%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF.PNG" alt="文档模版"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1-非功能性的系统测试需求</title>
      <link href="/posts/14723.html"/>
      <url>/posts/14723.html</url>
      
        <content type="html"><![CDATA[<h2 id="典型的遇到的问题"><a href="#典型的遇到的问题" class="headerlink" title="典型的遇到的问题"></a>典型的遇到的问题</h2><ol><li>系统性能问题</li><li>软件系统安全性受到挑战</li></ol><h2 id="什么是系统非功能性测试？"><a href="#什么是系统非功能性测试？" class="headerlink" title="什么是系统非功能性测试？"></a>什么是系统非功能性测试？</h2><ul><li><p>用户的需求</p><ul><li>分类：<ul><li>功能性需求</li><li>非功能性需求</li></ul></li></ul></li><li><p>非功能性需求：</p><ul><li>被归纳为：<ul><li>软件产品的各种质量特性</li><li>eg：<ul><li>安全性</li><li>兼容性</li><li>可靠性</li></ul></li></ul></li></ul></li><li><p>系统非功能性测试：</p><ul><li>针对于以上非功能特性展开</li><li>验证软件产品符合这些质量特性的要求<ul><li>从而满足用户和软件企业自身的非功能性需求</li></ul></li></ul></li><li><p>系统测试</p><ul><li>分类：<ul><li>负载测试</li><li>性能测试</li><li>容量测试</li><li>安全性测试</li><li>兼容性测试</li><li>可靠性测试</li></ul></li></ul></li></ul><h2 id="系统非功能特性"><a href="#系统非功能特性" class="headerlink" title="系统非功能特性"></a>系统非功能特性</h2><ul><li><p><strong>性能</strong></p><ul><li>指按用户负载条件对<ul><li>响应时间</li><li>吞吐量<ul><li>所做的度量<ul><li>（度量指的是一些指标进行计算后的统计结果）</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>可用性</strong>：</p><ul><li>指对<ul><li>系统资源</li><li>服务<ul><li>可供最终用户使用的程度度量</li></ul></li></ul></li><li>通常以系统的正常运行时间来表示</li></ul></li><li><p><strong>可伸缩性</strong>：</p><ul><li>指随时间推移为部署系统增加容量和用户的能力</li><li>通常涉及向系统添加资源</li><li>但不应要求对部署体系结构进行更改</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>指对系统及用户的完整性进行说明的复杂因素组合</li><li>包括<ul><li>用户的验证和授权</li><li>数据的安全</li><li>对已部署系统的安全访问</li></ul></li></ul></li><li><p><strong>潜在容量</strong>：</p><ul><li>指在不增加资源的情况下，系统处理异常峰值负载的能力</li><li>潜在容量是<ul><li>可用性</li><li>性能</li><li>可伸缩性<ul><li>特性中的一个因素</li></ul></li></ul></li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>指对已部署系统进行维护的难易度</li><li>其中包括：<ul><li>监视系统</li><li>修复出现的故障</li><li>升级硬件和软件组件</li></ul></li></ul></li></ul><h2 id="系统非功能性测试的内容"><a href="#系统非功能性测试的内容" class="headerlink" title="系统非功能性测试的内容"></a>系统非功能性测试的内容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter录制脚本</title>
      <link href="/posts/3679.html"/>
      <url>/posts/3679.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>file</code>目录中选择 templates..</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC1.png" alt="1"></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC2.png" alt="2"></p><p><code>select</code> <code>template</code>   中选择  <code>recording</code>  （在要做接口测试时）</p><p>如果要做性能测试，可以选择<code>recording with think time</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC3.png" alt="3"></p><p>选完后，<code>create</code> 确认</p><p>更改 <code>hostToRecord</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC4.png" alt="4"></p><p>因为是要测试自己的网站，而这个网站是部署在自己电脑上的，所以此处<code>hostToRecord</code>更改为<code>127.00.1</code></p><p><code>https</code> 改为 <code>http</code></p><p>再次选择 <code>create</code> 创建</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC5.png" alt="5"></p><ul><li><p>知识点：LogicController：</p><ul><li>用来控制TestPlan的执行，如循环、分支等，或者更简单一点，就是为了分组</li></ul></li><li><p>Thread Group下的Recording controller即是用于分组</p></li><li><p>view resultsTree：看执行结果</p></li><li><p>HTTP(S) Test Script Recorder:</p><ul><li>用于代理（浏览器请求需要通过这个代理再到网站，网站返回的相应也要通过这个代理，所以他要把这个请求给记下来）</li></ul></li></ul><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC6.png" alt="6"></p><p><code>port</code> 端口为8888，因为电脑上没有与这个冲突的，所以不用改</p><p>下面的 <code>Target Controller</code> 是指的存放所录制脚本的地方</p><p> <code>grouping</code>：一秒钟以内的请求</p><p>点击上面的 <code>start</code></p><p>再打开浏览器，打开设置栏，选择管理证书</p><p><img src="/posts/3679/7.png" alt="7"></p><p>选择证书颁发机构，选择导入</p><p><img src="/posts/3679/8.png" alt="8"></p><p>打开jmeter下的bin目录的apachejmetertemporaryrootca</p><p>后面一直点下一步、确定之类的即可</p><p>直到导入成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo s</code></p><p>图片引用：<img src="/posts/16107/%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="你想输入的替代文字"></p><p>emoji-》     ：smile：（冒号两边无空格）</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
