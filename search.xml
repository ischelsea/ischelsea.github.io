<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jmeter的第一个实验</title>
      <link href="/posts/12105.html"/>
      <url>/posts/12105.html</url>
      
        <content type="html"><![CDATA[<p>首先打开jmeter文件夹内bin目录下的 <code>jmeter.bat</code>  从而运行jmeter程序</p><p>再在jmeter中 <code>open file</code>,打开实验要运行的文件， <code>first test plan</code></p><p><img src="/posts/12105/1.png" alt="1"></p><p><code>comment</code>：注释</p><p>刚创立test plan时内部是空的，在设置完名称和注释之后先记得把这个test plan保存</p><p>保存完后，为了利用这个test plan做些东西，就要 add something</p><p>即：</p><ul><li>右键first test plan</li><li>add</li><li>Threads（Users）</li><li>Thread Group<ul><li>即成功添加第一个线程组</li></ul></li></ul><p>但是添加完这个线程组之后还是做不了什么事情，要再在 <code>thread group</code>里 添加一些设置</p><ul><li><p>点击thread group:</p><p><img src="/posts/12105/2.png" alt="2"></p></li><li><p><code>Number of Threads(users)</code>:</p><ul><li>即需要多少线程 或者可以说虚拟用户</li></ul></li><li><p><code>Ramp-up period</code>：</p><ul><li>即这些用户用多久时间生成</li></ul></li><li><p><code>Loop count</code>:</p><ul><li>即循环次数</li></ul></li></ul><p>因为这个test plan意图访问web系统的界面类</p><p>我们不直接对界面进行操作，而是对接口发送请求</p><p>在jmeter中，所有的请求要发出去，都要用到 <code>Add</code>里面的 <code>Sampler</code>(采样器)  </p><p>其中有许多采样器，我们这个实验中使用 <code>Http request</code></p><p>其中设置好名称和网址，如图：</p><p><img src="/posts/12105/3.png" alt="3"></p><ul><li><code>port number</code><ul><li>端口号<ul><li>如果使用默认端口，可以不填</li></ul></li></ul></li><li><code>path</code><ul><li>路径</li><li>因为这里是要访问首页，所以不需要填路径</li></ul></li></ul><p>经过以上操作，我们已经有了一个可以发请求的采样器，现在可以来跑一下。</p><p>但是虽然这时候已经可以跑了，但是结果我们看不到</p><p>因此，需要增加 <code>listener</code>来查看结果</p><ul><li>右键Thread Group</li><li><code>add</code></li><li><code>listener</code></li><li>选择 <code>view results tree</code></li></ul><p>加上之后即可选择start，开始测试，并得到结果</p><p>如果要清除listener，即可选择右上角 <code>clear all</code>   （如果只是清掉当前的view result tree，按clear即可）</p><p>我们查看view result tree里面详情，可以看到一次httprequest包含了两次请求</p><p>这是因为被重定向了</p><p><img src="/posts/12105/4.png" alt="4"></p><p>通过以上操作，我们明白了这样添加线程组并运行</p><p>但我们也要知道，实际操作中还需要添加<code>Config element</code></p><ul><li><code>add</code></li><li><code>config element</code></li><li><code>Http request defaults</code></li></ul><p><img src="/posts/12105/5.png" alt="5"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言学 第一章</title>
      <link href="/posts/17942.html"/>
      <url>/posts/17942.html</url>
      
        <content type="html"><![CDATA[<h2 id="语言学分类-按研究对象分"><a href="#语言学分类-按研究对象分" class="headerlink" title="语言学分类-按研究对象分"></a>语言学分类-按研究对象分</h2><ul><li>linguistics<ul><li>Theoretical Ling</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语语言学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组 第一章 绪论</title>
      <link href="/posts/7573.html"/>
      <url>/posts/7573.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-计算机的发展史"><a href="#1-1-计算机的发展史" class="headerlink" title="1.1 计算机的发展史"></a>1.1 计算机的发展史</h2><h3 id="1-1-1-计算简史"><a href="#1-1-1-计算简史" class="headerlink" title="1.1.1 计算简史"></a>1.1.1 计算简史</h3><h4 id="人类创造工具"><a href="#人类创造工具" class="headerlink" title="人类创造工具"></a>人类创造工具</h4><ul><li>机械工具</li><li>测试工具</li><li>计算工具</li></ul><h4 id="计算经历阶段"><a href="#计算经历阶段" class="headerlink" title="计算经历阶段"></a>计算经历阶段</h4><ul><li><p>手工计算</p></li><li><p>机械计算</p></li><li><p>电子计算</p></li></ul><h4 id="手工计算阶段"><a href="#手工计算阶段" class="headerlink" title="手工计算阶段"></a>手工计算阶段</h4><h5 id="计数工具"><a href="#计数工具" class="headerlink" title="计数工具"></a>计数工具</h5><ul><li>穴石、绳结、刻痕</li><li>十指</li><li>算盘<ul><li>应用时间最长</li><li>功能最完善</li><li>非自然化计数工具</li></ul></li><li>计算尺<ul><li>用长度模拟数值大小</li><li>可进行一些四则运算和复杂非四则运算</li></ul></li></ul><h5 id="计数法："><a href="#计数法：" class="headerlink" title="计数法："></a>计数法：</h5><ul><li>十进制<ul><li>是数学体系计数制基础</li></ul></li></ul><h5 id="口诀："><a href="#口诀：" class="headerlink" title="口诀："></a>口诀：</h5><ul><li>基本操作指令</li><li>算盘指令系统、珠算语言</li></ul><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li>人的技能水平、精力、智力影响计算速度、正确性</li><li>无法进行大的复杂运算</li></ul><h4 id="机械计算阶段"><a href="#机械计算阶段" class="headerlink" title="机械计算阶段"></a>机械计算阶段</h4><ul><li><p>pascal[法]</p><ul><li>1642年</li><li>可做成加减法的机械计算起</li></ul></li><li><p>Leibnitz[德]</p><ul><li>1673年</li><li>改进pascal设计</li><li>增加乘除运算</li></ul></li><li><p>19世纪</p><ul><li>手摇计算机商品化生产</li></ul></li><li><p>Babbage[英]  计算机之父</p><ul><li>首先提出整个计算过程自动化概念</li><li>设计第一台通用自动时序控制机械式计算机<ul><li>但未能制造出来</li></ul></li><li>认为自动计算机必须有五大功能<ul><li>输入</li><li>输出</li><li>处理</li><li>存储</li><li>控制</li></ul></li><li>提出计算机实现自动计算的前提<ul><li>具有记忆功能</li><li>能记住数据和要进行的步骤</li><li>并按步骤规定对机器进行自动控制</li></ul></li></ul></li><li><p>缺陷</p><ul><li>频繁的人工干预限制计算速度提高</li></ul></li></ul><h4 id="电子计算阶段"><a href="#电子计算阶段" class="headerlink" title="电子计算阶段"></a>电子计算阶段</h4><h5 id="电子计算"><a href="#电子计算" class="headerlink" title="电子计算"></a>电子计算</h5><ul><li>理论基础：<ul><li>二进制<ol><li>中国最早使用</li><li>阳爻-&gt;1  阴爻-&gt;0</li></ol></li></ul></li></ul><h5 id="George-Boole-英"><a href="#George-Boole-英" class="headerlink" title="George Boole [英]"></a>George Boole [英]</h5><ul><li><p>发表：</p><ul><li>《逻辑的数学分析》</li><li>《思维规律的研究》<ul><li>两本书核心：<ul><li>现代《布尔代数》精髓</li></ul></li></ul></li></ul></li><li><p>把运算和逻辑理论建立在</p><ul><li>0和1两种数值</li><li>”与“”或“”非“三种基本逻辑运算</li></ul></li><li><p>是现代数字式设备理论基础</p></li></ul><h5 id="V-Atanasolf-美-伊阿华大学"><a href="#V-Atanasolf-美-伊阿华大学" class="headerlink" title="V.Atanasolf 美 伊阿华大学"></a>V.Atanasolf 美 伊阿华大学</h5><ul><li><p>首次</p><ul><li>使用电子原件</li><li>按二进制原理<ul><li>制造一台电子管计算机</li></ul></li></ul></li><li><p>在Cliffod Berry协助下</p><ul><li>制造出一台电子管计算机Atanasoff Berry Computer</li></ul></li></ul><h5 id="ENIAC-Electronic-Numerical-Integrator-and-Computer"><a href="#ENIAC-Electronic-Numerical-Integrator-and-Computer" class="headerlink" title="ENIAC Electronic Numerical Integrator and Computer"></a>ENIAC Electronic Numerical Integrator and Computer</h5><ul><li>地位：<ul><li>世界上第一台电子数字计算机（试运行：1945）</li><li>现代电子数字计算机始祖</li></ul></li><li>大小：<ul><li>高8英尺 长100英尺 宽3英尺 </li><li>18000个真空管 1500个电子继电器</li><li>18000个电容 70000个电阻</li><li>重30吨</li></ul></li><li>计算：<ul><li>弹道计算：<ul><li>60s射程弹道计算为30s</li></ul></li><li>性能：<ul><li>不高<ul><li>5000次加法运算</li><li>50次乘法运算</li></ul></li><li>每秒可进行<ul><li>平方</li><li>立方</li><li>sin</li><li>cos<ul><li>数值运算</li></ul></li></ul></li></ul></li><li>其他领域<ul><li>eg：<ul><li>天气预报</li><li>原子核能</li><li>风洞试验</li></ul></li><li>关于原子裂变的能量计算<ul><li>冯诺依曼邀请</li><li>促进世界第一颗原子弹问世</li></ul></li></ul></li><li>圆周率计算（1949）<ul><li>70小时，计算至小数点后2037位</li><li>人类第一次用机器算的最精确圆周率数值</li></ul></li></ul></li><li>1955年 退休</li></ul><h5 id="EDSAC-英-剑桥"><a href="#EDSAC-英-剑桥" class="headerlink" title="EDSAC [英 剑桥]"></a>EDSAC [英 剑桥]</h5><ul><li>Electronic Delay Storage Automatic Computer<ul><li>世界上第一台通用电子数字计算机<ul><li>人类开始进入电子数字计算机时代</li></ul></li></ul></li></ul><h3 id="1-1-2-计算机发展简史"><a href="#1-1-2-计算机发展简史" class="headerlink" title="1.1.2 计算机发展简史"></a>1.1.2 计算机发展简史</h3><h4 id="经历4代："><a href="#经历4代：" class="headerlink" title="经历4代："></a>经历4代：</h4><ul><li>第一代计算机 20世纪40代中-50末</li><li>第二代计算机 20世纪50中后-60中</li><li>第三代计算机 20世纪60中-70中</li><li>第四代计算机 20世纪70中-今</li></ul><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><ul><li><p>电子器件</p><ul><li>是划分时代最重要标志</li></ul></li></ul><h4 id="第一代计算机：电子管计算机"><a href="#第一代计算机：电子管计算机" class="headerlink" title="第一代计算机：电子管计算机"></a>第一代计算机：电子管计算机</h4><ul><li>逻辑元件：<ul><li>电子管</li></ul></li><li>主存储器：<ul><li>阴极射线管</li><li>声泵延迟线</li><li>磁带、磁鼓</li></ul></li><li>数据表示<ul><li>定点表示</li></ul></li><li>编程语言：<ul><li>机器语言</li><li>汇编语言</li></ul></li><li>机器：<ul><li>ENIAC\EDSCAC</li><li>冯诺依曼为首研制的存储程序计算机<ul><li>IAS</li><li>UNIVAC-1</li><li>IBM 704</li></ul></li><li>我国自己研制的第一代计算机<ul><li>主要<ul><li>104机</li><li>103机</li><li>119机</li></ul></li></ul></li></ul></li></ul><h4 id="第二代计算机：晶体管计算机"><a href="#第二代计算机：晶体管计算机" class="headerlink" title="第二代计算机：晶体管计算机"></a>第二代计算机：晶体管计算机</h4><ul><li><h5 id="逻辑元件："><a href="#逻辑元件：" class="headerlink" title="逻辑元件："></a>逻辑元件：</h5><ul><li>晶体管</li></ul></li><li><p>主存储器元件：</p><ul><li>磁芯</li></ul></li><li><p>运算：</p><ul><li>引入浮点运算硬件</li></ul></li><li><p>建立：</p><ul><li>子程序库</li><li>批处理管理程序</li></ul></li><li><p>语言：</p><ul><li>FORTRAN</li><li>COBOL</li><li>ALGOL<ul><li>等高级语言<ul><li>简化了程序设计</li></ul></li></ul></li></ul></li><li><p>优点：</p><ul><li>体积小</li><li>功耗快</li><li>速度快</li><li>可靠性高</li></ul></li><li><p>机器：</p><ul><li>国外：<ul><li>IBM 7040,7070,7090</li><li>CDC 1604</li></ul></li><li>国内：<ul><li>109机</li><li>441B机</li><li>108机</li></ul></li></ul></li></ul><h4 id="第三代计算机"><a href="#第三代计算机" class="headerlink" title="第三代计算机"></a>第三代计算机</h4><ul><li>基础器件：<ul><li>集成电路<ul><li>微电子技术与计算机技术相结合的一大突破</li></ul></li></ul></li><li>电路：<ul><li>采用<ul><li>小规模</li><li>中规模<ul><li>集成电路</li></ul></li></ul></li></ul></li><li>存储器：<ul><li>半导体存储器</li></ul></li><li>改进：<ul><li>引进多道程序和并行处理等新的技术</li><li>操作系统日趋成熟</li></ul></li><li>机器：<ul><li>国外：<ul><li>IBM 360系列</li><li>CDC 6600/7600系列</li><li>CYBER系列</li></ul></li><li>国产:<ul><li>150,151<ul><li>DJS-2000系列</li><li>DJS-1000系列</li></ul></li></ul></li></ul></li></ul><h4 id="第四代计算机"><a href="#第四代计算机" class="headerlink" title="第四代计算机"></a>第四代计算机</h4><ul><li>电路：<ul><li>大规模集成电路</li><li>超大规模集成电路</li></ul></li><li>改进：<ul><li>技术：<ul><li>并行处理</li><li>多机系统</li><li>分布式计算机</li><li>计算机网络<ul><li>等技术飞速发展</li></ul></li></ul></li><li>机器：<ul><li>微处理机、微型计算机<ul><li>迅速发展</li></ul></li><li>小型机、超级小型机、大型机、巨型机<ul><li>不断问世</li></ul></li></ul></li></ul></li></ul><h2 id="1-2-计算机系统组成"><a href="#1-2-计算机系统组成" class="headerlink" title="1.2 计算机系统组成"></a>1.2 计算机系统组成</h2><h3 id="1-2-1-存储程序原理"><a href="#1-2-1-存储程序原理" class="headerlink" title="1.2.1 存储程序原理"></a>1.2.1 存储程序原理</h3><h4 id="《关于电子计算装置逻辑结果初探》"><a href="#《关于电子计算装置逻辑结果初探》" class="headerlink" title="《关于电子计算装置逻辑结果初探》"></a>《关于电子计算装置逻辑结果初探》</h4><ul><li>美籍匈牙利数学家 冯诺依曼</li><li>所阐述思想构建了<ul><li>现代电子计算机的组成原理</li></ul></li><li>提出了<ul><li>以存储程序为核心的通用电子数字计算机体系结构原理</li></ul></li><li>奠定了<ul><li>当代电子计算机体系结构的基础</li></ul></li></ul><h4 id="“存储程序计算机”："><a href="#“存储程序计算机”：" class="headerlink" title="“存储程序计算机”："></a>“存储程序计算机”：</h4><ul><li>按照存储程序原理构建的计算机</li></ul><h4 id="存储程序原理"><a href="#存储程序原理" class="headerlink" title="存储程序原理"></a>存储程序原理</h4><h5 id="存储程序原理基本思想"><a href="#存储程序原理基本思想" class="headerlink" title="存储程序原理基本思想"></a>存储程序原理基本思想</h5><ul><li>计算机要自动完成解题任务</li><li>必须将实现设计好、用以描述计算机解题过程中的程序<ul><li>和数据一样</li><li>按 <strong>二进制</strong> 形式存储在机器中</li></ul></li><li>计算机在工作时 <strong>自动高速</strong> 地从机器中 <strong>逐条取出指令</strong> 并加以执行</li></ul><h6 id="程序的定义："><a href="#程序的定义：" class="headerlink" title="程序的定义："></a>程序的定义：</h6><ul><li>程序即指令的有序集合</li></ul><h6 id="计算器与计算机不同之处："><a href="#计算器与计算机不同之处：" class="headerlink" title="计算器与计算机不同之处："></a>计算器与计算机不同之处：</h6><ul><li>计算器解题步骤<ul><li>即程序是在执行过程中由人工临时编制和控制执行的</li></ul></li></ul><h5 id="存储程序原理-计算机五大功能"><a href="#存储程序原理-计算机五大功能" class="headerlink" title="存储程序原理 计算机五大功能"></a>存储程序原理 计算机五大功能</h5><ol><li>数据传送功能<ul><li>计算机将 <strong>原始数据</strong> 和 <strong>解题程序</strong> 输入到机器中</li><li>计算机结果与计算过程中情况 也能 <strong>随时输出</strong> 给用户</li><li>即 计算机必须有 <strong>输入和输出</strong> 的功能</li></ul></li><li>数据存储功能<ul><li>计算机能记住<ul><li>输入的原始数据</li><li>解题步骤 即程序</li><li>解题过程中产生中间结果</li></ul></li><li>即具备数据存储功能</li><li>是计算机能实现<strong>自动运算关键</strong></li></ul></li><li>数据处理功能<ul><li>能进行一些基本运算<ul><li>组合成所需要的一切复杂运算和操作</li></ul></li><li>这是计算机 进行<strong>运算、处理、控制的基础</strong></li></ul></li><li>操作控制功能<ul><li>保证程序执行的<strong>正确性</strong></li><li><strong>协调控制</strong> 组成计算机的各部件</li></ul></li><li>操作判断功能<ul><li>完成一步操作后<ul><li>从预先无法确定的几种方案中选择一种方案</li><li>保证解题操作正确完成</li></ul></li></ul></li></ol><h4 id="经典“存储程序计算机”"><a href="#经典“存储程序计算机”" class="headerlink" title="经典“存储程序计算机”"></a>经典“存储程序计算机”</h4><ul><li>即经典冯诺依曼结构计算机框图</li><li><img src="/posts/7573/冯诺依曼计算机.png" alt="冯诺依曼计算机" style="zoom:67%;">- 实线：  - 数据线- 虚线：  - 控制线  - 反馈线</li></ul><h3 id="1-2-2-计算机系统的组成"><a href="#1-2-2-计算机系统的组成" class="headerlink" title="1.2.2 计算机系统的组成"></a>1.2.2 计算机系统的组成</h3><h4 id="完整的计算机系统构成"><a href="#完整的计算机系统构成" class="headerlink" title="完整的计算机系统构成"></a>完整的计算机系统构成</h4><ul><li>硬件系统</li><li>软件系统</li></ul><h4 id="计算机硬件系统"><a href="#计算机硬件系统" class="headerlink" title="计算机硬件系统"></a>计算机硬件系统</h4><h5 id="硬件的定义："><a href="#硬件的定义：" class="headerlink" title="硬件的定义："></a>硬件的定义：</h5><ul><li>Hardware</li><li>是组成电子计算机的所有电子器件和机电装置的总称</li><li>是计算机系统中实际存在的物理实体，看得见摸得着</li></ul><h5 id="硬件系统的构成"><a href="#硬件系统的构成" class="headerlink" title="硬件系统的构成"></a>硬件系统的构成</h5><ul><li>物理构成上看：<ul><li>电子器件</li><li>插件板</li><li>电源</li><li>机架</li><li>各种功能的外部设备</li></ul></li><li>逻辑功能上看：<ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li><li>之间的互连结构</li></ul></li></ul><h5 id="硬件系统地位："><a href="#硬件系统地位：" class="headerlink" title="硬件系统地位："></a>硬件系统地位：</h5><ul><li><p>是构成计算机的物质基础</p></li><li><p>是计算机系统的核心</p></li></ul><h4 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h4><h5 id="软件的定义："><a href="#软件的定义：" class="headerlink" title="软件的定义："></a>软件的定义：</h5><ul><li>按iso国际标准化组织的定义：<ul><li>是电子计算机程序及运用数据处理系统所必须的<ul><li>手续</li><li>规则</li><li>文件<ul><li>的总称</li></ul></li></ul></li></ul></li></ul><h5 id="软件的构成"><a href="#软件的构成" class="headerlink" title="软件的构成"></a>软件的构成</h5><ul><li>程序</li><li>文档</li></ul><h5 id="程序："><a href="#程序：" class="headerlink" title="程序："></a>程序：</h5><ul><li>定义：<ul><li>为了取得一定的结果而编写的计算机指令的有序集合</li></ul></li><li>特点：<ul><li>可由计算机执行</li><li>是计算机软件的主体</li><li>一般说到软件，主要指程序</li></ul></li></ul><h5 id="文档："><a href="#文档：" class="headerlink" title="文档："></a>文档：</h5><ul><li><p>定义：</p><ul><li>是描述程序操作及使用的有关资料</li></ul></li><li><p>特点：</p><ul><li>不能由计算机执行</li></ul></li></ul><h4 id="计算机软件系统和硬件系统关系"><a href="#计算机软件系统和硬件系统关系" class="headerlink" title="计算机软件系统和硬件系统关系"></a>计算机软件系统和硬件系统关系</h4><h5 id="软硬件关系"><a href="#软硬件关系" class="headerlink" title="软硬件关系"></a>软硬件关系</h5><ul><li>软硬件之间是<ul><li>相互渗透、相互依存</li><li>相互配合、相互促进的关系</li><li>二者缺一不可</li></ul></li><li>硬件<ul><li>是躯体，是物质基础</li></ul></li><li>软件<ul><li>是智慧、灵魂、是硬件功能的完善和扩充</li><li>作为计算机用户与硬件之间接口界面<ul><li>在计算机系统中 起指挥管理作用</li></ul></li></ul></li><li>硬件与软件的组合<ul><li>构成了完善实用的计算机系统</li></ul></li></ul><h5 id="软硬件功能："><a href="#软硬件功能：" class="headerlink" title="软硬件功能："></a>软硬件功能：</h5><ul><li>计算机系统功能<ul><li>由硬件或软件实现</li></ul></li><li>软件与硬件在逻辑功能上等价<ul><li>硬件实现的功能可用软件实现</li><li>反之亦然</li></ul></li><li>由软硬件实现的计算机系统的<ul><li>成本</li><li>效率<ul><li>不同</li><li>一般在系统设计时加以权衡</li></ul></li></ul></li></ul><h5 id="软硬件转化："><a href="#软硬件转化：" class="headerlink" title="软硬件转化："></a>软硬件转化：</h5><ul><li><p>随着超大规模集成电路技术的发展</p><ul><li><p>软件硬化成固化是</p><ul><li>提高 <strong>计算机处理能力</strong> 的 最常用手段</li></ul></li><li><p>固件Firmware</p><ul><li><p>是将程序固化在ROM中组成的部件</p></li><li><p>是一种具有软件特性的硬件</p><ul><li><p>具有</p><ul><li><p>硬件的 快速性</p></li><li><p>软件的 灵活性</p></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="1-2-3-计算机硬件系统组成"><a href="#1-2-3-计算机硬件系统组成" class="headerlink" title="1.2.3 计算机硬件系统组成"></a>1.2.3 计算机硬件系统组成</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><h5 id="两类计算机结构"><a href="#两类计算机结构" class="headerlink" title="两类计算机结构"></a>两类计算机结构</h5><ul><li>冯诺依曼计算机结构<ul><li>以 <strong>运算器</strong> 为中心</li><li>计算机效率不高<ul><li>原因：<ul><li>输入输出设备速度慢</li><li>传输操作都需通过运算器</li></ul></li></ul></li></ul></li><li>现代计算机结构<ul><li>以 <strong>存储器</strong> 为中心</li></ul></li></ul><h5 id="中央处理器："><a href="#中央处理器：" class="headerlink" title="中央处理器："></a>中央处理器：</h5><ul><li>Central Processing Unit,CPU<ul><li>包含：<ul><li>运算器</li><li>控制器</li></ul></li><li>名称原因：<ul><li>运算器、控制器逻辑关系联系紧密</li><li>大规模集成电路出现后<ul><li>两部件集中在同一芯片上</li></ul></li></ul></li></ul></li></ul><h5 id="存储器："><a href="#存储器：" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>功能：<ul><li>存储二进制信息</li></ul></li><li>分类<ul><li>内存储器：<ul><li>又称主存储器</li><li>特点：<ul><li>存取速度快</li><li>存储容量较小</li><li>与CPU直接打交道</li><li>有半导体元器件构成</li></ul></li></ul></li><li>外存储器<ul><li>也称辅助存储器</li><li>特点：<ul><li>存取速度慢</li><li>存储容量较大</li><li>但不能直接与CPU打交道</li><li>必须把其中的信息送到内存后再由CPU处理</li></ul></li><li>eg：<ul><li>磁盘、磁带、光盘</li></ul></li></ul></li></ul></li></ul><h5 id="主机："><a href="#主机：" class="headerlink" title="主机："></a>主机：</h5><ul><li>包含<ul><li>内存储器</li><li>CPU</li></ul></li></ul><h5 id="外部设备："><a href="#外部设备：" class="headerlink" title="外部设备："></a>外部设备：</h5><ul><li><p>包含</p><ul><li><p>输入输出设备</p></li><li><p>外存储器</p></li></ul></li></ul><h4 id="运算器-Arithmetic-Unit"><a href="#运算器-Arithmetic-Unit" class="headerlink" title="运算器 Arithmetic Unit"></a>运算器 Arithmetic Unit</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h5><h6 id="运算器定义："><a href="#运算器定义：" class="headerlink" title="运算器定义："></a>运算器定义：</h6><ul><li>是进行数据处理</li><li>即执行<ul><li>算术运算</li><li>逻辑运算<ul><li>的部件</li></ul></li></ul></li></ul><h6 id="算术运算："><a href="#算术运算：" class="headerlink" title="算术运算："></a>算术运算：</h6><ul><li>是按照算数规则进行的运算</li><li>eg：<ul><li>加减乘除</li><li>及它们的复合运算等</li></ul></li></ul><h6 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h6><ul><li>即非算数性运算<ul><li>eg：<ul><li>比较</li><li>移位</li><li>逻辑加、逻辑乘</li><li>异或操作等</li></ul></li></ul></li></ul><h6 id="带输入锁存器的运算器"><a href="#带输入锁存器的运算器" class="headerlink" title="带输入锁存器的运算器"></a>带输入锁存器的运算器</h6><ul><li><p>含有：</p><ul><li>算术逻辑单元</li><li>内部总线</li><li>通用寄存器组</li><li>锁存器</li><li>标志寄存器</li><li>移位器</li></ul></li><li><p>结构图：</p><ul><li><img src="/posts/7573/%E5%B8%A6%E8%BE%93%E5%85%A5%E9%94%81%E5%AD%98%E5%99%A8%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8.png" alt="带输入锁存器的运算器"></li></ul></li></ul><h6 id="1-算数逻辑单元"><a href="#1-算数逻辑单元" class="headerlink" title="1.算数逻辑单元"></a>1.算数逻辑单元</h6><ul><li>Arithmetic and logic unit</li><li>功能：<ul><li>是具体完成算术逻辑运算的部件</li></ul></li><li>包含：<ul><li>加法器</li><li>逻辑运算器件</li></ul></li><li>地位：<ul><li>是运算器的核心</li></ul></li></ul><h6 id="2-内部总线"><a href="#2-内部总线" class="headerlink" title="2.内部总线"></a>2.内部总线</h6><ul><li>连接：<ul><li>ALU</li><li>通用寄存器组</li><li>锁存器</li><li>标志寄存器Flag</li><li>移位器</li></ul></li><li>地位：<ul><li>是CPU内部的数据通路</li></ul></li><li>与系统总线的区别：<ul><li>内部总线 仅用来传送数据</li></ul></li></ul><h6 id="3-通用寄存器组R0-R-n-1）"><a href="#3-通用寄存器组R0-R-n-1）" class="headerlink" title="3.通用寄存器组R0-R(n-1）"></a>3.通用寄存器组R0-R(n-1）</h6><ul><li>功能：<ul><li>用于存放参与运算的操作数<ul><li>eg：<ul><li>加、减、乘、被除数、积、商等</li></ul></li></ul></li><li>连续运算中，还存放<ul><li>中间结果</li><li>最终结果</li></ul></li><li>通用寄存器中的数据<ul><li>均从存储器中取得</li><li>最终结果也存放到存储器中</li></ul></li></ul></li></ul><h6 id="4-锁存器"><a href="#4-锁存器" class="headerlink" title="4.锁存器"></a>4.锁存器</h6><ul><li>位置：<ul><li>ALU的两个输入端各有一个锁存器<ul><li>用来暂存要参与运算的操作数</li></ul></li></ul></li><li>实现R0&lt;-(R0)+(R2)的方法：<ol><li>通过内部总线 将R0中的数据送入锁存器1</li><li>通过内部总线将R2中的数据送入锁存器2</li><li>再在ALU中相加</li><li>将结果通过内部总线送入R0</li></ol></li></ul><h6 id="5-标志寄存器Flag"><a href="#5-标志寄存器Flag" class="headerlink" title="5.标志寄存器Flag"></a>5.标志寄存器Flag</h6><ul><li>寄存运算的状态信息<ul><li>eg：<ul><li>结果是否为0</li><li>是正数还是负数</li><li>溢出与否</li></ul></li></ul></li></ul><h6 id="6-移位器："><a href="#6-移位器：" class="headerlink" title="6.移位器："></a>6.移位器：</h6><ul><li><p>是一个多路开关</p></li><li><p>可对ALU的加工结果进行辅助操作</p></li><li><p>eg：</p><ul><li><p>可实现</p><ul><li><p>左移</p></li><li><p>右移</p></li><li><p>直接传送</p><ul><li>等功能</li></ul></li></ul></li></ul></li></ul><h6 id="带多路选择器的运算器"><a href="#带多路选择器的运算器" class="headerlink" title="带多路选择器的运算器"></a>带多路选择器的运算器</h6><ul><li>除了带输入所存期的运算器外</li><li>还有带多路选择器的运算器<ul><li>相似点：<ul><li>基本组成相同</li></ul></li><li>差异点：<ul><li>通用寄存器与ALU的连接方式不同</li></ul></li></ul></li></ul><h4 id="控制器-Control-Unit"><a href="#控制器-Control-Unit" class="headerlink" title="控制器 Control Unit"></a>控制器 Control Unit</h4><h5 id="地位："><a href="#地位：" class="headerlink" title="地位："></a>地位：</h5><ul><li>是计算机的管理机构和指挥中心</li><li>协调计算机的各部件自动地工作</li></ul><h5 id="完成的工作："><a href="#完成的工作：" class="headerlink" title="完成的工作："></a>完成的工作：</h5><ul><li>实质上是 解释程序<ul><li>每次从存储器中读取一条指令</li><li>经过<ul><li>分析译码</li><li>产生一系列控制信号</li></ul></li><li>发往各个部件以控制他们的操作</li></ul></li><li>连续不断地继续上述动作<ul><li>即所谓执行程序</li></ul></li></ul><h5 id="控制器的结构图："><a href="#控制器的结构图：" class="headerlink" title="控制器的结构图："></a>控制器的结构图：</h5><p><img src="/posts/7573/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90.png" alt="控制器结构图"></p><h5 id="控制器的类别："><a href="#控制器的类别：" class="headerlink" title="控制器的类别："></a>控制器的类别：</h5><ul><li>组合逻辑控制器</li><li>微程序控制器</li></ul><h5 id="组合逻辑控制器："><a href="#组合逻辑控制器：" class="headerlink" title="组合逻辑控制器："></a>组合逻辑控制器：</h5><h6 id="结构组成："><a href="#结构组成：" class="headerlink" title="结构组成："></a>结构组成：</h6><ul><li><p>指令控制部件</p></li><li><p>地址形成部件</p></li><li><p>定时部件</p></li><li><p>微操作控制部件</p></li></ul><h5 id="1-指令控制部件"><a href="#1-指令控制部件" class="headerlink" title="1.指令控制部件"></a>1.指令控制部件</h5><h6 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h6><ul><li>程序计数器 Program Counter ,PC</li><li>指令寄存器 Instruction Register,IR</li><li>指令译码器 Instruction Decoder,ID</li></ul><h6 id="程序计数器PC："><a href="#程序计数器PC：" class="headerlink" title="程序计数器PC："></a>程序计数器PC：</h6><ul><li>又叫指令计数器</li><li>作用：<ul><li>给出程序中指令在存储器中的单位地址</li><li>兼有<ul><li>指令地址寄存器</li><li>计数器<ul><li>的功能</li></ul></li></ul></li></ul></li><li>工作过程：<ul><li>取指令时，PC指向要取指令的地址</li><li>当一条指令执行完毕时<ul><li>pc作为指令地址寄存器</li><li>其内容已变成下一条指令的地址</li></ul></li><li>控制器依据PC的内容从存储器取出指令到IR后<ul><li>pc将自动加1</li><li>指向下一条指令的地址</li></ul></li><li>假定一个存储单元存储一条指令<ul><li>若非顺序执行</li><li>只要将pc的内容作相应改变</li><li>就可以按新的序列顺序执行</li></ul></li></ul></li></ul><h6 id="指令寄存器IR"><a href="#指令寄存器IR" class="headerlink" title="指令寄存器IR:"></a>指令寄存器IR:</h6><ul><li>保存当前正在执行的指令代码</li><li>在指令执行过程中由它决定指令的<ul><li>操作性质</li><li>参与操作的操作数地址</li></ul></li></ul><h6 id="指令译码器ID："><a href="#指令译码器ID：" class="headerlink" title="指令译码器ID："></a>指令译码器ID：</h6><ul><li>也称操作码译码器</li><li>将指令的操作码转换为相应的控制电位信号<ul><li>只是各部件做什么操作</li></ul></li></ul><h5 id="2-地址形成部件"><a href="#2-地址形成部件" class="headerlink" title="2.地址形成部件"></a>2.地址形成部件</h5><ul><li>包括：<ul><li>地址寄存器Address Register AR</li><li>变址寄存器Index Register XR</li><li>地址计算部件</li></ul></li><li>功能：<ul><li>依据<ul><li>指令的寻址方式</li><li>指令的地址码部分<ul><li>生成实际的操作数地址</li></ul></li></ul></li></ul></li></ul><h5 id="3-定时部件"><a href="#3-定时部件" class="headerlink" title="3.定时部件"></a>3.定时部件</h5><ul><li>又称时序部件</li></ul><h6 id="组成：-1"><a href="#组成：-1" class="headerlink" title="组成："></a>组成：</h6><ul><li>时钟 Clock Pulses,CP</li><li>时序信号产生器 Timing Signal Generator ,TSG</li></ul><h6 id="时钟-CP："><a href="#时钟-CP：" class="headerlink" title="时钟 CP："></a>时钟 CP：</h6><ul><li>是协调计算机各部件进行操作的同步时钟</li><li>其工作频率<ul><li>成为计算机的 <strong>主频</strong></li><li><strong>主频</strong>的高低直接影响计算机的工作速度</li></ul></li></ul><h6 id="时序信号产生器TSG："><a href="#时序信号产生器TSG：" class="headerlink" title="时序信号产生器TSG："></a>时序信号产生器TSG：</h6><ul><li>功能：<ul><li>按时间顺序<ul><li>周而复始地发出若干节拍信号和脉冲</li></ul></li></ul></li><li>节拍：<ul><li>即相邻两个时钟脉冲的时间间隔</li><li>即主频周期</li></ul></li></ul><h6 id="定时部件工作特点："><a href="#定时部件工作特点：" class="headerlink" title="定时部件工作特点："></a>定时部件工作特点：</h6><ul><li>根据机器的时钟脉冲<ul><li>发出全机所需的<ul><li>定时节拍信号</li><li>脉冲</li></ul></li></ul></li><li>各部件在不同的节拍信号控制下依次进行工作</li></ul><h5 id="4-微操作控制器"><a href="#4-微操作控制器" class="headerlink" title="4.微操作控制器"></a>4.微操作控制器</h5><h6 id="微操作的定义："><a href="#微操作的定义：" class="headerlink" title="微操作的定义："></a>微操作的定义：</h6><ul><li>Micro-operation</li><li>是指计算机各部件在一个节拍内能完成的基本操作</li></ul><h6 id="微操作的意义："><a href="#微操作的意义：" class="headerlink" title="微操作的意义："></a>微操作的意义：</h6><ul><li>计算机任意一条指令的执行都需要分解成许多微操作来执行</li></ul><h6 id="微操作控制部件："><a href="#微操作控制部件：" class="headerlink" title="微操作控制部件："></a>微操作控制部件：</h6><ul><li>是控制器的<ul><li>核心部件</li><li>最复杂的部件</li></ul></li><li>工作过程：<ul><li>根据<ul><li>指令控制部件给出的指令译码电位信号（进行什么操作）</li><li>时序部件给出的节拍信号和脉冲（指令执行到那一步）</li><li>运算器Flag提供的状态信息</li></ul></li><li>产生 计算机指令系统中所有指令所需的各种微操作控制信号</li><li>再讲这些控制信号发送给<ul><li>运算器</li><li>存储器</li><li>输入、输出设备</li><li>控制其本身</li></ul></li></ul></li><li>与组合逻辑控制器关系：<ul><li>除将微操作控制部件用微程序库代替外</li><li>其他部件和组合逻辑控制器相似</li></ul></li></ul><h4 id="内存储器"><a href="#内存储器" class="headerlink" title="内存储器"></a>内存储器</h4><h5 id="存储器：-1"><a href="#存储器：-1" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>主要功能：<ul><li>存放<ul><li>数据</li><li>程序</li></ul></li></ul></li><li>数据：<ul><li>是计算机操作的对象</li></ul></li><li>程序：<ul><li>是计算机指令的有序集合</li></ul></li><li>数据与程序必须存放在内存储器中原因：<ul><li>数据与程序均以二进制的形式表示</li><li>为实现自动运行程序</li></ul></li></ul><h5 id="内存储器的构成："><a href="#内存储器的构成：" class="headerlink" title="内存储器的构成："></a>内存储器的构成：</h5><ul><li>存储体</li><li>选址系统</li><li>读写系统</li><li>存储时序控制线路</li></ul><h5 id="存储体："><a href="#存储体：" class="headerlink" title="存储体："></a>存储体：</h5><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><ul><li>被分成一个一个存储单元</li><li>每个存储单元存放多位二进制信息</li><li>通常每个单元存放一个数据或一条指令</li></ul><h6 id="信息的特点："><a href="#信息的特点：" class="headerlink" title="信息的特点："></a>信息的特点：</h6><ul><li>信息的位数通常是计算机的字长</li><li>一般字长为字节的整数倍</li></ul><h6 id="存储体的定义："><a href="#存储体的定义：" class="headerlink" title="存储体的定义："></a>存储体的定义：</h6><ul><li>即存储单元的集合</li></ul><h6 id="存储单元的特点："><a href="#存储单元的特点：" class="headerlink" title="存储单元的特点："></a>存储单元的特点：</h6><ul><li><p>按顺序编号</p></li><li><p>每个存储单元对应一个编号</p><ul><li>此编号为存储单元地址<ul><li>简称地址</li></ul></li></ul></li><li><p>只要给定一个地址</p><ul><li>就可以通过地址译码器译码</li><li>找到对应的存储单元</li><li>从而可<ul><li>从该单元读取信息</li><li>或将信息写入该单元</li></ul></li></ul></li><li><p>地址与存储单元的关系：</p><ul><li><p>地址与存储单元一一对应</p></li><li><p>每个存储单元只有一个地址</p></li></ul></li></ul><h5 id="选址系统：Addressing-System"><a href="#选址系统：Addressing-System" class="headerlink" title="选址系统：Addressing System"></a>选址系统：Addressing System</h5><h6 id="包含："><a href="#包含：" class="headerlink" title="包含："></a>包含：</h6><ul><li>存储地址寄存器 Memory Address Register ,MAR</li><li>地址译码器</li><li>地址驱动器</li></ul><h6 id="访问存储器过程："><a href="#访问存储器过程：" class="headerlink" title="访问存储器过程："></a>访问存储器过程：</h6><ul><li>CPU或I/O与内存储器交换信息以存储单元为单位</li><li>访问存储器：<ul><li>即向存储单元存入或从存储单元取出信息</li></ul></li></ul><h6 id="CPU或i-o访存过程："><a href="#CPU或i-o访存过程：" class="headerlink" title="CPU或i/o访存过程："></a>CPU或i/o访存过程：</h6><ul><li>先将访存地址送MAR</li><li>经地址译码器找到被访问的存储单元</li><li>最后由地址驱动器驱动该存储单元以实现读和写</li></ul><h5 id="读写系统-Read-and-Write-System"><a href="#读写系统-Read-and-Write-System" class="headerlink" title="读写系统 Read and Write System"></a>读写系统 Read and Write System</h5><ul><li>包含：<ul><li>存储缓冲寄存器 Mcmory Buffer Register ,MBR</li><li>读写线路</li></ul></li><li>工作过程：<ul><li>读出时：<ul><li>控制器发出读控制信号</li><li>借助于读出线路<ul><li>将由选址系统确定的存储单元内容<ul><li>读出送至MBR</li></ul></li></ul></li><li>以供I/O或CPU使用</li></ul></li><li>写入时：<ul><li>先将要写入的数据送至MBR</li><li>控制器发出写控制信号</li><li>借助于写入线路<ul><li>将BMR内容写入<ul><li>由选址系统确定的存储单元</li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="存储时序控制线路-Memory-Sequential-Control-Circuit"><a href="#存储时序控制线路-Memory-Sequential-Control-Circuit" class="headerlink" title="存储时序控制线路 Memory Sequential Control Circuit"></a>存储时序控制线路 Memory Sequential Control Circuit</h5><ul><li>包含：<ul><li>控制触发器</li><li>各种门电路</li><li>延迟线路</li></ul></li><li>工作过程：<ul><li>接收来自I/O或CPU的<ul><li>启动</li><li>读写</li><li>清除<ul><li>等命令</li></ul></li></ul></li><li>产生一系列控制内存储器<ul><li>完成读写等操作的信号</li></ul></li></ul></li></ul><h4 id="输入设备和输出设备"><a href="#输入设备和输出设备" class="headerlink" title="输入设备和输出设备"></a>输入设备和输出设备</h4><h5 id="输入设备："><a href="#输入设备：" class="headerlink" title="输入设备："></a>输入设备：</h5><ul><li>作用：<ul><li>将<ul><li>数据</li><li>程序<ul><li>送入计算机</li></ul></li></ul></li></ul></li><li>常见的输入设备：<ul><li>键盘</li><li>鼠标</li><li>数字化仪</li><li>扫描仪</li><li>摄像机</li></ul></li><li>特点：<ul><li>多是电子和机电混合的装置</li><li>一般需要通过被称之为接口的电子部件与<ul><li>运算器</li><li>控制器</li><li>存储器相连接<ul><li>原因：<ul><li>与运算器、控制器、内存储器等纯电子部件相比<ul><li>速度较慢</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备:"></a>输出设备:</h5><h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><ul><li>将计算处理的结果转化为<ul><li>人或其它设备</li><li>所能识别或接收的信息形式的装置</li></ul></li></ul><h6 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h6><ul><li>显示器能将信息转化为字符、图像、图形，并在屏幕上显示</li><li>打印机能将文件打印出来</li><li>绘图机可将图形绘制出来</li></ul><h6 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h6><ul><li><p>与输入设备一样</p><ul><li><p>输出设备也多为机电装置</p></li><li><p>也需要通过接口与</p><ul><li><p>运算器</p></li><li><p>控制器</p></li><li><p>存储器</p><ul><li>相连接</li></ul></li></ul></li></ul></li></ul><h4 id="互连结构"><a href="#互连结构" class="headerlink" title="互连结构"></a>互连结构</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><ul><li>计算机的五大部件<ul><li>需通过互连结构Interconnection Structure<ul><li>连接成一个有机的整体</li></ul></li></ul></li></ul><h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><ul><li>现代计算机通常采用 <strong>总线</strong>互连结构</li></ul><h5 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h5><ul><li>是连接计算机各部件进行信息传送的一组共同传输线</li><li>其类型和结构形式繁多</li></ul><h2 id="1-3-计算机的工作过程"><a href="#1-3-计算机的工作过程" class="headerlink" title="1.3 计算机的工作过程"></a>1.3 计算机的工作过程</h2><h3 id="1-3-1-使用计算机求解一个简单例子"><a href="#1-3-1-使用计算机求解一个简单例子" class="headerlink" title="1.3.1 使用计算机求解一个简单例子"></a>1.3.1 使用计算机求解一个简单例子</h3><h4 id="计算机求解问题步骤："><a href="#计算机求解问题步骤：" class="headerlink" title="计算机求解问题步骤："></a>计算机求解问题步骤：</h4><ul><li>首先，由用户提出任务并建立数学模型</li><li>确定便于计算机实现的算法</li><li>选择合适的语言编写程序</li><li>上机调试运行</li><li>不论采用哪种程序设计语言编写源程序<ul><li>都必需转换为机器语言程序</li><li>即目标程序</li><li>然后计算机才能执行</li></ul></li></ul><h4 id="机器语言程序的定义："><a href="#机器语言程序的定义：" class="headerlink" title="机器语言程序的定义："></a>机器语言程序的定义：</h4><ul><li>是机器指令（简称指令）的有序集合</li></ul><h4 id="计算机的工作过程："><a href="#计算机的工作过程：" class="headerlink" title="计算机的工作过程："></a>计算机的工作过程：</h4><ul><li>就是执行指令的过程</li></ul><h4 id="简单例子-1-1"><a href="#简单例子-1-1" class="headerlink" title="简单例子 1.1"></a>简单例子 1.1</h4><p>用计算机求解代数多项式：x=ax^3+bx^2+cx+d,其中a,b,c,d,x为已知数</p><ul><li>对该代数多项式可直接进行四则运算<ul><li>先求出x^2和x^3</li><li>然后计算每项乘积ax^3,bx^2和cx</li><li>最后两两相加求得y值<ul><li>此算法需要5次乘法和3次加法</li><li>共8次运算</li></ul></li></ul></li><li>如果将多项式的幂、乘加形式 变换为 乘、加迭代形式<ul><li>即：y=((ax+b)x+c)x+d<ul><li>此时计算需要乘、加各3次</li><li>共6次计算</li></ul></li></ul></li><li>更改后：<ul><li>8次运算减少到了6次</li><li>运算次数减少了四分之一</li></ul></li><li>运算的操作对象：<ul><li>有两个<ul><li>一个为寄存器中的操作数</li><li>一个为存储器中的操作数</li></ul></li><li>能完成计算任务的指令字格式为：<ul><li><img src="/posts/7573/%E6%8C%87%E4%BB%A4%E5%AD%97%E6%A0%BC%E5%BC%8F.png" alt="指令字格式"></li></ul></li></ul></li></ul><h4 id="指令与指令系统简介："><a href="#指令与指令系统简介：" class="headerlink" title="指令与指令系统简介："></a>指令与指令系统简介：</h4><h5 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h5><ul><li>是计算机设计者赋予计算机实现某种基本操作的命令</li><li>一般包含两个字段：<ul><li>操作码字段</li><li>地址码字段</li></ul></li></ul><h5 id="操作码字段："><a href="#操作码字段：" class="headerlink" title="操作码字段："></a>操作码字段：</h5><ul><li>指出计算机要执行什么类型的操作</li><li>即决定了指令的功能</li></ul><h5 id="地址码字段："><a href="#地址码字段：" class="headerlink" title="地址码字段："></a>地址码字段：</h5><ul><li>指出参与操作的操作数或操作数的地址</li><li>即规定了指令的操作对象</li><li>地址码字段的操作对象可以是零个到多个</li></ul><h5 id="指令字："><a href="#指令字：" class="headerlink" title="指令字："></a>指令字：</h5><ul><li>由操作码和地址码共同构成</li></ul><h5 id="指令系统："><a href="#指令系统：" class="headerlink" title="指令系统："></a>指令系统：</h5><ul><li><p>特点：</p><ul><li>包含一台计算机所能执行的所有指令</li><li>表征着计算机的基本功能和使用属性</li><li>计算机只能执行自己指令系统中的指令</li></ul></li><li><p>包括：</p><ul><li>算术运算</li><li>数据传送</li><li>处理机控制</li></ul></li><li><p>假如在某32位字长，设有16个通用寄存器的计算机上进行例1.1要求的计算机</p><ul><li>其指令格式如下：</li><li><img src="/posts/7573/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="指令格式"></li><li>OP<ul><li>操作码，占八位</li><li>表示该机指令系统中最多包含256条指令</li><li>这些指令包括<ul><li>算术运算，例如加，乘</li><li>数据传送，例如存数、取数</li><li>处理机控制，例如停机</li></ul></li></ul></li><li>Ri：<ul><li>操作数在寄存器中的地址</li><li>指向某通用寄存器，用4位表示</li><li>16个通用寄存器的地址（编号）可以分别用16进制的0~F来表示</li></ul></li><li>D：<ul><li>操作数在存储器中的地址</li><li>指向内存储器某存储单元</li><li>用20位表示</li><li>表示该计算机最多能访问2^20个存储单元</li></ul></li><li>该计算机的地址码：<ul><li>由Ri和D共同构成</li></ul></li><li>计算机的指令字:<ul><li>由OP,Ri，D构成</li></ul></li></ul></li><li><p>为完成例1.1工作，该计算机提供5条指令</p><ul><li><p>他们的操作码和指令功能见表1.1</p></li><li><p><img src="/posts/7573/%E8%A1%A81-1.png" alt="表1.1"></p></li><li><p>根据此表</p><ul><li>该指令将寄存器R8中的数据<ul><li>与地址为04000H的存储单元中的数据做加法</li></ul></li><li>结果放入寄存器R8中</li></ul></li><li><p>对于同一条指令的表示，可采用两种方法：</p><ul><li>二进制<ul><li>在计算机中存储的指令为二进制形式</li></ul></li><li>十六进制<ul><li>只是为了方便人们的书写和阅读</li></ul></li></ul></li></ul></li></ul><h4 id="编写求Y的机器语言程序"><a href="#编写求Y的机器语言程序" class="headerlink" title="编写求Y的机器语言程序"></a>编写求Y的机器语言程序</h4><h5 id="编写机器语言程序之前："><a href="#编写机器语言程序之前：" class="headerlink" title="编写机器语言程序之前："></a>编写机器语言程序之前：</h5><ul><li>必须进行存储单元分配</li></ul><h5 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h5><ul><li><p>假定将初始数据x,a,b,c,d分别存放在地址为</p><ul><li>00B00H~00B04H的存储单元中</li></ul></li><li><p>计算结果y存储到地址为00B05H的存储单元</p></li><li><p>程序存放在以00A00H为始地址的存储单元中</p></li><li><p>过程如表：</p></li><li><img src="/posts/7573/求y程序.png" alt="求y程序" style="zoom:60%;"></li><li><p>存储形式：</p><ul><li>如上图，指令和数据<ul><li>都是以代码形式存储在同一存储器的</li><li>计算机在执行时才加以区分</li></ul></li><li>这是冯诺依曼计算机最基本的原理</li></ul></li></ul><h3 id="1-3-2-指令执行过程"><a href="#1-3-2-指令执行过程" class="headerlink" title="1.3.2 指令执行过程"></a>1.3.2 指令执行过程</h3><h4 id="计算机总体框图"><a href="#计算机总体框图" class="headerlink" title="计算机总体框图"></a>计算机总体框图</h4><img src="/posts/7573/计算机总体框图.png" alt="计算机总体框图" style="zoom:67%;"><ul><li>实线箭头：<ul><li>代表数据信号</li></ul></li><li>虚线箭头<ul><li>代表控制信号</li></ul></li></ul><h4 id="指令工作过程简介："><a href="#指令工作过程简介：" class="headerlink" title="指令工作过程简介："></a>指令工作过程简介：</h4><h5 id="计算机工作过程："><a href="#计算机工作过程：" class="headerlink" title="计算机工作过程："></a>计算机工作过程：</h5><ul><li>实质是执行程序的过程<ul><li>执行程序的过程实质是<ul><li>逐条执行指令的过程</li></ul></li></ul></li></ul><h5 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h5><ul><li>取指令过程</li><li>执行指令过程</li></ul><h5 id="取指令过程"><a href="#取指令过程" class="headerlink" title="取指令过程"></a>取指令过程</h5><ul><li>程序计数器PC内容送往内存储器选址系统的MAR，即MAR&lt;-PC</li><li>控制器向内存储器发出读命令<ul><li>内存储器把MAR所指存储单元的内容读出送MBR</li><li>即MBR&lt;-M(MAR)</li><li>注意：此时MBR存放的是指令</li></ul></li><li>程序计数器内容加1<ul><li>为下一条指令准备好地址</li><li>即PC&lt;-PC+1</li></ul></li><li>经系统总线<ul><li>把MBR中的指令送控制器的指令寄存器IR</li><li>即IR&lt;-MBR</li></ul></li></ul><h5 id="执行指令过程"><a href="#执行指令过程" class="headerlink" title="执行指令过程"></a>执行指令过程</h5><ul><li>指令送到IR之后，计算机就进入执行指令过程</li><li>指令操作码经ID译码后<ul><li>确定执行操作的内容</li><li>然后将操作控制信号送入微操作控制部件</li></ul></li><li>在时序部件和运算状态的配合下<ul><li>由微操作控制部件向相关部件</li><li>发送执行该指令需要的所有 <strong>微操作控制信号</strong></li></ul></li><li>指令不同，微操作控制信号序列也不同<ul><li>执行不同的指令，涉及和使用的部件也不相同</li></ul></li><li>有些指令<ul><li>仅涉及和使用控制器部件</li><li>有些既涉及和使用控制器<ul><li>也涉及和使用内存储器、运算器、I/O等部件</li></ul></li></ul></li><li>但无论执行什么部件<ul><li>执行完最后一个微操作后，</li><li>都会返回到取指令的公共操作阶段</li></ul></li></ul><h5 id="以执行加法指令为例说明指令执行过程："><a href="#以执行加法指令为例说明指令执行过程：" class="headerlink" title="以执行加法指令为例说明指令执行过程："></a>以执行加法指令为例说明指令执行过程：</h5><ul><li>当ID译码后，加法控制电位为有效</li><li>在TSG配合下，微操作控制部件首先发出控制信号MAR&lt;-D<ul><li>将存储器操作数的地址送至MAR</li></ul></li><li>然后读存储器<ul><li>并将读出的数据送至MBR</li><li>即MBR&lt;-M(MAR)</li></ul></li><li>接着分别将加数、被加数送往两个锁存器</li><li>最后完成加法操作<ul><li>并将结果送回Ri</li><li>即Ri&lt;-锁存器1+锁存器2</li></ul></li><li>加法指令执行完成后，又回到下一条指令的取指令过程</li><li>如此周而复始执行程序中的每条指令，直至程序执行完毕</li></ul><img src="/posts/7573/指令执行过程.png" alt="指令执行过程" style="zoom:60%;"><h3 id="1-3-3-计算机工作的过程"><a href="#1-3-3-计算机工作的过程" class="headerlink" title="1.3.3 计算机工作的过程"></a>1.3.3 计算机工作的过程</h3><h4 id="程序设计好后如何装入内存储器？"><a href="#程序设计好后如何装入内存储器？" class="headerlink" title="程序设计好后如何装入内存储器？"></a>程序设计好后如何装入内存储器？</h4><ul><li>通过操作系统下的调试程序<ul><li>送到内存储器指令存储区域</li></ul></li><li>同时通过它把机器语言程序的始地址送给程序计数器PC</li></ul><h4 id="例1-1计算机工作过程"><a href="#例1-1计算机工作过程" class="headerlink" title="例1.1计算机工作过程"></a>例1.1计算机工作过程</h4><h5 id="启动计算机："><a href="#启动计算机：" class="headerlink" title="启动计算机："></a>启动计算机：</h5><ul><li>把程序始地址00A00H送PC</li><li>然后可启动计算机工作<ul><li>计算机开始执行程序<ul><li>即开始了指令执行的过程</li></ul></li></ul></li></ul><h5 id="指令执行的过程："><a href="#指令执行的过程：" class="headerlink" title="指令执行的过程："></a>指令执行的过程：</h5><ul><li>从00A00H存储单元取出指令10800B01H放入IR</li><li>PC内容加1变为00A01H</li><li>IR的内容经ID译码发现是取数指令</li><li>于是在执行指令阶段<ul><li>将存储单元00B01H中的数a读到R8寄存器中</li></ul></li><li>接着又进入取指令阶段<ul><li>从00A01H存储单元取出指令08800 B00H放入IR</li><li>PC内容加1变为00A02H</li><li>IR的内容经ID译码发现是乘法指令</li></ul></li><li>于是在执行指令阶段<ul><li>从00B00H存储单元取出乘数</li><li>将它与R8中的被乘数a进行乘法运算</li><li>乘积存入R8</li></ul></li><li>接着又从00A02H存储单元取出指令02800B02H放入IR<ul><li>PC内容加1变成00A03H</li><li>IR的内容经ID译码发现是加法指令</li><li>执行加法指令</li></ul></li><li>如果此执行程序中的每条指令<ul><li>直至从00A08H存储单元取出停机指令并执行</li><li>停机指令使TSG不再发出节拍信号</li><li>计算机也停止了指令执行过程</li><li>该程序执行完毕</li></ul></li></ul><h2 id="1-4-计算机的性能指标和分类"><a href="#1-4-计算机的性能指标和分类" class="headerlink" title="1.4 计算机的性能指标和分类"></a>1.4 计算机的性能指标和分类</h2><h3 id="1-4-1-计算机的性能指标"><a href="#1-4-1-计算机的性能指标" class="headerlink" title="1.4.1 计算机的性能指标"></a>1.4.1 计算机的性能指标</h3><h4 id="与硬件相关的几个性能指标："><a href="#与硬件相关的几个性能指标：" class="headerlink" title="与硬件相关的几个性能指标："></a>与硬件相关的几个性能指标：</h4><ul><li>主频</li><li>运算速度</li><li>运算精度</li><li>主存存储容量</li><li>主存存储周期</li></ul><h4 id="主频："><a href="#主频：" class="headerlink" title="主频："></a>主频：</h4><h5 id="主频（或时钟周期）："><a href="#主频（或时钟周期）：" class="headerlink" title="主频（或时钟周期）："></a>主频（或时钟周期）：</h5><ul><li>是计算机的主要性能指标之一</li><li>很大程度上决定计算机的运行速度</li></ul><h5 id="主频的特点："><a href="#主频的特点：" class="headerlink" title="主频的特点："></a>主频的特点：</h5><ul><li>主频越高<ul><li>CPU的工作节拍就越快</li><li>运算速度就越高</li></ul></li><li>主频通常用一秒钟内处理器能发出电子脉冲数来表示<ul><li>单位一般为兆赫兹MHZ</li></ul></li></ul><h5 id="时钟CP："><a href="#时钟CP：" class="headerlink" title="时钟CP："></a>时钟CP：</h5><ul><li>CPU的工作节拍是由时钟CP控制的</li><li>时钟不断产生固定频率的时钟脉冲</li><li>这个脉冲就是 CPU的 <strong>主频f</strong></li></ul><h5 id="以Intel系列微型计算机为例："><a href="#以Intel系列微型计算机为例：" class="headerlink" title="以Intel系列微型计算机为例："></a>以Intel系列微型计算机为例：</h5><ul><li>最早8086的主频为5MHZ</li><li>80386的主频为16MHZ</li><li>586的主频可达到266MHZ</li><li>奔腾二代的主频可达450MHZ</li><li>奔腾三代的主频可达1.2GHZ</li><li>奔腾四代的主频现已达3GHZ甚至更高</li></ul><h4 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h4><h5 id="运算速度的概念："><a href="#运算速度的概念：" class="headerlink" title="运算速度的概念："></a>运算速度的概念：</h5><ul><li>是计算机工作能力和工作效率的主要表征</li><li>取决于在给定时间内处理器所能处理的数据量以及处理器的时钟频率</li></ul><h5 id="运算速度的表示："><a href="#运算速度的表示：" class="headerlink" title="运算速度的表示："></a>运算速度的表示：</h5><ul><li>通常用每秒执行指令的条数来表示</li><li>计量单位：<ul><li>MIPS 百万条指令每秒<ul><li>用来描述计算机的定点运算速度</li></ul></li><li>MFLOPS 百万次浮点预算每秒<ul><li>用来描述计算机的浮点运算速度</li></ul></li></ul></li></ul><h5 id="运算速度的计算方法："><a href="#运算速度的计算方法：" class="headerlink" title="运算速度的计算方法："></a>运算速度的计算方法：</h5><h6 id="吉普森混合法："><a href="#吉普森混合法：" class="headerlink" title="吉普森混合法："></a>吉普森混合法：</h6><ul><li>也称 混合比率计算法</li><li>原理<ul><li>从应用课题程序中统计各类指令所占百分比</li><li>然后用指令混合比计算指令的平均执行速度</li></ul></li><li>具体计算方法：<ul><li>假定第i类指令(i=1,2,…,n)在使用过程中<ul><li>出现的概率为P</li><li>执行时间为ti</li><li>则指令的平均执行时间tE为：<ul><li><img src="/posts/7573/%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="执行时间"></li><li>tE的倒数是 吉布森混合法平均执行速度<ul><li>其中Pi的集合即为混合比</li></ul></li></ul></li></ul></li></ul></li><li>缺陷：<ul><li>现代计算机的指令系统十分复杂<ul><li>不少指令执行时间不固定</li><li>采用固定比例可能脱离实际</li><li>所以这种方法较少采用</li></ul></li></ul></li></ul><h6 id="计算各种指令的执行速度"><a href="#计算各种指令的执行速度" class="headerlink" title="计算各种指令的执行速度"></a>计算各种指令的执行速度</h6><ul><li>原理：<ul><li>根据计算机的主频f（MHZ）</li><li>求出处理器的基本节拍周期T=1/f（ns）</li><li>再根据处理器结构模型和指令操作流程</li><li>可推算出 <ul><li>执行各种指令的基本节拍数 和每秒执行指令的条数</li></ul></li></ul></li><li>缺陷：<ul><li>这种方法得到的性能并不十分精确<ul><li>有时甚至做了一些理想化的假定<ul><li>例如：假定全部功能部件都处在满负荷的最佳工作状态下</li></ul></li><li>这种在理想状态下得到的最佳性能被称为 <strong>峰值执行速度</strong><ul><li>在实际指令执行时是不可能出现的</li></ul></li></ul></li></ul></li></ul><h6 id="计算典型程序的运算速度"><a href="#计算典型程序的运算速度" class="headerlink" title="计算典型程序的运算速度"></a>计算典型程序的运算速度</h6><ul><li>选取应用中具有代表性的课题<ul><li>eg：<ul><li>快速傅里叶变换FFT</li><li>图形图像的处理</li><li>等等</li></ul></li><li>计算这些典型程序的运算速度</li></ul></li></ul><h6 id="计算计算机运算速度其他方法："><a href="#计算计算机运算速度其他方法：" class="headerlink" title="计算计算机运算速度其他方法："></a>计算计算机运算速度其他方法：</h6><ul><li>模型分析与模型模拟</li><li>实际测量</li><li>等等</li></ul><h4 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a>运算精度</h4><h5 id="衡量标准："><a href="#衡量标准：" class="headerlink" title="衡量标准："></a>衡量标准：</h5><ul><li>运算精度通常用计算机能直接处理的 <strong>二进制信息位数</strong> 来衡量</li></ul><h5 id="二进制信息位数："><a href="#二进制信息位数：" class="headerlink" title="二进制信息位数："></a>二进制信息位数：</h5><ul><li>特点：<ul><li>一般与CPU中存储数据寄存器的位数相同</li><li>位数越多，精度越高</li></ul></li></ul><h5 id="基本字长："><a href="#基本字长：" class="headerlink" title="基本字长："></a>基本字长：</h5><ul><li>定义：<ul><li>参与运算操作数的基本位数成为 <strong>基本字长</strong></li></ul></li><li>特点：<ul><li>在一定情况下标志着计算精度</li><li>决定着<ul><li>寄存器</li><li>加法器</li><li>数据总线<ul><li>等的位数</li></ul></li></ul></li><li>直接影响着硬件的造价</li></ul></li></ul><h5 id="变字长计算："><a href="#变字长计算：" class="headerlink" title="变字长计算："></a>变字长计算：</h5><ul><li>原因：<ul><li>为适应不同类型计算的需要</li><li>并较好地协调精度与造价的关系</li></ul></li><li>eg：<ul><li>半字长</li><li>全字长</li><li>双字长</li><li>等等</li></ul></li></ul><h5 id="计算机字长："><a href="#计算机字长：" class="headerlink" title="计算机字长："></a>计算机字长：</h5><ul><li>早期微型计算机<ul><li>字长多为 <strong>8位</strong> 和 <strong>16</strong>位</li><li>现在多为 <strong>32</strong>位</li></ul></li><li>大中型计算机<ul><li>多为 <strong>32</strong>位 和 <strong>64位</strong></li></ul></li><li>巨型计算机<ul><li>一般都是 <strong>64</strong>位</li></ul></li></ul><h4 id="主存存储容量"><a href="#主存存储容量" class="headerlink" title="主存存储容量"></a>主存存储容量</h4><h5 id="主存储器作用："><a href="#主存储器作用：" class="headerlink" title="主存储器作用："></a>主存储器作用：</h5><ul><li>用来存储数据和程序</li><li>直接与CPU交换信息</li></ul><h5 id="主存储器特点："><a href="#主存储器特点：" class="headerlink" title="主存储器特点："></a>主存储器特点：</h5><ul><li>主存容量越大<ul><li>可存储的数据和程序就越多</li><li>处理问题的能力也就越强</li></ul></li><li>主存与外存储器的<ul><li>信息交换次数越少</li><li>系统的效率就越高</li></ul></li></ul><h5 id="主存容量的地位"><a href="#主存容量的地位" class="headerlink" title="主存容量的地位;"></a>主存容量的地位;</h5><ul><li>是衡量计算机的主要性能指标之一</li></ul><h5 id="主存容量的表示："><a href="#主存容量的表示：" class="headerlink" title="主存容量的表示："></a>主存容量的表示：</h5><ul><li>以字为单位的计算机<ul><li>常用 <strong>字数</strong> 乘以 <strong>字长</strong> 表示主存容量</li><li>eg：<ul><li>4K x 16位<ul><li>表示主存有4096个存储单元</li><li>每个单元字长16位</li></ul></li></ul></li></ul></li><li>以字节为单位的计算机<ul><li>以 <strong>字节数</strong> 表示主存容量</li><li>eg：<ul><li>32KB</li><li>表示主存容量为<ul><li>32768x8位</li></ul></li></ul></li></ul></li></ul><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><ul><li>现在的高档微机<ul><li>主存容量从128MB,256MB不等</li><li>有的为2GB甚至更高</li></ul></li></ul><h4 id="主存存取周期"><a href="#主存存取周期" class="headerlink" title="主存存取周期"></a>主存存取周期</h4><h5 id="“写入”的定义："><a href="#“写入”的定义：" class="headerlink" title="“写入”的定义："></a>“写入”的定义：</h5><ul><li>将信息存入主存</li></ul><h5 id="“读出”的定义："><a href="#“读出”的定义：" class="headerlink" title="“读出”的定义："></a>“读出”的定义：</h5><ul><li>将信息从主存中取出</li></ul><h5 id="“访存”的定义："><a href="#“访存”的定义：" class="headerlink" title="“访存”的定义："></a>“访存”的定义：</h5><ul><li>对主存的读写</li></ul><h5 id="存取周期："><a href="#存取周期：" class="headerlink" title="存取周期："></a>存取周期：</h5><ul><li>定义：<ul><li>对主存连续两次访存所允许的最小时间间隔</li></ul></li><li>地位：<ul><li>既是 表征主存性能的基本参数</li><li>也是反应计算机整机性能的重要参数</li></ul></li><li>特点：<ul><li>存取周期越小<ul><li>表明从主存存取信息的时间越短</li><li>计算机系统性能越高</li></ul></li></ul></li><li>数值：<ul><li>现代 计算机主存存取周期 一般在<ul><li>几十纳秒</li><li>有时甚至几个纳秒</li></ul></li></ul></li></ul><h5 id="计算机技术性能评价的因素："><a href="#计算机技术性能评价的因素：" class="headerlink" title="计算机技术性能评价的因素："></a>计算机技术性能评价的因素：</h5><ul><li><p>计算机技术性能高低好坏，考虑因素应多方面：</p><ul><li>如<ul><li>系统结构、硬件组成、外设配置</li><li>软件种类、吞吐率、响应时间</li><li>可靠性、可用性、可维性</li><li>完整性、安全性</li></ul></li><li>不能片面强调一项指标，应综合全面考虑</li></ul></li><li><p>综合性指标：</p><ul><li>通常以 <strong>性能价格比</strong> 为综合性指标</li><li>性能：<ul><li>指机器的综合性能</li><li>包括：<ul><li>硬件、软件的各种性能</li></ul></li></ul></li><li>价格：<ul><li>指的是整个系统的价格</li></ul></li><li>性能价格比 <strong>越大越好</strong><ul><li>它是选择和设计计算机的重要依据</li></ul></li></ul></li></ul><h3 id="1-4-2-计算机的分类"><a href="#1-4-2-计算机的分类" class="headerlink" title="1.4.2 计算机的分类"></a>1.4.2 计算机的分类</h3><h4 id="电子计算机的定义："><a href="#电子计算机的定义：" class="headerlink" title="电子计算机的定义："></a>电子计算机的定义：</h4><ul><li>是一种由电子线路构成的设备</li><li>能对信息进行记忆、传送、处理<ul><li>从而实现计算的功能</li></ul></li></ul><h4 id="计算机常见分类方法："><a href="#计算机常见分类方法：" class="headerlink" title="计算机常见分类方法："></a>计算机常见分类方法：</h4><ul><li>按计算机用途分类：<ul><li>通用计算机</li><li>专用计算机</li></ul></li><li>按计算机规模分类：<ul><li>巨型机</li><li>大型计算机</li><li>小型计算机</li><li>微型计算机</li><li>单片机</li></ul></li></ul><h4 id="专用计算机："><a href="#专用计算机：" class="headerlink" title="专用计算机："></a>专用计算机：</h4><ul><li><p>定义：</p><ul><li>是针对某一特定应用领域<ul><li>或面向某种算法</li><li>的计算机</li></ul></li></ul></li><li><p>eg：</p><ul><li>工业过程中的控制计算机</li><li>军事上武器设备的控制指挥仪</li><li>卫星图像处理和天气预报使用的大型并行处理机</li><li>等等</li></ul></li><li><p>特点：</p><ul><li>专用机的结构和软件是专门针对其应用领域设计的</li><li>因而对该领域的应用是高效的</li></ul></li><li><p>缺点：</p><ul><li>若用于其他领域<ul><li>则效率较低甚至无法运行</li></ul></li></ul></li><li><p>优点：</p><ul><li>功能单一、结构较简单</li><li>成本较低、可靠性较高</li></ul></li></ul><h4 id="通用计算机"><a href="#通用计算机" class="headerlink" title="通用计算机"></a>通用计算机</h4><ul><li>定义：<ul><li>即人们常说的计算机</li></ul></li><li>配置:<ul><li>通常根据不同计算机系列型号配备一定外设</li><li>它配备多种系统软件<ul><li>eg：<ul><li>操作系统</li><li>数据库管理软件</li><li>多种工具软件</li></ul></li></ul></li><li>只要再配备相应应用软件<ul><li>就可以应用于各种领域</li></ul></li></ul></li><li>特点：<ul><li>通用性强</li><li>功能全</li></ul></li></ul><h4 id="规模："><a href="#规模：" class="headerlink" title="规模："></a>规模：</h4><ul><li>是综合计算机多方面因素而言</li><li>通常涉及<ul><li>计算机的运算速度、字长、存储容量、外部设备等硬件配置</li><li>以及软件、价格等诸多方面</li></ul></li><li>按规模分类实际是<ul><li>按计算机性能分类</li></ul></li><li>变化：<ul><li>随计算机科学技术飞速发展<ul><li>这种规模或性能的概念也在不断变化</li></ul></li><li>昔日超级计算机<ul><li>可能赶不上现在的微型机</li></ul></li></ul></li></ul><h4 id="巨型机："><a href="#巨型机：" class="headerlink" title="巨型机："></a>巨型机：</h4><ul><li>名称：<ul><li>Supercomputer</li><li>也称 超级计算机</li></ul></li><li>地位：<ul><li>是一个国家科技水平、经济水平、军事威力的象征<ul><li>目前只有美英俄法日等少数几个国家拥有巨型机</li></ul></li></ul></li><li>优点：<ul><li>速度最快、性能最高</li><li>功能最强、技术最复杂</li></ul></li><li>作用：<ul><li>拥有巨大的数值计算和信息处理能力</li><li>是计算机高精尖技术的集中代表</li></ul></li><li>特点：<ul><li>一般字长为64位</li><li>每秒平均执行百亿次以上的浮点运算</li><li>主存容量1~4百万字以上</li><li>其高速数据通道每秒可传送数据几千万个字以上</li><li>具有丰富的系统软件</li></ul></li><li>举例：<ul><li>IBM公司SP2系列<ul><li>速度可达每秒3万亿次浮点运算</li></ul></li><li>Intel公司使用Pentium Pro构成的巨型计算机Paragon<ul><li>速度可达到每秒1万亿次</li></ul></li><li>我国自行研制的<ul><li>银河二型巨型机<ul><li>运算速度达到每秒10亿次</li></ul></li><li>银河三型巨型机<ul><li>运算速度达到每秒130亿次</li></ul></li><li>曙光巨型机<ul><li>运算速度达到每秒3000亿次</li></ul></li></ul></li></ul></li></ul><h4 id="大型计算机"><a href="#大型计算机" class="headerlink" title="大型计算机"></a>大型计算机</h4><ul><li>名称：<ul><li>Large Scale Computer/Mainframe</li></ul></li><li>地位：<ul><li>是计算机家族中 通用性最强、功能很强的计算机</li><li>是体现所在时代计算机科技水平的一类高性能大容量计算机</li></ul></li><li>特点：<ul><li>一般字节32~64位</li><li>每秒执行数百万到数千万条指令</li><li>主存容量几十万到几百万字</li><li>有较多的外设和通信接口</li><li>有很强的I/O处理能力和丰富的系统软件及应用软件</li></ul></li><li>典型机种：<ul><li>20世纪<ul><li>60年代的IBM360系列</li><li>70年代的IBM370系列</li><li>80年代的IBM 370-XA系列</li><li>90年代的IBM390系列</li></ul></li></ul></li></ul><h4 id="小型计算机"><a href="#小型计算机" class="headerlink" title="小型计算机"></a>小型计算机</h4><ul><li>名称：<ul><li>Minicomputer</li></ul></li><li>优点：<ul><li>性能较好</li><li>价格便宜</li><li>应用领域广泛</li></ul></li><li>特点：<ul><li>一般字长32位</li><li>速度每秒几十万到几百万次</li><li>内存容量几万到几十万字</li><li>配有一定数量的外设与通信接口</li><li>有汇编语言和多种高级语言</li><li>有功能较强的操作系统</li></ul></li><li>超级小型计算机：<ul><li>Super Minicomputer</li><li>处理能力、内存容量、操作系统功能远超一般小型计算机</li></ul></li><li>典型机种：（包括小型与超级小型)<ul><li>NOVA系列</li><li>PDP-11系列</li><li>VAX-11系列</li><li>MicroVAX系列</li><li>王安VS系列</li></ul></li></ul><h4 id="微型计算机"><a href="#微型计算机" class="headerlink" title="微型计算机"></a>微型计算机</h4><ul><li>简称：<ul><li>微型机</li><li>微机</li></ul></li><li>特点：<ul><li>以微处理器为中央处理器</li></ul></li><li>优点：<ul><li>性能价格比最高</li><li>应用领域最广</li></ul></li><li>发展状况：<ul><li>发展最快、市场占有率最高</li><li>许多性能达到甚至超过小型机水平</li><li>正不断向微型化、网络化、高性能、多用途方向发展</li></ul></li><li>分类方法：<ul><li>按字长分：<ul><li>8位</li><li>16位</li><li>32位</li></ul></li><li>按组装形式分：<ul><li>非便携式<ul><li>eg：台式机</li></ul></li><li>便携式<ul><li>eg：可移动的微型机<ul><li>笔记本型或掌上型计算机</li></ul></li></ul></li></ul></li><li>按最终是否由用户使用分：<ul><li>独立式<ul><li>可由最终用户直接使用</li><li>eg：个人计算机 PC Personal Computer</li></ul></li><li>嵌入式<ul><li>将其作为一个信息处理部件装入一个应用设备</li><li>最终用户不直接使用计算机，而使用该设备</li><li>eg：<ul><li>包含计算机的医疗设备、家用电器等</li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="单片机："><a href="#单片机：" class="headerlink" title="单片机："></a>单片机：</h4><ul><li>定义：<ul><li>将中央处理器、存储器、输入输出接口集成在一块芯片上的微型计算机<ul><li>简称：<ul><li>单片机 Single Chip Computer</li></ul></li></ul></li><li>由于主要应用于控制系统，所以又通常称：<ul><li>微控制器 Micro Control Unit ,MCU</li></ul></li></ul></li><li>特点：<ul><li>一般采用 <strong>面向控制</strong> 的系统结构和指令系统</li><li>字长<ul><li>从4位、8位、到16位</li><li>20世纪90年代推出32位单片机</li></ul></li><li>显著特点：<ul><li>多功能的输入、输出结构</li></ul></li></ul></li><li>常有：<ul><li>定时计数器</li><li>并行接口</li><li>串行接口</li><li>数模转换器</li><li>模数转换器</li></ul></li><li>地位：<ul><li>与个人计算器一样，是目前应用最广、产量最高的两种计算机</li></ul></li><li>应用：<ul><li>单片机 多作为MCU装入各种设备<ul><li>是嵌入式微型化计算机最主要的形式</li></ul></li><li>通常在家用电器、一般控制及高速控制等应用领域</li><li>家用电器中：<ul><li>多采用4位单片机或低档8位单片机</li></ul></li><li>在一般控制应用中：<ul><li>多采用高性能8位或16位单片机</li></ul></li><li>在高速控制应用中：<ul><li>多采用高性能16位或32位单片机</li></ul></li></ul></li></ul><h2 id="1-5-计算机应用与发展"><a href="#1-5-计算机应用与发展" class="headerlink" title="1.5 计算机应用与发展"></a>1.5 计算机应用与发展</h2><h3 id="1-5-1-计算机的应用"><a href="#1-5-1-计算机的应用" class="headerlink" title="1.5.1 计算机的应用"></a>1.5.1 计算机的应用</h3><h4 id="大体分类："><a href="#大体分类：" class="headerlink" title="大体分类："></a>大体分类：</h4><ul><li><p>科学计算</p></li><li><p>数据处理</p></li><li><p>实时控制</p></li><li><p>辅助设计</p></li><li><p>智能模拟</p><p>（虽覆盖计算机大多数领域，但未能包括全部）</p></li></ul><h4 id="1-科学计算"><a href="#1-科学计算" class="headerlink" title="1.科学计算"></a>1.科学计算</h4><ul><li>是计算机一个重要领域</li><li>有效地使用数字计算机<ul><li>来求解数学问题的近似解的理论、方法和过程<ul><li>已形成专门的学科：</li><li>数值计算 Numerical Computation</li></ul></li></ul></li><li>eg:<ul><li>求解上千阶微分方程组</li></ul></li><li>大大促进科学研究与国民经济发展</li></ul><h4 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2.数据处理"></a>2.数据处理</h4><ul><li>主要功能：<ul><li>将输入设备送来的数据及时记录、整理、分类、加工<ul><li>以得到需要的信息</li></ul></li><li>eg：<ul><li>企业管理、库存管理、账目计算、情报检索、图像处理等等</li></ul></li></ul></li><li>特点：<ul><li>原始数据量大、算数运算比较简单、有大量逻辑与判断</li><li>处理的结果多以报表或文件形式存储或输出</li><li>对于这些工作，人力无法完成，采用计算机可很快得出结果</li></ul></li><li>实例：<ul><li>利用数据库系统软件，如Sybase,Oracle,Access等开发的各种应用软件系统<ul><li>eg：<ul><li>财务管理系统、交通客票预定系统、人事管理系统</li><li>办公自动化系统、数字地图系统、情报分析与检测系统</li></ul></li></ul></li></ul></li><li>优点：<ul><li>使人们从大量繁杂的数据统计与管理事务中解脱出来<ul><li>大大提高了工作效率与质量</li></ul></li><li>利用计算机网络与通信技术<ul><li>实现资源共享与远程信息传输</li><li>更使数据处理这类应用焕发生机</li></ul></li></ul></li></ul><h4 id="3-实时控制："><a href="#3-实时控制：" class="headerlink" title="3.实时控制："></a>3.实时控制：</h4><ul><li>是计算机在过程控制中的重要应用</li><li>“实时”的定义：<ul><li>就是指计算机的运算和控制时间与被控制过程的实际时间相适应</li></ul></li><li>“实时性”<ul><li>是以计算机速度为基础的</li><li>不同受控对象其物理过程的时间参数是不同的</li><li>eg：<ul><li>生产过程控制时间参数较大<ul><li>对计算机速度要求不高</li></ul></li><li>对武器发射过程控制时间参数较小<ul><li>对计算机速度要求高</li></ul></li></ul></li></ul></li><li>过程控制应用：<ul><li>最初：<ul><li>主要应用于导弹、卫星、飞船等</li><li>现代化武器系统和航空航天等领域</li></ul></li><li>现在：<ul><li>已广泛运用于工业生产过程</li><li>过程控制发挥神经系统功能<ul><li>由于高灵敏度、高精确度控制</li><li>使得上述领域工作能在人的意志控制下准确无误完成</li></ul></li></ul></li></ul></li></ul><h4 id="4-辅助设计"><a href="#4-辅助设计" class="headerlink" title="4.辅助设计"></a>4.辅助设计</h4><ul><li>定义：<ul><li>Computer Aided Design,CAD</li><li>是利用计算机能帮助设计人员进行工程、产品等设计工作的过程和技术</li></ul></li><li>应用：<ul><li>在航天航空、船舶交通、机械电子、基建和化工等部门</li><li>由计算机辅助产生的设计结果通过图形设备与设计人员交互<ul><li>可及时对设计进行判断和修改</li><li>最终完成设计工作</li></ul></li></ul></li><li>优点：<ul><li>提高了设计的自动化水平</li><li>缩短了设计周期</li><li>减轻了设计人员的劳动</li><li>大大提高了设计质量</li></ul></li><li>计算机辅助制造CAM：<ul><li>CAD发展带动了CAM进步</li><li>定义：<ul><li>CAM是在制造业中<ul><li>利用计算机辅助各种设备完成产品的加工、装配、检测、和包装等的过程和技术</li></ul></li></ul></li><li>优点：<ul><li>显著提高了企业的生产效率</li><li>缩短了工作周期</li><li>降低了产品成本</li><li>提高了产品质量</li></ul></li><li>CAD/CAM系统：<ul><li>有CAD与CAM紧密结合一起而构成</li></ul></li></ul></li><li>计算机辅助教学CAI：<ul><li>定义：<ul><li>是利用计算机辅助教师对学生进行教学的过程和技术</li></ul></li><li>最大特点：<ul><li>在计算机和学生之间实现对话</li><li>学生可以根据个人特点进行学习，变被动为主动</li><li>生动直观形象，极大提高学习兴趣与效果</li></ul></li></ul></li></ul><h4 id="5-智能模拟"><a href="#5-智能模拟" class="headerlink" title="5.智能模拟"></a>5.智能模拟</h4><h5 id="人工智能："><a href="#人工智能：" class="headerlink" title="人工智能："></a>人工智能：</h5><ul><li>地位：<ul><li>是计算机应用研究最前沿的学科</li></ul></li><li>定义：<ul><li>是采用计算机来研究开发用于模拟、延伸和扩展人的只能</li><li>eg：智能、推理、学习、理解</li><li>是在质的方面扩充计算机的能力<ul><li>提高它的智能水平</li></ul></li></ul></li><li>研究与应用：<ul><li>已在模式识别、景物分析、自然语言的理解与生成</li><li>博弈、自动定理证明、自动程序设计、专家系统</li><li>模拟训练系统、智能决策系统以及机器人领域得到发展</li></ul></li></ul><h5 id="智能模拟："><a href="#智能模拟：" class="headerlink" title="智能模拟："></a>智能模拟：</h5><ul><li>优点：<ul><li>将计算机的应用提高到了一个更高的阶段</li><li>为计算机的推广应用开拓出一个全新的领域</li></ul></li></ul><h3 id="1-5-2-计算机发展前景"><a href="#1-5-2-计算机发展前景" class="headerlink" title="1.5.2 计算机发展前景"></a>1.5.2 计算机发展前景</h3><h4 id="趋势："><a href="#趋势：" class="headerlink" title="趋势："></a>趋势：</h4><ul><li>巨型化</li><li>微型化</li><li>网络化</li><li>智能化</li></ul><h4 id="1-巨型化："><a href="#1-巨型化：" class="headerlink" title="1.巨型化："></a>1.巨型化：</h4><ul><li>原因：<ul><li>航空航天、气象预报、地震分析、原子裂变、生物工程等领域中<ul><li>大型科学计算和数据处理的需要</li><li>对超大规模、高性能巨型计算机提出永无止境的性能要求</li></ul></li></ul></li><li>实例：<ul><li>日本NEC公司2002年制造的Earth-Simulator超级计算机<ul><li>由5120个处理器构成</li><li>每秒能完成35亿次的浮点运算</li><li>它是世界上最快的计算机</li></ul></li></ul></li></ul><h4 id="2-微型化："><a href="#2-微型化：" class="headerlink" title="2.微型化："></a>2.微型化：</h4><ul><li>计算机向微型化、高性能、多用途方向发展</li><li>原因：<ul><li>微处理器芯片性能不断提高<ul><li>eg：奔腾4芯片主频已达到3GHz以上</li><li>目前微处理器芯片计算能力已经超过早期巨型机计算能力</li></ul></li><li>微型机所需的配套期间的性能也在不断提高<ul><li>如：<ul><li>主存芯片的集成度、读写速度和数据传输率</li><li>光盘、移动硬盘和硬盘的容量、速度和数据传输率</li><li>显示器的综合性能</li><li>各种多媒体和大量预装软件等</li></ul></li></ul></li></ul></li></ul><h4 id="3-网络化："><a href="#3-网络化：" class="headerlink" title="3.网络化："></a>3.网络化：</h4><ul><li>原因：<ul><li>Internet建立与信息高速公路崛起<ul><li>使人类社会处理和传播信息能力大大增强</li></ul></li><li>为适应网络化需要<ul><li>可移动式计算机及网络配套用的硬件与软件不断推出新产品<ul><li>eg：<ul><li>调制解调器，声卡</li><li>视频卡，电源等装置</li></ul></li></ul></li></ul></li></ul></li><li>将成为 信息时代和知识经济时代强大的助推器</li></ul><h4 id="4-智能化："><a href="#4-智能化：" class="headerlink" title="4.智能化："></a>4.智能化：</h4><ul><li><p>应用：</p><ul><li>计算机科学与控制论、仿生学、心理学等等相结合</li><li>用计算机模拟人类的某些智能行为<ul><li>如触觉、嗅觉、视觉等感觉功能</li><li>对声音、图像、图形及其他模式的识别能力</li><li>提供只是进行推理和自我学习的能力等等</li></ul></li></ul></li><li><p>优点：</p><ul><li><p>使计算机不但能储存、计算和处理数据</p></li><li><p>而且在模式识别、定理证明、学习研究、联想探索、语言理解等领域都成为人类助手</p></li></ul></li></ul><h4 id="计算机发展特点："><a href="#计算机发展特点：" class="headerlink" title="计算机发展特点："></a>计算机发展特点：</h4><ul><li><p>新型元器件、体系结构及实现技术的发展，将大大提高计算机系统性能及性能价格比</p><ul><li>eg：<ul><li>集成电路纳米极微细加工技术<ul><li>促使提高半导体各种芯片集成度、速度</li></ul></li><li>光电子器件与生物器件若产生<ul><li>将提高计算机运算速度</li></ul></li><li>计算机辅助技术及信息工艺技术应用<ul><li>将使计算机整体性能大幅提高</li></ul></li></ul></li></ul></li><li><p>计算机与通信技术融合与渗透，将加速人类社会信息化进程</p><ul><li>全球性计算机联网<ul><li>促进信息资源的开发与利用</li></ul></li><li>计算机成为人类生活必需品<ul><li>计算机科学与技术成为人类必须学习与具备基础知识</li></ul></li></ul></li><li><p>以智能化、集成化、自动化、并行化、开放化、自然化为标志的</p><ul><li>计算机软件新技术的而深入研究、开发与利用</li><li>不但将软件的功能与性能迅速提高</li><li>还将解决软件生产率低下的问题<ul><li>软件理论与软件工程发展<ul><li>将从理论与实践两方面解决计算机系统开发的软件瓶颈问题</li></ul></li><li>信息产业与软件产业将成为新的经济增长点<ul><li>成为国民经济的支柱产业</li></ul></li></ul></li></ul></li><li><p>在Internet与信息高速公路迅速发展普及形势下</p><ul><li>为保证信息资源共享</li><li>计算机系统与网络的互操作性、开放性、标准化将受到高度重视</li></ul></li><li><p>完全新型的计算机不断问世</p><ul><li>传统计算机：<ul><li>基本工作方式：<ul><li>是顺序执行指令的串行工作方式</li></ul></li><li>将导致传统计算机在并行处理、字符处理、知识处理等方面的低效能</li></ul></li><li>为突破传统的存储程序计算机结构的局限性<ul><li>人们研究开发了一些非传统计算机</li><li>例如：<ul><li>数据流计算机、归约机、</li><li>逻辑推理机、神经计算机等</li></ul></li></ul></li><li>为进一步提高计算机系统的性能<ul><li>研究开发不采用传统电子器件的计算机也是一个重要方向与课题</li><li>eg：<ul><li>光计算机</li><li>生物计算机</li><li>量子计算机</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 绿皮书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-10-可靠性测试</title>
      <link href="/posts/41234.html"/>
      <url>/posts/41234.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件可靠性定义"><a href="#软件可靠性定义" class="headerlink" title="软件可靠性定义"></a>软件可靠性定义</h2><ul><li>软件可靠性<ul><li>是软件系统在规定的时间内及规定的环境条件下</li><li>完成规定功能的能力</li></ul></li></ul><h2 id="软件可靠性三要素"><a href="#软件可靠性三要素" class="headerlink" title="软件可靠性三要素"></a>软件可靠性三要素</h2><ul><li>规定的时间</li><li>规定的运行环境条件</li><li>规定的功能</li></ul><h2 id="可靠性的度量"><a href="#可靠性的度量" class="headerlink" title="可靠性的度量"></a>可靠性的度量</h2><ul><li>可靠性的最常用的度量<ul><li>是平均无故障时间</li></ul></li><li>例如：<ul><li>通过压力测试</li><li>并借助<ul><li>软件失效模式</li><li>影响分析<ul><li>来获得有关可靠性数据</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.9 容错性测试</title>
      <link href="/posts/54896.html"/>
      <url>/posts/54896.html</url>
      
        <content type="html"><![CDATA[<h2 id="容错性测试的分类"><a href="#容错性测试的分类" class="headerlink" title="容错性测试的分类"></a>容错性测试的分类</h2><ul><li>负面测试</li><li>故障转移测试</li></ul><h2 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h2><ul><li><p>容错性测试就是</p><ul><li>在各种异常条件下对系统的功能进行测试</li><li>以检验系统是否具有防护性的举措或者某种灾难性恢复的手段或能力</li></ul></li><li><p>容错性可分为两个层次：</p><ul><li>功能层次的容错性测试<ul><li>也称 <strong>负面</strong> 测试<ul><li>negative test</li></ul></li><li>或 <strong>例外</strong> 测试<ul><li>exception test</li></ul></li></ul></li><li>系统层次的容错性测试<ul><li>主要是<ul><li>灾难恢复性测试</li><li>故障转移测试</li></ul></li></ul></li></ul></li></ul><h2 id="负面测试"><a href="#负面测试" class="headerlink" title="负面测试"></a>负面测试</h2><ul><li><p>负面测试</p><ul><li>是从<strong>逆向思维</strong>出发</li><li>检查系统在 <strong>异常条件</strong> 下或用户的 <strong>非法操作</strong> 下系统是如何 <strong>响应</strong> 的</li><li>是否有 <strong>异常行为</strong> 或执行了 <strong>不应该执行的动作</strong></li></ul></li><li><p>无效等价类的测试用例就是一种 <strong>负面的测试</strong></p></li><li><p>在一些 <strong>异常的</strong> 或 <strong>恶劣</strong>的条件下进行操作</p></li><li><p><strong>探索式</strong> 测试</p></li></ul><h2 id="故障转移机制"><a href="#故障转移机制" class="headerlink" title="故障转移机制"></a>故障转移机制</h2><p><img src="/posts/54896/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6.jpg" alt="故障转移机制"></p><h2 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h2><ul><li>故障转移测试<ul><li>就是验证 <strong>故障转移机制</strong> 能否 <strong>正常实现</strong>，满足事先的设计要求</li><li>是在 <strong>软件系统发生故障</strong> 的情况下<ul><li>去检验系统的恢复能力</li><li>验证系统已保存的用户数据是否丢失</li><li>系统和数据是否能尽快恢复或在指定时间内恢复</li><li>包括<ul><li>验证重新初始化</li><li>检查点</li><li>数据恢复</li><li>重新启动<ul><li>等机制的正确性</li></ul></li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美国文学绪论</title>
      <link href="/posts/28139.html"/>
      <url>/posts/28139.html</url>
      
        <content type="html"><![CDATA[<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ol><li>The Literature of Colonial America<ul><li>Puritan Thoughts</li></ul></li><li>The Literature of Reason and Revolution<ul><li>American Enlightenment</li><li>Benjamin Franklin: The Autobiography</li><li>Philip Freneau:The Wild Honey Suckle </li></ul></li><li>The Literature of Romanticism<ul><li>American Romanticism</li><li>Washington Irving: The Legend of Sleepy Hollow</li><li>William Cullen Bryant:To a Waterfowl</li><li>Edgar Allan Poe: To Helen; Annabel Lee;The Fall of the House of Usher</li><li>Transcendentalism</li><li>Henry David Thoreau:Walden</li><li>Nathaniel Hawthorne :The Scarlet Letter</li><li>Herman Melville:Moby Dick</li><li>Henry Wadsworth Longfellow:A Psalm of Life</li></ul></li><li>The Literature of Realism<ul><li>American Realism</li><li>free verse</li><li>Walt Whitman: Song of Myself</li><li>Emily Dickinson:I heard a Fly buzz—when I died</li><li>Mark Twain:The Adventures of Tom Sawyer</li><li>Henry James:The Portrait of a Lady</li><li>American Naturalism</li><li>Jack London:The Sea-Wolf,Martin Eden</li><li>Theodore Dreiser:Sister Carrie</li></ul></li><li>Twentieth-Century Literature<ul><li>Modernism</li><li>Imagism</li><li>Ezra Pound:In a Station of the Metro</li><li>Robert Frost:The Road Not Taken;Stopping by Woods on a Snowy Evening</li><li>Carl Sandburg:Chicago</li><li>F.Scott Fitzgerald:The Great Gatsby</li><li>Ernest Hemingway:A Farewell to Arms</li><li>John Steinbeck:The Grapes of Wrath</li><li>William Faulkner:A Rose for Emily</li></ul></li></ol><h2 id="The-Literature-of-Colonial-America"><a href="#The-Literature-of-Colonial-America" class="headerlink" title="The Literature of Colonial America"></a>The Literature of Colonial America</h2><h3 id="historical-introduction"><a href="#historical-introduction" class="headerlink" title="historical introduction"></a>historical introduction</h3><ul><li><p>The colonial period stretched roughly from the settlement of America in the early 17th century through the end of the 18th.</p><ul><li>The first permanent settlement in America was established by English in 1607.</li><li>(A group of people was sent by the English <strong>King James I</strong> to hunt for <strong>gold</strong>.They arrived at Virginia in 1607.They named the <strong>James River</strong> and bulid the <strong>James town</strong>.)</li></ul></li><li><p>The pre-revolutionary writing in the colonies was essentially of two kinds:   分为两类</p><ol><li>Practical matter-of-fact accounts of farming,hunting,travel,etc.designed to inform people “at home” what life was like in the new world,and,often,to induce their immigration</li><li>Highly theoretical,generally polemical,discussions of religious questions</li></ol></li></ul><h3 id="The-first-American-writer"><a href="#The-first-American-writer" class="headerlink" title="The first American writer"></a>The first American writer</h3><ul><li><p>The first writings that we call American were the narratives and journals of these settlements.They wrote about their voyage to the new land,their lives in the new land,their dealings with indians.</p></li><li><p>Captain John Smith is the first American writer.</p></li><li><p>A true Relation of such Occurrences and Accidents of Note as Hath Happened in verginia since the First Planting of That Colony.(1608)</p></li><li><p>A Map of virginia: A Description of the Country(1612)</p></li><li><p>General History of Virginia(1624):the Indian princess Pocahontas.</p></li><li><p><strong>Captain John Smith</strong></p><ul><li>was one of the first early 17th century British settlers in North America.</li><li>One of the things he wrote about that has become an American legend was his capture by the Indians and his rescue by the famous Indian Princess,Pocahontas.</li><li>宝嘉康蒂</li></ul></li></ul><h3 id="Puritan-Thoughts-（重点）"><a href="#Puritan-Thoughts-（重点）" class="headerlink" title="Puritan Thoughts   （重点）"></a>Puritan Thoughts   （重点）</h3><ul><li>the origin of puritan<ul><li>in the mediaeval Europe,there was widespread religious revolution.In the 16th Century,the English King Henry VIII(At that time)，the Catholics were not allowed to divorce unless they have the Pope’s permission.</li><li>Henry VIII wanted to divorce his wife because she couldn‘t bear him a son.But the pope didn’t allow him    to divorce,so he broke away the roman catholics Church&amp;established the Church of England.</li><li>But there was no radical difference between the doctrines of the Church of England and the Catholic Church.A group of people thought the church of England was too Catholic and wanted to purify the church.</li><li>Then came the name Puritans.</li></ul></li></ul><ul><li>Puritanism is the practises and beliefs on the Puritans.<ul><li>The puritans were originally members of a division of the Protestant Church,who came into existence in the reigns of Queen Elizabeth and King James I.</li><li>The first settlers who became the founding fathers of the American nation were quite a few of them Puritans.</li><li>They came to America out of various reasons,but it should be remembered that they were a group of serious,religious people,advocating highly religious and moral principles.As the word itself hints,Puritans wanted to purify their religous beliefs and practices.They felt that the Church of England was too close to the Church of Rome in doctrine from worship,and organization of authority.</li></ul></li></ul><p>主要教义 predestination</p><ol><li>God’s elect<ul><li>Puritans believed they are predestined before they were born.</li><li>Nothing or no good work can change their fate.</li><li>They believed the success of one’s business is the sign to show he is the God‘s elect.So the Puritans works very hard,spend very little and invest more for the future business.They lived a very frugal life.This is their ethics.</li></ul></li><li>Original sin and total depravity<ul><li>Man is born sinful.This determines some puritans pessimistic attitude towards life.</li></ul></li><li>Limited atonement(the salvation of a selected few)</li><li>theocracy  政教合一<ul><li>They combined state with religion.Their government is at least not a liberal one</li><li>The puritans established American tradition–intolerant moralism.They strictly punished drunks,adultery&amp;heretics</li><li>Puritans changed gradually due to the severity of frontier environment.</li></ul></li></ol><h4 id="影响Influence"><a href="#影响Influence" class="headerlink" title="影响Influence"></a>影响Influence</h4><ol><li>its optimism<ul><li>American literature was from the outset conditioned by the Puritan heritage.It can be said American literature is based on the Biblical myth.After Adam and Eve were driven out of the Garden of Eden,man have on illusion to restore the paradise.The puritans,after arriving at America,believing that God must have sent them to this new land to restore the lost paradise,to build the wildness into a new Garden of Eden.Fired with such a strong sense of mission,they treated life with a tremendous amount of optimism.The optimistic Puritans has exerted a great influence on American literature.</li></ul></li><li>Puritan’s metaphorical mode of perception changed gradually into a literary symbolism.</li></ol><h3 id="American-Dream"><a href="#American-Dream" class="headerlink" title="American Dream"></a>American Dream</h3><ul><li><p>The <strong>American</strong> <strong>Dream</strong> is a national ethos of the United States,a set of ideals in which freedom includes….</p></li><li><p>The idea of the American Dream is rooted in the United States Declaration of Independence which proclaims that”all men are created equal” and that they are “endowed by their Creator with certain inalienable Rights”including “life,Liberty and the pursuit of Happiness.”</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美国文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.8 安全性测试</title>
      <link href="/posts/41073.html"/>
      <url>/posts/41073.html</url>
      
        <content type="html"><![CDATA[<h2 id="安全性测试定义"><a href="#安全性测试定义" class="headerlink" title="安全性测试定义"></a>安全性测试定义</h2><h3 id="软件安全性测试就是"><a href="#软件安全性测试就是" class="headerlink" title="软件安全性测试就是"></a>软件安全性测试就是</h3><ul><li>检验系统权限设置有效性</li><li>防范违法入侵的能力</li><li>数据备份和恢复能力等</li><li>设法找出各种安全性漏洞</li></ul><h3 id="漏洞举例："><a href="#漏洞举例：" class="headerlink" title="漏洞举例："></a>漏洞举例：</h3><ul><li>跨站点脚本(cross-site scripting , XSS)攻击</li><li>SQL注入式漏洞</li><li>缓冲区溢出</li><li>不安全的数据存储或传递</li><li>不安全的配置管理</li><li>有问题的访问控制、权限分配有问题</li><li>口令设置不严、包括长度、构成和更新频</li><li>暴露的端口或入口</li></ul><h2 id="安全性测试的范围"><a href="#安全性测试的范围" class="headerlink" title="安全性测试的范围"></a>安全性测试的范围</h2><ul><li>系统级别的安全性</li><li>应用程序级别的安全性（important）<ul><li>用户权限</li><li>数据输入验证</li><li>敏感数据加密</li><li>数据存储安全性</li><li>用户口令</li><li>验证系统的日志文件是否得到保护</li></ul></li></ul><h2 id="web安全性测试"><a href="#web安全性测试" class="headerlink" title="web安全性测试"></a>web安全性测试</h2><ul><li>跨站脚本攻击</li><li>SQL注入式攻击</li><li>URL和API的身份验证</li><li>其他</li></ul><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><ul><li>在页面某些输入域中使用跨站脚本（写入一段javascript）来发送恶意代码给没有发觉的用户，让浏览器执行document.write等危险指令<ul><li>窃取用户的资料或者信息</li></ul></li></ul><h2 id="输入域验证"><a href="#输入域验证" class="headerlink" title="输入域验证"></a>输入域验证</h2><ul><li>防止<ul><li>HTML标签：&lt;…&gt;…&lt;/…&gt;</li><li>转义字符：&amp;amp(&amp;);&amp;lt(&lt;);&amp;gt(&lt;);&amp;nbsp(空格)</li><li>脚本语言，如javascript <script language="javascript">......</script></li><li>特殊字符： ‘ ‘ &lt;&gt; /</li></ul></li><li>最好进行更严格的保护和验证</li></ul><h2 id="SQL注入式攻击"><a href="#SQL注入式攻击" class="headerlink" title="SQL注入式攻击"></a>SQL注入式攻击</h2><ul><li>根据SQL语句的编写规则，附加一个永远为”真”的条件<ul><li>使系统中的某个认证条件总是成立</li><li>从而欺骗系统、躲过认证</li><li>进而侵入系统</li></ul></li></ul><h2 id="安全性测试工具的评估标准"><a href="#安全性测试工具的评估标准" class="headerlink" title="安全性测试工具的评估标准"></a>安全性测试工具的评估标准</h2><ul><li>支持常见的web服务器平台</li><li>能同时提供对源代码和二进制文件进行扫描的功能</li><li>漏洞检测和纠正分析</li><li>检测实时系统的问题</li><li>不改变被测试的软件，不影响代码</li><li>良好的报告</li><li>非安全专业认识也易于上手</li><li>可管理部署的多种扫描器、尽可能小的错误误差等</li></ul><h2 id="常见的安全性测试工具"><a href="#常见的安全性测试工具" class="headerlink" title="常见的安全性测试工具"></a>常见的安全性测试工具</h2><p><img src="/posts/41073/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.jpg" alt="安全性测试工具"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7 兼容性测试</title>
      <link href="/posts/14844.html"/>
      <url>/posts/14844.html</url>
      
        <content type="html"><![CDATA[<h2 id="兼容性测试的定义"><a href="#兼容性测试的定义" class="headerlink" title="兼容性测试的定义"></a>兼容性测试的定义</h2><p>兼容性测试</p><ul><li>是在 <strong>不同软硬件环境</strong> 下，验证软件系统能否正常地运行</li><li>这些软硬件一般有但不限于以下种类：<ul><li>硬件 hardware</li><li>操作系统 </li><li>数据库 </li><li>浏览器 </li><li>第三方系统</li><li>内部业务系统</li><li>自身系统的不同版本的用户数据</li></ul></li></ul><h2 id="兼容性测试的内容"><a href="#兼容性测试的内容" class="headerlink" title="兼容性测试的内容"></a>兼容性测试的内容</h2><ul><li>硬件兼容性的测试</li><li>数据兼容性的测试</li><li>系统版本之间的兼容性</li></ul><ul><li>向后兼容：<ul><li>指新发布的软件版本可以使用该软件的以前版本所产生的数据</li></ul></li><li>向前兼容：<ul><li>指在设计和开发一个新版本时，考虑如何和未来版本的数据兼容</li></ul></li></ul><h2 id="系统兼容性测试"><a href="#系统兼容性测试" class="headerlink" title="系统兼容性测试"></a>系统兼容性测试</h2><ul><li>B/S系统兼容性测试（考虑兼容哪个浏览器）</li><li>C/S系统兼容性测试（考虑兼容哪个客户端）</li></ul><h2 id="数据兼容性测试"><a href="#数据兼容性测试" class="headerlink" title="数据兼容性测试"></a>数据兼容性测试</h2><ul><li>是否遵守统一的国际标准、国家标准或业界认可的事实标准等</li><li>提供相应的导入、导出功能</li><li>剪贴板或ODBC等类似方法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 性能测试工具</title>
      <link href="/posts/30377.html"/>
      <url>/posts/30377.html</url>
      
        <content type="html"><![CDATA[<h1 id="特性及其使用"><a href="#特性及其使用" class="headerlink" title="特性及其使用"></a>特性及其使用</h1><ul><li>能模拟实际用户的 <strong>操作行为</strong>，<ul><li><strong>记录和回放</strong> <strong>多用户</strong> 测试中的 <strong>事务处理过程</strong></li><li><strong>自动生成</strong>相应的 <strong>测试脚本</strong></li></ul></li><li>能针对 <strong>脚本</strong> 进行修改<ul><li>增加 <strong>逻辑控制</strong></li><li>完成 <strong>参数化</strong> 和 <strong>数据关联</strong></li></ul></li><li>可以设置不同的 <strong>应用环境和场景</strong>，通过 <strong>虚拟用户</strong> 执行相应的测试脚本</li><li>通过 <strong>系统监控工具</strong> 获得系统性能的相关指标的值</li></ul><h1 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h1><h2 id="nGrinder"><a href="#nGrinder" class="headerlink" title="nGrinder"></a>nGrinder</h2><ul><li>是一个基于Grinder 开发的、易于管理和使用的、分布式性能测试系统</li></ul><h2 id="Flood"><a href="#Flood" class="headerlink" title="Flood"></a>Flood</h2><ul><li>是人们经常使用的一个Web性能测试工具</li></ul><h2 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h2><ul><li>是一个开源的web压力测试和评测系统</li></ul><h2 id="openSTA"><a href="#openSTA" class="headerlink" title="openSTA"></a>openSTA</h2><ul><li>可以模拟大量的虚拟用户来完成性能测试</li><li>并通过script来完成丰富的自定义设置</li></ul><h2 id="DBMonster"><a href="#DBMonster" class="headerlink" title="DBMonster"></a>DBMonster</h2><ul><li>是一个生成随机数据</li><li>用来测试SQL数据库的压力测试工具</li></ul><h2 id="LoadSim"><a href="#LoadSim" class="headerlink" title="LoadSim"></a>LoadSim</h2><ul><li>网络应用程序的负载模拟器</li></ul><h1 id="商业工具"><a href="#商业工具" class="headerlink" title="商业工具"></a>商业工具</h1><ul><li>HP LoadRunner</li><li>IBM Rational performance Tester</li><li>Radview webload</li><li>compuware QA Load</li><li>Quest Benchmark Factory</li><li>微软WAS (web access stress test)</li><li>Paessler Webserver Stress Tool</li><li>MINQ PureLoad</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 压力测试</title>
      <link href="/posts/27406.html"/>
      <url>/posts/27406.html</url>
      
        <content type="html"><![CDATA[<h1 id="压力测试的定义"><a href="#压力测试的定义" class="headerlink" title="压力测试的定义"></a>压力测试的定义</h1><ul><li>是在系统（eg：CPU、内存、网络带宽等）处于 <strong>饱和</strong> 状态下</li><li>测试系统<ul><li>是否还具有正常的 <strong>会话</strong> 能力、<strong>数据处理</strong> 能力</li><li>或 是否会 <strong>出现错误</strong></li></ul></li><li>以检查软件系统对 <strong>异常情况的抵抗</strong> 能力</li><li>找出 <strong>性能瓶颈</strong>、<strong>功能不稳定性</strong> 等问题</li></ul><h1 id="压力测试的类型"><a href="#压力测试的类型" class="headerlink" title="压力测试的类型"></a>压力测试的类型</h1><h2 id="稳定性压力测试"><a href="#稳定性压力测试" class="headerlink" title="稳定性压力测试"></a>稳定性压力测试</h2><ul><li>高负载下持续运行24小时以上的压力测试</li></ul><h2 id="破坏性压力测试"><a href="#破坏性压力测试" class="headerlink" title="破坏性压力测试"></a>破坏性压力测试</h2><ul><li>通过不断加载的手段</li><li>快速总成系统的崩溃</li><li>让问题尽快地暴露出来</li></ul><h2 id="渗入测试"><a href="#渗入测试" class="headerlink" title="渗入测试"></a>渗入测试</h2><ul><li><p><strong>soak</strong> <strong>test</strong></p></li><li><p>通过长时间运行</p></li><li><p>使问题逐渐渗透出来</p></li><li><p>从而发现</p><ul><li><p>内存泄漏</p></li><li><p>垃圾收集 <strong>GC</strong></p></li><li><p>或系统的其他问题</p><p>以检验系统的 <strong>健壮性</strong></p></li></ul></li></ul><h2 id="峰谷测试"><a href="#峰谷测试" class="headerlink" title="峰谷测试"></a>峰谷测试</h2><ul><li><strong>peak-rest test</strong></li><li>采用 <strong>高低突变加载方式</strong> 进行<ul><li>先加载到 <strong>高水平</strong> 的负载</li><li>然后 <strong>急剧降低</strong> 负载</li><li><strong>稍微平息</strong> 一段时间</li><li>再加载到 <strong>高水平</strong> 的负载</li></ul></li><li><strong>重复</strong> 这样的过程</li><li>容易发现问题的 <strong>蛛丝马迹</strong></li><li>最终找到问题的 <strong>根源</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 性能测试</title>
      <link href="/posts/11040.html"/>
      <url>/posts/11040.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何确定性能需求"><a href="#如何确定性能需求" class="headerlink" title="如何确定性能需求"></a>如何确定性能需求</h1><h2 id="性能指标预期来源"><a href="#性能指标预期来源" class="headerlink" title="性能指标预期来源"></a>性能指标预期来源</h2><ol><li><strong>最终用户的体验</strong>      eg:2-5-10原则</li><li><strong>商业需求</strong>        eg：”比竞争对手的产品好”</li><li><strong>技术需求</strong>        eg：”cpu使用率不超过70%”</li><li><strong>标准要求</strong></li></ol><h2 id="包含下列性能指标："><a href="#包含下列性能指标：" class="headerlink" title="包含下列性能指标："></a>包含下列性能指标：</h2><ol><li><strong>时间</strong> time<ul><li>响应时间</li><li>页面下载时间等等</li></ul></li><li><strong>容量</strong> capacity<ul><li>正常工作能承受的最大负载</li><li>eg：<ul><li>最大并发用户数</li><li>最大数据容量</li><li>最大在线用户数</li></ul></li></ul></li><li><strong>吞吐量</strong> throughput<ul><li>eg：<ul><li>每秒请求数RPS</li><li>每秒点击数HPS</li><li>每秒事务数TPS</li><li>每秒接受或发送的数据量等</li></ul></li></ul></li><li><strong>系统资源利用率</strong> utilization<ul><li>eg：<ul><li>cpu</li><li>memory<ul><li>使用率</li></ul></li><li>等等</li></ul></li></ul></li></ol><h2 id="不同角色对于性能指标关注什么"><a href="#不同角色对于性能指标关注什么" class="headerlink" title="不同角色对于性能指标关注什么"></a>不同角色对于性能指标关注什么</h2><h3 id="用户："><a href="#用户：" class="headerlink" title="用户："></a>用户：</h3><ul><li>响应时间</li></ul><h3 id="产品市场团队"><a href="#产品市场团队" class="headerlink" title="产品市场团队"></a>产品市场团队</h3><ul><li>容量</li><li>数据吞吐量</li></ul><h3 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h3><ul><li>系统资源占用率</li></ul><h1 id="性能测试类型"><a href="#性能测试类型" class="headerlink" title="性能测试类型"></a>性能测试类型</h1><h2 id="性能验证测试"><a href="#性能验证测试" class="headerlink" title="性能验证测试"></a>性能验证测试</h2><ul><li>验证事先已定义的系统性能指标、系统能否满足系统的性能需求</li></ul><h2 id="性能基准测试"><a href="#性能基准测试" class="headerlink" title="性能基准测试"></a>性能基准测试</h2><ul><li>在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线</li></ul><h2 id="性能规划测试"><a href="#性能规划测试" class="headerlink" title="性能规划测试"></a>性能规划测试</h2><ul><li>在多种 <strong>特定</strong> 的环境下，获得 <strong>不同配置</strong> 的系统的 <strong>性能指标</strong> ，从而决定在系统部署时采用什么样的 <strong>软</strong>、<strong>硬件配置</strong></li></ul><h2 id="容量测试"><a href="#容量测试" class="headerlink" title="容量测试"></a>容量测试</h2><ul><li>可以看作是 <strong>性能</strong> 的测试的一种</li><li>因为系统的容量可以看作 <strong>系统性能指标</strong> 之一</li></ul><h1 id="性能测试步骤"><a href="#性能测试步骤" class="headerlink" title="性能测试步骤"></a>性能测试步骤</h1><ol><li>确定性能测试 <strong>需求</strong></li><li><strong>计划和设计测试</strong> ；包括确定关键业务流程、测试类型和测试方法，选择合适的测试工具、设计测试场景等等</li><li><strong>测试工具</strong> 的选择</li><li>配置 <strong>测试环境</strong>、尽量接近实际运行环境、即建立仿真环境作为性能测试环境，测试结果才能可信</li><li>实现 <strong>测试设计</strong>（开发测试脚本）</li><li><strong>执行测试</strong></li><li><strong>分析</strong> 测试结果</li><li>重复4-6步骤，直至 <strong>测试计划完成</strong> ，结果 <strong>满意</strong></li><li>提交 <strong>性能测试报告</strong></li></ol><h1 id="一些常见的性能问题"><a href="#一些常见的性能问题" class="headerlink" title="一些常见的性能问题"></a>一些常见的性能问题</h1><ul><li><strong>资源泄漏</strong>，包括内存泄漏</li><li><strong>资源瓶颈</strong>，内部资源（线程、放入池的对象）变得稀疏</li><li>cpu使用率达到<strong>100</strong>%、系统 <strong>被锁定</strong> （eg：鼠标键盘不响应）等等</li><li>线程 <strong>死锁</strong>、线程 <strong>阻塞</strong> 等等</li><li><strong>数据库连接</strong> 成为性能瓶颈（数据库连接时间过长）</li><li>查询 <strong>速度慢</strong> 或 列表 <strong>效率低</strong>（eg:没用上索引）</li><li>受 <strong>外部系统影响</strong> 越来越大</li></ul><h1 id="容量测试-1"><a href="#容量测试-1" class="headerlink" title="容量测试"></a>容量测试</h1><h2 id="容量测试的定义"><a href="#容量测试的定义" class="headerlink" title="容量测试的定义"></a>容量测试的定义</h2><ul><li><p><strong>capacity</strong> test</p></li><li><p>通过负载测试或其它测试方法，预先分析出反应软件系统应用特征的某项指标的极限值（eg：最大并发用户数、数据库记录数等等）</p></li><li><p>在其极限值状态下系统主要功能还能保持正常运行</p></li></ul><h2 id="与其他测试的关系"><a href="#与其他测试的关系" class="headerlink" title="与其他测试的关系"></a>与其他测试的关系</h2><ul><li>属于性能测试的一种</li></ul><h2 id="采用的方法"><a href="#采用的方法" class="headerlink" title="采用的方法"></a>采用的方法</h2><ul><li>一般采用 逐步加载 的负载测试方法</li><li>也可以<ul><li>先采用 <strong>逐步加载</strong> 的方式</li><li>获得一个 基本的 <strong>容量值或容量范围</strong></li><li>再考虑用 <strong>一次性加载方式</strong></li><li>来决定 <strong>实际可支持</strong> 的 <strong>容量值</strong></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 负载测试技术</title>
      <link href="/posts/19168.html"/>
      <url>/posts/19168.html</url>
      
        <content type="html"><![CDATA[<h1 id="pre：演示一个使用JMETER的例子"><a href="#pre：演示一个使用JMETER的例子" class="headerlink" title="pre：演示一个使用JMETER的例子"></a>pre：演示一个使用JMETER的例子</h1><h2 id="背景要求："><a href="#背景要求：" class="headerlink" title="背景要求："></a>背景要求：</h2><p>当120个用户同时访问ecshop,其中所有的用户会访问首页并搜索商品</p><p>要求平均响应时间&lt;=2000ms,并且cpu的利用率&lt;=75%</p><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>先启动xapp，把apache和mysql打开</p><p><img src="/posts/19168/Xapp.png" alt="Xapp"></p><p>jmeter启动测试计划 <code>pre7.3</code></p><p><img src="/posts/19168/jmeter.png" alt="jmeter"></p><ul><li><code>User</code> <code>Defined</code> <code>Variable</code><ul><li>用户定义变量</li></ul></li><li><code>HTTP Request Defaults</code><ul><li>HTTP请求的默认值</li></ul></li><li><code>HTTP Cookie Manager</code><ul><li>http cookie管理器</li></ul></li><li><code>Thread Group</code><ul><li>线程</li><li>模仿用户给服务器发请求</li><li>![thread group](7-3-负载测试技术/thread group.png)<ul><li><code>number of threads</code>:<ul><li>线程数</li></ul></li><li><code>ramp-up preriod</code><ul><li>执行完这些线程所用的时间 （秒数）</li></ul></li><li><code>loop</code> <code>count</code><ul><li>循环次数</li><li>infinite:无限循环</li></ul></li></ul></li></ul></li></ul><p><img src="/posts/19168/%E9%87%87%E6%A0%B7%E5%99%A8.png" alt="采样器"></p><p><code>uniform random timer</code></p><p><img src="/posts/19168/%E5%AE%9A%E6%97%B6%E5%99%A8.png" alt="定时器"></p><ul><li>采样器 就是发请求出去</li><li>有请求发出去，则自然要有监听器</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 负载测试 压力测试 性能测试</title>
      <link href="/posts/60505.html"/>
      <url>/posts/60505.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景及其分析"><a href="#背景及其分析" class="headerlink" title="背景及其分析"></a>背景及其分析</h1><h2 id="性能调优："><a href="#性能调优：" class="headerlink" title="性能调优："></a>性能调优：</h2><ul><li>指系统性能改善是<ul><li>测试</li><li>调整</li><li>再测试</li><li>再调整</li><li>…<ul><li>一个持续改进的过程</li></ul></li></ul></li><li>需要借助负载测试方法</li></ul><h2 id="负载测试-load-test"><a href="#负载测试-load-test" class="headerlink" title="负载测试 load test"></a>负载测试 load test</h2><ul><li>可看成是 <strong>性能测试</strong> 采用的一种技术</li></ul><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>可看作 <strong>负载测试</strong> 的一种</li><li>即  <strong>高负载</strong> 下的 <strong>负载测试</strong></li></ul><h2 id="容量测试-capacity-test"><a href="#容量测试-capacity-test" class="headerlink" title="容量测试 capacity test"></a>容量测试 capacity test</h2><ul><li>用 <strong>负载测试</strong> 技术来实现</li><li><strong>压力测试</strong> 可附带做 <strong>容量测试</strong></li></ul><h2 id="负载测试与性能测试相似性"><a href="#负载测试与性能测试相似性" class="headerlink" title="负载测试与性能测试相似性"></a>负载测试与性能测试相似性</h2><ul><li>测试方法接近</li><li>都关注系统性能</li><li>多数情况下用相同测试工具</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="负载测试-load-rest"><a href="#负载测试-load-rest" class="headerlink" title="负载测试 load rest"></a>负载测试 load rest</h2><ul><li>通过模拟实际软件系统所承受的<ul><li>负载条件</li><li>改变系统负载大小</li><li>负载方式<ul><li>来发现系统中所存在的问题</li></ul></li></ul></li><li>负载大小可以是<ul><li>并发请求的数量(RPS 每秒请求数)</li><li>并发用户数量</li><li>数据库大小</li><li>收发数据大小</li><li>等等</li></ul></li></ul><h2 id="压力测试-1"><a href="#压力测试-1" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>是在 <strong>强负载</strong> 情况下稳定性进行测试</li><li>查看应用系统在 <strong>峰值</strong>（瞬间使用高峰）使用情况下的行为表现</li><li>更有效地发现系统 <strong>稳定性的隐患</strong> 和系统在负载峰值的条件下 <strong>功能隐患</strong> 等</li><li>确认系统是否具有良好的 <strong>容错</strong> 能力和 <strong>可恢复</strong> 能力</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>是为了 <strong>获取</strong> 或 <strong>验证</strong> 系统性能指标</li><li>或为了发现 <strong>性能瓶颈</strong> 而进行的测试</li></ul><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><h2 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>测试被测系统是否满足 <strong>预期性能目标</strong></li></ul><h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><ul><li>测试被测试系统</li><li>在 <strong>服务器安全范围</strong> 内的 <strong>最大负载值</strong></li></ul><h2 id="压力测试-2"><a href="#压力测试-2" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>测试被测试系统</li><li>在 <strong>超过服务器安全范围</strong> 所能承受的 <strong>最大压力值</strong></li></ul><h2 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h2><ul><li>测试被测系统在 <strong>长时间的压力</strong> 下的 <strong>稳定性</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程基础知识简介</title>
      <link href="/posts/18088.html"/>
      <url>/posts/18088.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h2><ul><li>包括：<ul><li>需求分析</li><li>系统设计</li><li>系统实现</li><li>测试</li><li>发布</li><li>运行和维护</li><li>升级</li><li>淘汰</li></ul></li></ul><h2 id="软件主要的测试工作"><a href="#软件主要的测试工作" class="headerlink" title="软件主要的测试工作"></a>软件主要的测试工作</h2><ul><li>随着 <strong>系统实现阶段</strong> 的展开而开始</li><li>一直持续到 <strong>产品发布</strong> 之后</li></ul><h2 id="软件的质量保证活动QA"><a href="#软件的质量保证活动QA" class="headerlink" title="软件的质量保证活动QA"></a>软件的质量保证活动QA</h2><ul><li>伴随着软件整个生命周期</li><li>原因：<ul><li>为了度量、跟踪、控制软件产品的质量</li></ul></li></ul><h1 id="2-软件开发流程简述"><a href="#2-软件开发流程简述" class="headerlink" title="2 软件开发流程简述"></a>2 软件开发流程简述</h1><h2 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h2><h3 id="需求分析的定义"><a href="#需求分析的定义" class="headerlink" title="需求分析的定义"></a>需求分析的定义</h3><ul><li>是开发人员经过深入细致的调研和分析，准确理解用户和项目的<ul><li>功能</li><li>性能</li><li>可靠性<ul><li>等具体要求</li></ul></li></ul></li><li>将用户 <strong>非形式的需求</strong> 转化为 <strong>完整的需求定义</strong> </li><li>从而确定系统 <strong>必须做什么</strong> 的过程</li></ul><h3 id="需求分析中需明白的几个概念"><a href="#需求分析中需明白的几个概念" class="headerlink" title="需求分析中需明白的几个概念"></a>需求分析中需明白的几个概念</h3><h4 id="业务需求："><a href="#业务需求：" class="headerlink" title="业务需求："></a>业务需求：</h4><ul><li>是由高层领导提出的业务上要满足的需求</li><li>目的：<ul><li>解决业务通电</li></ul></li><li>通常比较宏观</li></ul><h4 id="用户需求："><a href="#用户需求：" class="headerlink" title="用户需求："></a>用户需求：</h4><ul><li>使用户从自身角度出发，自己所认为的需求</li><li>也可以看作将业务需求具体化之后的需求</li></ul><h4 id="产品需求："><a href="#产品需求：" class="headerlink" title="产品需求："></a>产品需求：</h4><ul><li>是通过分析提炼得到的用户的真实需求</li><li>且符合产品定位的解决方案</li><li>一般来说，产品需求等同于系统需求</li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="系统设计的定义："><a href="#系统设计的定义：" class="headerlink" title="系统设计的定义："></a>系统设计的定义：</h3><ul><li>是根据需求分析的结果</li><li>是对软件的技术实现由粗到细进行设计的过程</li></ul><h3 id="系统设计的两个阶段："><a href="#系统设计的两个阶段：" class="headerlink" title="系统设计的两个阶段："></a>系统设计的两个阶段：</h3><ul><li>概要设计</li><li>详细设计</li></ul><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><h4 id="概要设计的任务："><a href="#概要设计的任务：" class="headerlink" title="概要设计的任务："></a>概要设计的任务：</h4><ul><li>根据系统需求分析得到的系统用例转换为软件结构和数据结构</li></ul><h4 id="概要设计的内容："><a href="#概要设计的内容：" class="headerlink" title="概要设计的内容："></a>概要设计的内容：</h4><ul><li>系统技术架构设计</li><li>功能模块划分和功能设计</li><li>数据库设计</li><li>接口设计</li><li>界面设计</li></ul><h3 id="详细设计："><a href="#详细设计：" class="headerlink" title="详细设计："></a>详细设计：</h3><h4 id="详细设计的定义："><a href="#详细设计的定义：" class="headerlink" title="详细设计的定义："></a>详细设计的定义：</h4><ul><li>对概要设计的细化</li></ul><h4 id="详细设计的内容："><a href="#详细设计的内容：" class="headerlink" title="详细设计的内容："></a>详细设计的内容：</h4><ul><li>算法设计</li><li>函数流程设计</li><li>等等</li></ul><h2 id="2-3-系统实现"><a href="#2-3-系统实现" class="headerlink" title="2.3 系统实现"></a>2.3 系统实现</h2><h3 id="系统实现的定义："><a href="#系统实现的定义：" class="headerlink" title="系统实现的定义："></a>系统实现的定义：</h3><ul><li>即编码</li><li>根据系统设计来进行实际的编码工作</li><li>并得到可以运行的软件产品</li></ul><h2 id="2-4-系统测试"><a href="#2-4-系统测试" class="headerlink" title="2.4 系统测试"></a>2.4 系统测试</h2><h3 id="系统测试的定义："><a href="#系统测试的定义：" class="headerlink" title="系统测试的定义："></a>系统测试的定义：</h3><ul><li>对源代码或可以运行的程序进行检查或执行</li><li>判断被测系统事都存在与需求中的预期不一致的地方</li><li>并加以记录的过程</li></ul><h2 id="2-5-产品发布和运维"><a href="#2-5-产品发布和运维" class="headerlink" title="2.5 产品发布和运维"></a>2.5 产品发布和运维</h2><p>原因：</p><ul><li>软件发布后，可能会产生问题：<ul><li>用户对产品不熟悉造成使用问题</li><li>开发测试不彻底遗留缺陷</li></ul></li></ul><p>因此：</p><ul><li>要对产品运行<ul><li>进行维护</li><li>进行用户培训</li><li>修复缺陷</li><li>等等</li></ul></li></ul><h2 id="2-6-产品升级"><a href="#2-6-产品升级" class="headerlink" title="2.6 产品升级"></a>2.6 产品升级</h2><p>原因：</p><ul><li>随着用户使用的深入</li><li>软件产品可能无法继续使用用户要求</li></ul><p>因此需要：</p><ul><li>对产品进行升级</li><li>增加新的功能和特性</li><li>优化产品性能</li><li>等等</li></ul><h2 id="2-7-产品淘汰"><a href="#2-7-产品淘汰" class="headerlink" title="2.7 产品淘汰"></a>2.7 产品淘汰</h2><p>原因：</p><ul><li>随着技术不断发展，软件产品可能无法适应业务发展</li></ul><p>因此：</p><ul><li>不得不将产品彻底报废、淘汰</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 质量保证与测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 认识软件测试管理</title>
      <link href="/posts/40593.html"/>
      <url>/posts/40593.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-软件质量与测试"><a href="#1-1-软件质量与测试" class="headerlink" title="1.1 软件质量与测试"></a>1.1 软件质量与测试</h2><h3 id="软件质量的概念"><a href="#软件质量的概念" class="headerlink" title="软件质量的概念"></a>软件质量的概念</h3><ul><li>软件质量越来越受到重视</li><li>ANSI/IEEE&lt;软件工程术语的IEEE标准术语表&gt;定义软件质量为<ul><li>“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”</li></ul></li></ul><h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><ul><li><p>软件产品各种质量特性的组合称为软件质量模型</p></li><li><p>常见的软件质量模型</p><ul><li>Boehm模型 1976年</li><li>MCCALL模型 1978年</li><li>ISO9126软件质量模型 1993年</li></ul></li></ul><h3 id="Boehm质量模型"><a href="#Boehm质量模型" class="headerlink" title="Boehm质量模型"></a>Boehm质量模型</h3><ul><li>1976年由Boehm等提出的分层方案</li><li>将软件的质量定义为分层的模型</li></ul><h4 id="boehm质量模型内容"><a href="#boehm质量模型内容" class="headerlink" title="boehm质量模型内容"></a>boehm质量模型内容</h4><ul><li><strong>可维护性</strong><ul><li><strong>可修改性</strong><ul><li><strong>可扩充性</strong></li><li><strong>结构化性</strong></li></ul></li><li><strong>可理解性</strong><ul><li><strong>清晰性</strong></li><li><strong>简单性</strong></li><li><strong>结构化性</strong></li><li><strong>自描述性</strong> 不需要其他培训 软件上的说明足以指引完成使用</li></ul></li><li><strong>可测试性</strong><ul><li><strong>结构化性</strong></li><li><strong>自描述性</strong></li><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>可测试性</strong></li></ul></li></ul></li><li><strong>可用性</strong><ul><li><strong>人类工程</strong><ul><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>健壮性</strong></li></ul></li><li><strong>效率</strong><ul><li><strong>可存取性</strong></li><li><strong>设备效率</strong></li><li><strong>可测试性</strong></li></ul></li><li><strong>可靠性</strong><ul><li><strong>一致性</strong></li><li><strong>健壮性</strong></li><li><strong>完备性</strong></li><li><strong>正确性</strong></li><li><strong>自包含性</strong></li></ul></li></ul></li><li><strong>可移植性</strong><ul><li><strong>自包含性</strong></li><li><strong>设备独立性</strong></li></ul></li></ul><h3 id="MCCALL质量模型"><a href="#MCCALL质量模型" class="headerlink" title="MCCALL质量模型"></a>MCCALL质量模型</h3><ul><li>1979年由McCall等人提出的软件质量模型</li><li>将软件质量的概念建立在11个质量特性之上</li><li>这些质量特性分别是面向软件产品的运行、修正和转移的</li></ul><h3 id="ISO9126质量模型"><a href="#ISO9126质量模型" class="headerlink" title="ISO9126质量模型"></a>ISO9126质量模型</h3><ul><li>软件质量模型可以分为：<ul><li>内部质量和外部质量模型、<ul><li>功能性</li><li>可靠性</li><li>易用性</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li>使用质量模型<ul><li>有效性</li><li>生产性</li><li>安全性</li><li>满意度</li></ul></li></ul></li></ul><h3 id="常见的软件质量特性"><a href="#常见的软件质量特性" class="headerlink" title="常见的软件质量特性"></a>常见的软件质量特性</h3><ol><li>性能Performance<ol><li>系统的响应能力</li><li>即 要经过多长时间才能对某个时间做出响应</li><li>或者在某段时间内系统所能处理的事件个数</li></ol></li><li>可用性Availability<ol><li>系统能正常运行的时间比例</li></ol></li><li>可靠性Rvailability<ol><li>系统在应用或错误面前，在意外或者错误使用的情况下维持软件系统功能特性的能力</li></ol></li><li>健壮性Robustness<ol><li>在处理或者环境中系统能够承受的压力或者变更能力</li></ol></li><li>安全性Security<ol><li>系统向合法用户提供服务的同时能够阻止非授权用户使用企图或拒绝服务的能力</li></ol></li></ol><h3 id="软件质量保证的手段"><a href="#软件质量保证的手段" class="headerlink" title="软件质量保证的手段"></a>软件质量保证的手段</h3><ul><li>软件测试</li><li>软件研发过程保证</li><li>软件研发配置管理</li><li>…</li></ul><h3 id="软件测试-vs-软件质量"><a href="#软件测试-vs-软件质量" class="headerlink" title="软件测试 vs 软件质量"></a>软件测试 vs 软件质量</h3><ul><li>软件测试是保证软件质量的重要手段之一</li><li>软件测试是有计划有组织的活动</li><li>软件测试管理确保测试活动的顺利开展</li></ul><h2 id="1-2-软件测试管理概述"><a href="#1-2-软件测试管理概述" class="headerlink" title="1.2 软件测试管理概述"></a>1.2 软件测试管理概述</h2><h3 id="项目与项目管理"><a href="#项目与项目管理" class="headerlink" title="项目与项目管理"></a>项目与项目管理</h3><ul><li>项目：<ul><li>一系列复杂的并相互关联的活动</li><li>有着一个明确的目标</li><li>必须在特定的时间、预算、资源限定内，依据规范完成</li></ul></li><li>项目管理：<ul><li>在项目活动中运用专门的知识、技能、工具或方法</li><li>使项目能够在有限资源限定条件下，实现预定的目标</li></ul></li><li>范畴：<ul><li>范围管理</li><li>时间管理</li><li>费用管理</li><li>质量管理</li><li>人力资源管理</li><li>风险管理</li><li>沟通管理</li><li>采购与合同管理</li></ul></li></ul><h3 id="软件测试管理-vs-软件项目管理"><a href="#软件测试管理-vs-软件项目管理" class="headerlink" title="软件测试管理 vs 软件项目管理"></a>软件测试管理 vs 软件项目管理</h3><ul><li>软件测试管理是忒数的软件项目管理<ul><li>与软件项目管理密切相关，有时从属于软件项目管理的一部分</li><li>可以借用软件项目管理的办法</li><li>因任务特点有自身特殊的知识、流程、方法、工具</li></ul></li></ul><h3 id="软件测试管理的要素"><a href="#软件测试管理的要素" class="headerlink" title="软件测试管理的要素"></a>软件测试管理的要素</h3><ul><li>测试过程与测试资产管理<ul><li>建立并维护测试的过程</li><li>建立并维护测试过程中建立的指南、模板、评审单等</li><li>管理测试工作相关的资产</li></ul></li><li>测试需求管理<ul><li>收集需求</li><li>分析需求</li><li>测试需求跟踪</li></ul></li><li>测试计划管理<ul><li>制定计划</li><li>执行计划</li><li>监控计划</li></ul></li><li>测试缺陷管理<ul><li>报告测试缺陷</li><li>回归测试发现的缺陷</li><li>缺陷分析</li></ul></li><li>测试工具管理<ul><li>选择测试工具</li><li>维护测试工具</li></ul></li><li>测试团队管理<ul><li>建立并维护测试团队</li><li>团队日常管理</li><li>团队绩效管理</li></ul></li></ul><h2 id="1-3-软件测试管理工具"><a href="#1-3-软件测试管理工具" class="headerlink" title="1.3 软件测试管理工具"></a>1.3 软件测试管理工具</h2><h3 id="软件测试工具"><a href="#软件测试工具" class="headerlink" title="软件测试工具"></a>软件测试工具</h3><ul><li>自动化测试工具<ul><li>单元测试工具</li><li>性能测试工具</li><li>功能测试工具</li><li>…</li></ul></li><li>软件测试管理工具<ul><li>ALM</li><li>BUGzilla：<a href="https://www.bugzilla.org/" target="_blank" rel="noopener">https://www.bugzilla.org/</a></li><li>Jira</li><li>禅道：<a href="https://www.zentao.net/" target="_blank" rel="noopener">https://www.zentao.net/</a></li><li>…</li></ul></li></ul><h3 id="软件测试管理工具的分类"><a href="#软件测试管理工具的分类" class="headerlink" title="软件测试管理工具的分类"></a>软件测试管理工具的分类</h3><ul><li>专项测试管理工具<ul><li>只管理软件测试中的某项内容<ul><li>如缺陷管理工具、</li><li>用例管理工具</li></ul></li><li>如BUGzilla是缺陷管理工具</li></ul></li><li>专门测试管理工具<ul><li>对测试的整个流程进行管理</li><li>如IBM Rational Quality Manager</li><li>HP ALM(Application lifecycle Management)等</li></ul></li><li>覆盖开发和测试的项目管理工具<ul><li>覆盖整个研发周期的项目管理工具</li><li>特别适用于研发测试齐全的产品研发团队</li><li>如：禅道项目管理软件</li></ul></li><li>其他<ul><li>借助办公软件和文档管理软件完成测试管理</li><li>办公软件:Office Project\Word\Excel</li><li>文档管理软件：如TortoiseSVN\TortoiseHg</li></ul></li></ul><h3 id="软件测试管理工具的选择"><a href="#软件测试管理工具的选择" class="headerlink" title="软件测试管理工具的选择"></a>软件测试管理工具的选择</h3><ul><li><p>选择测试管理工具应该综合考虑</p><ul><li>项目大小</li><li>团队规模</li><li>团队结构</li><li>成本预算</li></ul></li><li><p>工具是一个载体，</p><ul><li><p>可以提高工作效率，减少错误发生</p></li><li><p>更重要的是，利用知识和规范的流程完成项目，从而灵活运用工具</p></li></ul></li></ul><table><thead><tr><th>团队种类</th><th>建议选择</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td>小规模初创团队（如创业项目、学生项目等）</td><td>专项管理的开源工具或办公软件</td><td>节省成本、简单易用</td><td>Bugzilla      jira免费版 Office、Wps   文档管理软件TortoiseSVN  各种在线缺陷管理工具</td></tr><tr><td>第三方测试团队（专门提供测试服务的机构）</td><td>专门的测试管理工具</td><td>对测试全流程进行管理</td><td>IBM Rational Quality Manager       Hp ALM (Application Lifecycle Management)</td></tr><tr><td>产品研发团队（包括开发和测试人员）</td><td>软件项目管理工具</td><td>对软件开发进行全流程管理</td><td>有非常多的此类商业软件、不再举例，也有很多公司用的是自己研发的产品</td></tr></tbody></table><h3 id="软件测试管理工具的功能"><a href="#软件测试管理工具的功能" class="headerlink" title="软件测试管理工具的功能"></a>软件测试管理工具的功能</h3><ul><li>用户及权限管理</li><li>测试项目的创建</li><li>测试项目需求管理</li><li>测试任务分配和实施</li><li>测试项目缺陷管理</li><li>测试数据收集</li><li>测试项目数据分析统计和报告生成</li><li>测试项目用例管理</li><li>测试执行管理</li><li>测试文档管理</li></ul><h3 id="软件测试管理工具的发展趋势"><a href="#软件测试管理工具的发展趋势" class="headerlink" title="软件测试管理工具的发展趋势"></a>软件测试管理工具的发展趋势</h3><ul><li>与其他软件自动化测试工具集成<ul><li>如可以直接启动各种自动化测试</li></ul></li><li>与软件研发的其他环节集成越来越紧密<ul><li>如代码审查、产品版本管理等</li></ul></li><li>基于云的测试管理工具<ul><li>比如QASymphony开发的QTest是基于云计算的测试管理工具</li></ul></li></ul><h3 id="HP-ALM-测试管理工具简介"><a href="#HP-ALM-测试管理工具简介" class="headerlink" title="HP ALM 测试管理工具简介"></a>HP ALM 测试管理工具简介</h3><h4 id="ALM简介"><a href="#ALM简介" class="headerlink" title="ALM简介"></a>ALM简介</h4><ul><li>HP公司的软件测试管理工具</li><li>HP Application Lifecycle Management（ALM）<ul><li>可提供用于组织和跟踪应用程序版本的系统</li><li>帮助定义并维护需求及测试的库</li></ul></li><li>ALM具有缺陷跟踪系统<ul><li>能够从初始检测开始监控缺陷</li><li>直到问题解决</li></ul></li><li>ALM可以<ul><li>生成演示业务性能各个方面的叫糊涂</li><li>或使用任何截面数据定义报告</li><li>还可以通过在单个视图中并排排列多个图监控多个业务指标</li></ul></li></ul><h4 id="应用ALM优势"><a href="#应用ALM优势" class="headerlink" title="应用ALM优势"></a>应用ALM优势</h4><ul><li>加强开发人员、测试人员和业务分析师之间的协作</li><li>支持构建多级要求、任务、测试、缺陷、源代码和报告</li><li>任务管理有助于提高开发人员和测试人员的工作效率</li><li>同时支持瀑布式和敏捷式方法</li><li>与常见的开放源、商业开发管理解决方案完美集成</li></ul><h4 id="ALM功能"><a href="#ALM功能" class="headerlink" title="ALM功能"></a>ALM功能</h4><ul><li>版本规范</li><li>需求规范</li><li>测试计划</li><li>测试执行</li><li>缺陷跟踪</li></ul><h4 id="ALM服务器站点管理页面"><a href="#ALM服务器站点管理页面" class="headerlink" title="ALM服务器站点管理页面"></a>ALM服务器站点管理页面</h4><p><img src="/posts/40593/%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9.PNG" alt="1"></p><h4 id="ALM客户端登录界面"><a href="#ALM客户端登录界面" class="headerlink" title="ALM客户端登录界面"></a>ALM客户端登录界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.PNG" alt="登录界面"></p><p>登录时除了登录名和密码，还要选择登录的项目</p><p>每次只能登录一个固定的项目</p><h4 id="ALM客户端登陆后的界面"><a href="#ALM客户端登陆后的界面" class="headerlink" title="ALM客户端登陆后的界面"></a>ALM客户端登陆后的界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E5%90%8E%E7%95%8C%E9%9D%A2.PNG" alt="登陆后界面"></p><h4 id="ALM客户端-需求管理"><a href="#ALM客户端-需求管理" class="headerlink" title="ALM客户端-需求管理"></a>ALM客户端-需求管理</h4><p>可以创建需求</p><p>右下角为创建好的需求</p><h4 id="ALM客户端-用例管理"><a href="#ALM客户端-用例管理" class="headerlink" title="ALM客户端-用例管理"></a>ALM客户端-用例管理</h4><p>![用例管理](D:/github blog/ischelsea.github.io/source/_posts/第一章-认识软件测试管理/用例管理.PNG)</p><p>ALM客户端的用例管理称为测试计划</p><p>可以以树的形式来展现，也可以以列表的形式</p><p>可以对应到用例、可以对应到需求</p><p>每个用例有详细信息、设计步骤、参数、测试配置、附件等属性</p><h4 id="ALM客户端-测试实验室（执行管理）"><a href="#ALM客户端-测试实验室（执行管理）" class="headerlink" title="ALM客户端-测试实验室（执行管理）"></a>ALM客户端-测试实验室（执行管理）</h4><p><img src="/posts/40593/%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86.PNG" alt="执行管理"></p><p>实际上就是建立一些测试的集合</p><p>然后去执行这个测试集</p><p>测试集里会包含一群测试用例</p><p>之后可以执行并记录测试用例的执行结果，进行一些分析</p><h4 id="ALM客户端-缺陷管理"><a href="#ALM客户端-缺陷管理" class="headerlink" title="ALM客户端-缺陷管理"></a>ALM客户端-缺陷管理</h4><p><img src="/posts/40593/%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86.PNG" alt="缺陷管理"></p><p>因为缺陷有很多字段</p><p>所以缺陷建立后可以以列表的形式进行查看</p><p>缺陷可以向前关联到相应的测试用例</p><ul><li>缺陷的字段可以自己定义<ul><li>比如说缺陷的功能模块</li><li>每个产品的缺陷功能模块都是不同的</li><li>我们可以在客户端通过项目的自定义来定义缺陷的一些字段</li></ul></li></ul><p>综上</p><p>也就是说，ALM可以实现从需求、到用例、到缺陷的关联</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 软件测试过程管理</title>
      <link href="/posts/5418.html"/>
      <url>/posts/5418.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件研发中的测试"><a href="#2-1-软件研发中的测试" class="headerlink" title="2.1 软件研发中的测试"></a>2.1 软件研发中的测试</h2><h3 id="1-软件研发中的测试活动"><a href="#1-软件研发中的测试活动" class="headerlink" title="1 软件研发中的测试活动"></a>1 软件研发中的测试活动</h3><h4 id="软件测试与软件研发"><a href="#软件测试与软件研发" class="headerlink" title="软件测试与软件研发"></a>软件测试与软件研发</h4><ul><li>软件测试和软件开发一样，都遵循软件工程的原理</li><li>测试是软件研发的一部分，测试和开发时密切相关的</li><li>测试活动是贯穿于软件项目开发的全过程的，和开发活动交互开展</li></ul><h4 id="软件研发生命周期的瀑布模型"><a href="#软件研发生命周期的瀑布模型" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h4><p><img src="/posts/5418/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><h4 id="尽早测试，越晚发现问题成本越高"><a href="#尽早测试，越晚发现问题成本越高" class="headerlink" title="尽早测试，越晚发现问题成本越高"></a>尽早测试，越晚发现问题成本越高</h4><p><img src="/posts/5418/%E5%8F%98%E5%8C%96.png" alt="变化"></p><h4 id="软件研发中的测试环节与测试活动"><a href="#软件研发中的测试环节与测试活动" class="headerlink" title="软件研发中的测试环节与测试活动"></a>软件研发中的测试环节与测试活动</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8.png" alt="测试活动"></p><h4 id="研发中的测试活动：软件需求评审及i系统测试方案制定"><a href="#研发中的测试活动：软件需求评审及i系统测试方案制定" class="headerlink" title="研发中的测试活动：软件需求评审及i系统测试方案制定"></a>研发中的测试活动：软件需求评审及i系统测试方案制定</h4><ol><li><p>软件需求完成后，需要进行需求的评审，此时测试人员可以：</p><ul><li>参与需求的评审</li><li>需求确定后进行系统测试方案及计划的制订</li></ul></li><li><p>软件总体设计完成后，进行总体设计方案评审，此时测试人员可以：</p><ul><li>参与总体设计方案的评审</li><li>开始进行集成测试方案的制定</li></ul></li><li><p>详细设计完成后，测试人员：</p><ul><li>参与详细设计的评审</li><li>开始进行模块测试方案的制定</li></ul></li><li><p>单元测试和编码一般是同步的，由开发人员自己完成的</p></li><li><p>整个模块开发完成后，测试人员开始进行模块测试，在这之前所有的模块测试用例应当已经准备完毕</p></li><li><p>模块测试后是执行集成测试和系统测试</p></li><li><p>软件运行维护期间则要对运行期间发现的问题进行记录和回归测试</p></li></ol><h3 id="2-按照开发阶段对软件测试分类"><a href="#2-按照开发阶段对软件测试分类" class="headerlink" title="2 按照开发阶段对软件测试分类"></a>2 按照开发阶段对软件测试分类</h3><ul><li><p>按照开发阶段划分，软件测试分为：</p><ul><li><p>单元测试</p></li><li><p>集成测试</p></li><li><p>系统测试</p></li><li><p>确认测试</p></li><li><p>验收测试</p></li></ul></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>单元测试又称为模块测试<ul><li>是针对软件设计的最小单位-程序模块进行正确性验证的测试工作</li></ul></li><li>检查程序单元是否满足详细设计说明中的：<ul><li>模块功能</li><li>性能</li><li>接口和设计约束</li><li>发现模块内部错误</li></ul></li><li>白盒和黑盒都会用到</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>集成测试<ul><li>也叫组装测试</li><li>或者联合测试</li></ul></li><li>每个单元正确<ul><li>组装起来不一定能正确工作</li><li>所以要开展集成测试</li></ul></li><li>主要检测单元的接口关系<ul><li>集成为符合概要设计要求的更大的组件</li></ul></li></ul><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><ul><li>检测软件是否满足软件需求说明书中规定的要求</li></ul><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>将同股集成测试的软件<ul><li>作为整个基于计算机系统的一个元素</li><li>与计算机硬件，外设，某些支持软件、数据和人员等其他元素结合在一起</li><li>在实际或模拟环境下进行测试</li></ul></li><li>目的是：<ul><li>通过与系统的需求定义作比较</li><li>发现与系统定义不一致的地方</li></ul></li></ul><h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul><li>按照项目任务书或合同的验收依据对整个系统进行测试与评审</li><li>决定是否接受系统</li></ul><h2 id="2-2-软件测试模型"><a href="#2-2-软件测试模型" class="headerlink" title="2.2 软件测试模型"></a>2.2 软件测试模型</h2><ul><li><h3 id="软件测试模型背景："><a href="#软件测试模型背景：" class="headerlink" title="软件测试模型背景："></a>软件测试模型背景：</h3><ul><li>测试与开发密切相关，通过实践产生了许多测试模型</li><li>这些模型将测试活动进行了抽象<ul><li>明确了测试与开发之间的关系</li><li>是测试管理的重要参考依据</li></ul></li></ul></li></ul><ul><li><h3 id="常见的软件测试模型"><a href="#常见的软件测试模型" class="headerlink" title="常见的软件测试模型"></a>常见的软件测试模型</h3><ul><li>V模型</li><li>W模型</li><li>H模型</li><li>X模型</li><li>前置测试模型</li></ul></li></ul><ul><li><h3 id="软件研发生命周期的瀑布模型-1"><a href="#软件研发生命周期的瀑布模型-1" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h3><ul><li>计划时期：<ul><li>问题定义</li><li>可行性研究</li></ul></li><li>开发时期：<ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>测试</li></ul></li><li>运行时期：<ul><li>运行与维护</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：V模型"><a href="#软件测试模型：V模型" class="headerlink" title="软件测试模型：V模型"></a>软件测试模型：V模型</h3><ul><li>来源：<ul><li>软件开发的瀑布模型</li></ul></li><li>特点：<ul><li>说明了基本的开发过程和测试行为</li><li>明确地标识了测试过程中存在的不同级别以及测试阶段和开发各阶段的关系</li></ul></li><li>局限性：<ul><li>测试对象只有程序代码</li><li>测试作为编码后的活动，未体现“尽早测试”的原则</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：W模型"><a href="#软件测试模型：W模型" class="headerlink" title="软件测试模型：W模型"></a>软件测试模型：W模型</h3><ul><li>演化来源：<ul><li>V模型</li></ul></li><li>与V模型区别：<ul><li>增加了与软件开发阶段同步进行的测试</li></ul></li><li>强调：<ul><li>测试伴随整个软件开发周期</li><li>测试对象不仅是程序，需求、功能和设计同样要测试</li><li>测试与开发同步进行，有利于尽早发现问题</li></ul></li><li>局限性：<ul><li>W与V模型<ul><li>均把软件开发视为需求、设计、编码等一系列串行的活动</li><li>无法支持迭代以及变更调整</li></ul></li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：H模型"><a href="#软件测试模型：H模型" class="headerlink" title="软件测试模型：H模型"></a>软件测试模型：H模型</h3><ul><li>强调：<ul><li>测试活动<ul><li>独立</li><li>贯穿于整个产品周期</li><li>与研发流程并发</li></ul></li><li>循环：<ul><li>测试点准备就绪即可执行测试</li></ul></li><li>测试<ul><li>可尽早进行</li><li>可对被测对象分层次、反复测试</li></ul></li></ul></li><li>某一次测试过程：<ul><li>测试准备</li><li>测试就绪点</li><li>其他流程</li><li>测试执行</li><li>测试流程</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：其他测试模型"><a href="#软件测试模型：其他测试模型" class="headerlink" title="软件测试模型：其他测试模型"></a>软件测试模型：其他测试模型</h3><ul><li>X测试模型:<ul><li>特点：<ul><li>认为”学院派的V模型“不能处理开发的实际时间过程</li><li>比如：<ul><li>频繁重复的集成</li><li>需求文档的缺乏</li></ul></li></ul></li><li>内容：<ul><li>针对单独程序片段所进行的相互分离的编码和测试</li><li>此后进行贫乏明年的交接</li><li>通过集成最终成为可执行的程序</li><li>然后再对这些可执行程序进行测试</li></ul></li></ul></li><li>前置测试模型：<ul><li>测试与开发紧密结合</li><li>对每个交付内容进行测试<ul><li>eg：<ul><li>设计文档</li><li>可行性报告</li></ul></li></ul></li><li>交付内容一旦完成，立即进行测试</li></ul></li></ul></li></ul><ul><li><h3 id="测试模型的使用："><a href="#测试模型的使用：" class="headerlink" title="测试模型的使用："></a>测试模型的使用：</h3><ul><li>模型对工作开展有重要意义<ul><li>但每个模型都不是完美的</li></ul></li><li>灵活运用各个模型的优点<ul><li>还要考虑项目的实际情况</li></ul></li></ul></li></ul><h2 id="2-3-软件测试的流程"><a href="#2-3-软件测试的流程" class="headerlink" title="2.3 软件测试的流程"></a>2.3 软件测试的流程</h2><h3 id="1-软件测试的流程"><a href="#1-软件测试的流程" class="headerlink" title="1.软件测试的流程"></a>1.软件测试的流程</h3><h4 id="测试流程内容："><a href="#测试流程内容：" class="headerlink" title="测试流程内容："></a>测试流程内容：</h4><ul><li>测试过程定义了<ul><li>企业在产品开发过程中在<ul><li>设计</li><li>开发与实现</li><li>维护</li><li>退出</li></ul></li><li>等阶段 与测试相关活动的<ul><li>内容</li><li>流程</li><li>规范</li></ul></li></ul></li><li>测试过程指导：<ul><li>项目如何开展各项测试活动</li><li>以及各项活动的输入输出</li></ul></li><li>测试过程<ul><li>约定活动中所设计的角色与职责</li><li>规范各个活动的内容和章程<ul><li>以及所使用到的统一的<ul><li>模版</li><li>表单</li><li>指导书</li><li>检查单</li></ul></li></ul></li></ul></li></ul><h4 id="测试流程的作用"><a href="#测试流程的作用" class="headerlink" title="测试流程的作用"></a>测试流程的作用</h4><ul><li>给公司在产品开发过程中测试相关的活动<ul><li>提供指导</li><li>确保产品可以真正满足用户要求</li></ul></li></ul><h4 id="测试与开发关系"><a href="#测试与开发关系" class="headerlink" title="测试与开发关系"></a>测试与开发关系</h4><ul><li>软件项目中测试与开发相互配合、同步推进<ul><li>软件项目的复杂性被测对象往往不断变化</li><li>实际项目中测试与开发的关系更加复杂</li></ul></li><li>虽然测试与开发关系复杂，但测试工作的开展有自己的过程要遵循</li><li>对单次测试来说，存在一个一般性的过程</li></ul><h4 id="软件测试一般性过程"><a href="#软件测试一般性过程" class="headerlink" title="软件测试一般性过程"></a>软件测试一般性过程</h4><ol><li>需求分析阶段<ul><li>收集相关资料</li><li>学习业务（测试对象）</li><li>分析测试需求点</li></ul></li><li>测试计划阶段：<ul><li>测试主管<ul><li>组织编写《测试计划》</li><li>该文档指明<ul><li>测试范围</li><li>方法</li><li>资源</li><li>相应测试活动人员时间进度安排</li></ul></li></ul></li><li>测试计划<ul><li>需要进行评审</li><li>测试计划一旦开始执行<ul><li>就要定期监控计划的执行情况</li></ul></li></ul></li></ul></li><li>测试设计与开发<ul><li>测试设计<ul><li>一般由对需求熟悉的资深测试工程师设计</li><li>为每个测试点设计出包括<ul><li>需求点简介</li><li>测试思路</li><li>详细测试方法</li></ul></li><li>三部分的方法</li></ul></li><li>测试开发主要完成：<ul><li>测试用例编写</li><li>测试数据准备</li><li>测试环境准备</li></ul></li><li>测试设计与测试用例完成后需要进行评审</li></ul></li><li>测试执行及报告<ul><li>执行测试用例</li><li>及时提交<ul><li>有质量的bug</li><li>测试阶段报告<ul><li>反馈测试情况</li></ul></li></ul></li></ul></li><li>软件评估报告及批准<ul><li>根据测试结果给出<ul><li>对软件的整体评估</li><li>是否通过测的建议</li></ul></li><li>一般决策部门<ul><li>会根据这份评估报告决定产品是否可以发布vy</li></ul></li></ul></li><li>测试总结及资产归档<ul><li>结项阶段<ul><li>对整个过程进行回顾总结</li><li>将项目相关资源进行整理归档</li></ul></li></ul></li></ol><h3 id="2-软件测试流程的建立和维护"><a href="#2-软件测试流程的建立和维护" class="headerlink" title="2 软件测试流程的建立和维护"></a>2 软件测试流程的建立和维护</h3><h4 id="创建软件测试流程注意事项"><a href="#创建软件测试流程注意事项" class="headerlink" title="创建软件测试流程注意事项"></a>创建软件测试流程注意事项</h4><ul><li>从实际情况出发<ul><li>优化流程</li><li>解决问题u</li></ul></li><li>重点考虑四个问题：<ul><li>哪些测试要做</li><li>谁做</li><li>什么时间做</li><li>如何做</li></ul></li></ul><h4 id="创建测试流程步骤"><a href="#创建测试流程步骤" class="headerlink" title="创建测试流程步骤"></a>创建测试流程步骤</h4><ul><li>对当前存在的问题进行收集、诊断分析</li><li>根据实际情况建立新的流程</li><li>流程发布和试运行</li><li>促进流程的执行、收集问题</li><li>流程更新和发布</li></ul><h4 id="测试执行-VS-测试过程执行"><a href="#测试执行-VS-测试过程执行" class="headerlink" title="测试执行 VS 测试过程执行"></a>测试执行 VS 测试过程执行</h4><ul><li>测试执行<ul><li>按照测试计划去执行测试活动</li></ul></li><li>测试过程执行<ul><li>是严格按照测试的过程去开展测试活动</li></ul></li></ul><h4 id="测试流程不是静止的"><a href="#测试流程不是静止的" class="headerlink" title="测试流程不是静止的"></a>测试流程不是静止的</h4><ul><li>测试过程创建后不是一成不变</li><li>而是根据实际实践情况不断改进和完善</li><li>进行修订后要及时进行过程发布</li></ul><h4 id="促进测试过程的执行"><a href="#促进测试过程的执行" class="headerlink" title="促进测试过程的执行"></a>促进测试过程的执行</h4><ul><li>一般在测试过程执行中<ul><li>要设置一定的机制</li><li>去保证测试人员按照测试过程开展测试活动</li></ul></li><li>促进测试的执行<ul><li>QA人员对项目的监督和指导</li><li>组织级审计</li></ul></li></ul><h4 id="测试流程的改进"><a href="#测试流程的改进" class="headerlink" title="测试流程的改进"></a>测试流程的改进</h4><ul><li>测试流程<ul><li>在每一轮执行完毕后</li><li>根据所执行情况对流程进行更新和完善</li><li>用好的实践去更新完善流程</li></ul></li></ul><h4 id="测试过程中涉及的文档等资产"><a href="#测试过程中涉及的文档等资产" class="headerlink" title="测试过程中涉及的文档等资产"></a>测试过程中涉及的文档等资产</h4><ul><li>测试计划文档</li><li>测试方案文档</li><li>测试用例</li><li>测试报告</li><li>测试缺陷库</li><li>其他<ul><li>新开发或引入的测试工具</li><li>测试工作会议记录<ul><li>测试计划</li><li>测试方案</li><li>测试用例<ul><li>的评审报告</li></ul></li></ul></li><li>测试总结</li><li>测试原始数据以及度量数据</li><li>测试日志<ul><li>每天测试日程记录</li></ul></li><li>周期性测试报告</li><li>任务报告：<ul><li>任务完成情况报告</li></ul></li></ul></li></ul><h4 id="测试方案文档"><a href="#测试方案文档" class="headerlink" title="测试方案文档"></a>测试方案文档</h4><ul><li>描述<ul><li>为完成软件特性的测试而采用的测试方法的细节</li></ul></li><li>主要内容：<ul><li>概述</li><li>被测对象</li><li>应测试的特性</li><li>不被测试的特性</li><li>测试模型</li><li>测试需求</li><li>测试设计</li></ul></li></ul><h4 id="测试用例文档"><a href="#测试用例文档" class="headerlink" title="测试用例文档"></a>测试用例文档</h4><ul><li>测试用例表描述测试用例<ul><li>测试项目</li><li>用例编号</li><li>用例级别：测试用例重要程度</li><li>用例可用性</li><li>输入值</li><li>预期输出</li><li>实测结果</li><li>特殊环境需求（可选）</li><li>特殊测试步骤（可选）</li></ul></li></ul><h4 id="测试报告文档"><a href="#测试报告文档" class="headerlink" title="测试报告文档"></a>测试报告文档</h4><ul><li>描述测试结果的文档</li><li>主要内容：<ul><li>概述</li><li>测试时间、地点、人员</li><li>测试环境</li><li>测试结果统计分析</li><li>测试评估</li><li>测试总结与改进</li><li>测试缺陷列表</li></ul></li></ul><h4 id="测试缺陷："><a href="#测试缺陷：" class="headerlink" title="测试缺陷："></a>测试缺陷：</h4><ul><li>描述测试缺陷</li><li>主要内容：<ul><li>缺陷简述</li><li>缺陷描述</li><li>缺陷级别</li><li>缺陷分析与对策</li></ul></li></ul><h3 id="企业测试流程样例"><a href="#企业测试流程样例" class="headerlink" title="企业测试流程样例"></a>企业测试流程样例</h3><h4 id="某企业测试过程样例-概览"><a href="#某企业测试过程样例-概览" class="headerlink" title="某企业测试过程样例-概览"></a>某企业测试过程样例-概览</h4><p><img src="/posts/5418/%E6%A6%82%E8%A7%88.PNG" alt="概览"></p><h4 id="测试过程描述"><a href="#测试过程描述" class="headerlink" title="测试过程描述"></a>测试过程描述</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0.PNG" alt="测试过程描述"></p><h4 id="活动流程定义"><a href="#活动流程定义" class="headerlink" title="活动流程定义"></a>活动流程定义</h4><p><img src="/posts/5418/%E6%B4%BB%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89.PNG" alt="活动流程定义"></p><h4 id="测试相关的文档模版"><a href="#测试相关的文档模版" class="headerlink" title="测试相关的文档模版"></a>测试相关的文档模版</h4><p><img src="/posts/5418/%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF.PNG" alt="文档模版"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1-非功能性的系统测试需求</title>
      <link href="/posts/14723.html"/>
      <url>/posts/14723.html</url>
      
        <content type="html"><![CDATA[<h2 id="典型的遇到的问题"><a href="#典型的遇到的问题" class="headerlink" title="典型的遇到的问题"></a>典型的遇到的问题</h2><ol><li>系统性能问题</li><li>软件系统安全性受到挑战</li></ol><h2 id="什么是系统非功能性测试？"><a href="#什么是系统非功能性测试？" class="headerlink" title="什么是系统非功能性测试？"></a>什么是系统非功能性测试？</h2><ul><li><p>用户的需求</p><ul><li>分类：<ul><li>功能性需求</li><li>非功能性需求</li></ul></li></ul></li><li><p>非功能性需求：</p><ul><li>被归纳为：<ul><li>软件产品的各种质量特性</li><li>eg：<ul><li>安全性</li><li>兼容性</li><li>可靠性</li></ul></li></ul></li></ul></li><li><p>系统非功能性测试：</p><ul><li>针对于以上非功能特性展开</li><li>验证软件产品符合这些质量特性的要求<ul><li>从而满足用户和软件企业自身的非功能性需求</li></ul></li></ul></li><li><p>系统测试</p><ul><li>分类：<ul><li>负载测试</li><li>性能测试</li><li>容量测试</li><li>安全性测试</li><li>兼容性测试</li><li>可靠性测试</li></ul></li></ul></li></ul><h2 id="系统非功能特性"><a href="#系统非功能特性" class="headerlink" title="系统非功能特性"></a>系统非功能特性</h2><ul><li><p><strong>性能</strong></p><ul><li>指按用户负载条件对<ul><li>响应时间</li><li>吞吐量<ul><li>所做的度量<ul><li>（度量指的是一些指标进行计算后的统计结果）</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>可用性</strong>：</p><ul><li>指对<ul><li>系统资源</li><li>服务<ul><li>可供最终用户使用的程度度量</li></ul></li></ul></li><li>通常以系统的正常运行时间来表示</li></ul></li><li><p><strong>可伸缩性</strong>：</p><ul><li>指随时间推移为部署系统增加容量和用户的能力</li><li>通常涉及向系统添加资源</li><li>但不应要求对部署体系结构进行更改</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>指对系统及用户的完整性进行说明的复杂因素组合</li><li>包括<ul><li>用户的验证和授权</li><li>数据的安全</li><li>对已部署系统的安全访问</li></ul></li></ul></li><li><p><strong>潜在容量</strong>：</p><ul><li>指在不增加资源的情况下，系统处理异常峰值负载的能力</li><li>潜在容量是<ul><li>可用性</li><li>性能</li><li>可伸缩性<ul><li>特性中的一个因素</li></ul></li></ul></li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>指对已部署系统进行维护的难易度</li><li>其中包括：<ul><li>监视系统</li><li>修复出现的故障</li><li>升级硬件和软件组件</li></ul></li></ul></li></ul><h2 id="系统非功能性测试的内容"><a href="#系统非功能性测试的内容" class="headerlink" title="系统非功能性测试的内容"></a>系统非功能性测试的内容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter录制脚本</title>
      <link href="/posts/3679.html"/>
      <url>/posts/3679.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>file</code>目录中选择 templates..</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC1.png" alt="1"></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC2.png" alt="2"></p><p><code>select</code> <code>template</code>   中选择  <code>recording</code>  （在要做接口测试时）</p><p>如果要做性能测试，可以选择<code>recording with think time</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC3.png" alt="3"></p><p>选完后，<code>create</code> 确认</p><p>更改 <code>hostToRecord</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC4.png" alt="4"></p><p>因为是要测试自己的网站，而这个网站是部署在自己电脑上的，所以此处<code>hostToRecord</code>更改为<code>127.00.1</code></p><p><code>https</code> 改为 <code>http</code></p><p>再次选择 <code>create</code> 创建</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC5.png" alt="5"></p><ul><li><p>知识点：LogicController：</p><ul><li>用来控制TestPlan的执行，如循环、分支等，或者更简单一点，就是为了分组</li></ul></li><li><p>Thread Group下的Recording controller即是用于分组</p></li><li><p>view resultsTree：看执行结果</p></li><li><p>HTTP(S) Test Script Recorder:</p><ul><li>用于代理（浏览器请求需要通过这个代理再到网站，网站返回的相应也要通过这个代理，所以他要把这个请求给记下来）</li></ul></li></ul><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC6.png" alt="6"></p><p><code>port</code> 端口为8888，因为电脑上没有与这个冲突的，所以不用改</p><p>下面的 <code>Target Controller</code> 是指的存放所录制脚本的地方</p><p> <code>grouping</code>：一秒钟以内的请求</p><p>点击上面的 <code>start</code></p><p>再打开浏览器，打开设置栏，选择管理证书</p><p><img src="/posts/3679/7.png" alt="7"></p><p>选择证书颁发机构，选择导入</p><p><img src="/posts/3679/8.png" alt="8"></p><p>打开jmeter下的bin目录的apachejmetertemporaryrootca</p><p>后面一直点下一步、确定之类的即可</p><p>直到导入成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo s</code></p><p>图片引用：<img src="/posts/16107/%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="你想输入的替代文字"></p><p>emoji-》     ：smile：（冒号两边无空格）</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
