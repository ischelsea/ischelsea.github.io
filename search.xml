<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>王道-计组-第一章</title>
      <link href="/posts/37002.html"/>
      <url>/posts/37002.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><p>知识框架:</p><ul><li>1.1 计算机发展历程<ul><li>硬件的发展</li><li>软件的发展</li><li>计算机分类与发展方向</li></ul></li><li>1.2 计算机系统层次结构<ul><li>计算机系统的组成</li><li>计算机硬件的组成</li><li>计算机软件的分类</li><li>计算机工作过程</li><li>计算机系统的多级层次结构</li></ul></li><li>1.3 计算机性能指标<ul><li>计算机的主要性能指标</li><li>几个专业术语</li></ul></li></ul><h2 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h2><h3 id="1-1-1-计算机硬件的发展"><a href="#1-1-1-计算机硬件的发展" class="headerlink" title="1.1.1 计算机硬件的发展"></a>1.1.1 计算机硬件的发展</h3><h4 id="计算机的四代变化"><a href="#计算机的四代变化" class="headerlink" title="计算机的四代变化"></a>计算机的四代变化</h4><ul><li>从1946年，世界第一台电子数字计算机ENIAC问世起（Electronic Numerical Integrator And Computer）</li><li>计算机发展已四代</li></ul><h5 id="第一代计算机："><a href="#第一代计算机：" class="headerlink" title="第一代计算机："></a>第一代计算机：</h5><ul><li>1946-1957 电子管时代</li><li>逻辑元件：<ul><li>电子管</li></ul></li><li>编程语言：<ul><li>机器语言</li></ul></li><li>主存：<ul><li>用延迟线、磁鼓存储信息</li></ul></li><li>特点：<ul><li>容量极小，体积庞大</li><li>成本高</li></ul></li><li>运算速度:<ul><li>较低，一般只有几千次到几万次每秒</li></ul></li><li>操作系统：<ul><li>尚无</li></ul></li></ul><h5 id="第二代计算机："><a href="#第二代计算机：" class="headerlink" title="第二代计算机："></a>第二代计算机：</h5><ul><li>1958-1964  晶体管时代</li><li>逻辑元件：<ul><li>晶体管</li></ul></li><li>编程语言：<ul><li>高级语言。eg：FORTRAN</li></ul></li><li>主存：<ul><li>磁心存储器</li></ul></li><li>运算速度:<ul><li>提高至几万次到几十万次每秒</li></ul></li><li>操作系统：<ul><li>有了操作系统的雏形</li></ul></li></ul><h5 id="第三代计算机："><a href="#第三代计算机：" class="headerlink" title="第三代计算机："></a>第三代计算机：</h5><ul><li>1965-1971年  中小规模集成电路时代</li><li>逻辑元件：<ul><li>中小规模集成电路</li></ul></li><li>存储器：<ul><li>半导体存储器</li></ul></li><li>编程语言：<ul><li>高级语言发展迅速</li></ul></li><li>操作系统：<ul><li>进一步发展</li><li>有了分时操作系统</li></ul></li></ul><h5 id="第四代计算机"><a href="#第四代计算机" class="headerlink" title="第四代计算机"></a>第四代计算机</h5><ul><li>1972年至今  超大规模集成电路时代</li><li>逻辑元件：<ul><li>大规模集成电路和超大规模集成电路</li></ul></li><li>产生微处理器</li><li>并行、流水线、高速缓存和虚拟存储器等概念出现</li></ul><h4 id="计算机元件的更新换代"><a href="#计算机元件的更新换代" class="headerlink" title="计算机元件的更新换代"></a>计算机元件的更新换代</h4><ol><li>摩尔定律<ul><li>价格不变时，集成电路上可容纳的晶体管数量<ul><li>约每隔18个月便增加一倍</li><li>性能也将提高一倍</li></ul></li><li>这一定律揭示信息技术进步的速度</li></ul></li><li>半导体存储器的发展<ul><li>1970年仙童半导体公司生产出第一个较大容量的半导体存储器</li><li>至今，半导体存储器经历11代<ul><li>单芯片1KB,4KB,16KB,64KB,256KB</li><li>1MB,4MB,16MB,256MB</li><li>1GB</li></ul></li></ul></li><li>微处理器的发展<ul><li>1971年Intel公司开发第一个微处理器Intel 4004</li><li>至今经历：<ul><li>Intel 8008 (8),Intel 8080 (8),Intel 8086(16),Intel80286(32位)，Intel80386(32)</li><li>Pentium(32位)，Pentium pro(64位)，Pentium II(64位)，Pentium III(64位)，Pentium 4(64位·)</li><li>（这里的位数指的是机器字长：计算机进行一次整数运算所能处理的二进制数据的位数）</li></ul></li></ul></li></ol><h3 id="1-1-2-计算机软件的发展"><a href="#1-1-2-计算机软件的发展" class="headerlink" title="1.1.2 计算机软件的发展"></a>1.1.2 计算机软件的发展</h3><ul><li>高级语言的发展真正促进了软件的发展<ul><li>科学计算和工程计算的FORTRAN</li><li>结构化程序设计的PASCAL</li><li>面向对象的C++</li><li>适应网络环境的Java</li></ul></li><li>直接影响计算机系统性能提升的各种系统软件也有了长足发展<ul><li>特别是操作系统</li><li>eg：Windows,UNIX,Linux</li></ul></li></ul><h3 id="1-1-3-计算机的分类与发展方向"><a href="#1-1-3-计算机的分类与发展方向" class="headerlink" title="1.1.3 计算机的分类与发展方向"></a>1.1.3 计算机的分类与发展方向</h3><h4 id="电子计算机："><a href="#电子计算机：" class="headerlink" title="电子计算机："></a>电子计算机：</h4><ul><li>电子模拟计算机</li><li>电子数字计算机</li></ul><h4 id="数字计算机："><a href="#数字计算机：" class="headerlink" title="数字计算机："></a>数字计算机：</h4><ul><li>按用途分为：<ul><li>专用计算机</li><li>通用计算机</li></ul></li><li>这是根据计算机效率、速度、价格、运行的经济性、适应性来划分的</li></ul><h5 id="通用计算机："><a href="#通用计算机：" class="headerlink" title="通用计算机："></a>通用计算机：</h5><ul><li>分为：巨型机，大型机，中型机，小型机，微型机，单片机 六类</li><li>它们体积、功耗、性能、数据存储量、指令系统复杂程度、价格依次递减</li></ul><h4 id="计算机按指令和数据流分为"><a href="#计算机按指令和数据流分为" class="headerlink" title="计算机按指令和数据流分为:"></a>计算机按指令和数据流分为:</h4><ol><li>单指令流和单数据流系统<ul><li>SISD</li><li>即传统冯诺依曼体系结构</li></ul></li><li>单数据流和多数据流系统<ul><li>阵列处理器和向量处理器系统</li></ul></li><li>多指令流和单数据流系统<ul><li>这种计算机实际上不存在</li></ul></li><li>多指令流和多数据流系统<ul><li>包括多处理器和多计算机系统</li></ul></li></ol><h4 id="计算机发展趋势"><a href="#计算机发展趋势" class="headerlink" title="计算机发展趋势"></a>计算机发展趋势</h4><ul><li>向两极分化<ul><li>一极是 微型计算机向更微型化、网络化、高性能、多用途方向发展</li><li>另一极 向更巨型化，超高速，并行处理，智能化方向发展</li></ul></li></ul><h2 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h2><h3 id="1-2-1-计算机系统的组成"><a href="#1-2-1-计算机系统的组成" class="headerlink" title="1.2.1 计算机系统的组成"></a>1.2.1 计算机系统的组成</h3><h4 id="完整的计算机系统："><a href="#完整的计算机系统：" class="headerlink" title="完整的计算机系统："></a>完整的计算机系统：</h4><ul><li>由硬件系统与软件系统共同构成</li></ul><h4 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h4><ul><li>是指有形的物理设备</li><li>是计算机系统中实际物理装置的总称</li></ul><h4 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h4><ul><li>是指在硬件上运行的程序和相关的数据及文档</li></ul><h4 id="软、硬件在逻辑上等效："><a href="#软、硬件在逻辑上等效：" class="headerlink" title="软、硬件在逻辑上等效："></a>软、硬件在逻辑上等效：</h4><ul><li>计算机系统性能好坏，很大程度由软件效率、作用来表征<ul><li>而软件性能的发挥离不开硬件支持</li></ul></li><li>对于某一功能来说<ul><li>其既可以用软件实现，又可以用硬件实现</li><li>则称软硬件在逻辑上等效</li></ul></li></ul><h4 id="软硬件功能分配："><a href="#软硬件功能分配：" class="headerlink" title="软硬件功能分配："></a>软硬件功能分配：</h4><ul><li>一个功能若使用频繁，且用硬件实现的成本较理想<ul><li>则用硬件解决可提高效率</li><li>用软件实现<ul><li>可提高灵活性</li><li>但效率没有用硬件高</li></ul></li></ul></li></ul><h3 id="1-2-2-计算机硬件的基本组成"><a href="#1-2-2-计算机硬件的基本组成" class="headerlink" title="1.2.2 计算机硬件的基本组成"></a>1.2.2 计算机硬件的基本组成</h3><h4 id="早期的冯诺依曼机"><a href="#早期的冯诺依曼机" class="headerlink" title="早期的冯诺依曼机"></a>早期的冯诺依曼机</h4><ul><li>冯诺依曼在研究EDVAC机时提出“存储程序”概念<ul><li>以此概念为基础的各类计算机被称为：冯诺依曼机</li></ul></li><li>“存储程序”概念：<ul><li>特点：<ol><li>计算机硬件系统由运算器、存储器、控制器、输入设备、输出设备5大部件组成</li><li>指令和数据以同等地位存储在存储器中，并按地址寻访</li><li>指令和数据均用二进制代码表示</li><li>指令由操作码、地址码组成<ul><li>操作码：用于表示操作的性质</li><li>地址码：用来表示操作数在存储器中的位置</li></ul></li><li>指令在存储器内按顺序存放<ul><li>通常，指令是顺序执行的</li><li>但在特定条件下可根据运算结果或设定的条件改变执行顺序</li></ul></li><li>早期的冯诺依曼机以运算器为中心，输入、输出设备通过运算器与存储器传送数据</li></ol></li><li>意义：<ul><li>奠定了现代计算机的基本结构</li></ul></li><li>定义：<ul><li>指将指令以代码的形式事先输入计算机的主存储器</li><li>然后按其在存储器中的首地址执行程序的第一条指令</li><li>以后就按该程序的规定顺序执行其他指令</li><li>直至程序执行结束</li></ul></li></ul></li><li>典型的冯诺依曼计算机结构：<ul><li><img src="/posts/37002/冯诺依曼.png" alt="冯诺依曼" style="zoom:50%;"></li></ul></li></ul><h4 id="现代计算机的组织结构"><a href="#现代计算机的组织结构" class="headerlink" title="现代计算机的组织结构"></a>现代计算机的组织结构</h4><h5 id="以运算器为中心的结构"><a href="#以运算器为中心的结构" class="headerlink" title="以运算器为中心的结构"></a>以运算器为中心的结构</h5><ul><li>原因：<ul><li>微处理器面世前，运算器与控制器分离</li><li>存储器容量很小</li><li>因此设计为运算器为中心<ul><li>其他部件都通过运算器完成信息传递</li></ul></li></ul></li><li>缺点:<ul><li>随着微电子技术的进步<ul><li>同时计算机需要处理、加工的信息量也与日俱增</li><li>大量I/O设备的速度与CPU速度差距悬殊</li></ul></li><li>因此以运算器为中心的结构 不能满足计算机发展的要求<ul><li>从而产生 以存储器为中心的结构</li></ul></li></ul></li></ul><h5 id="以存储器为中心的结构"><a href="#以存储器为中心的结构" class="headerlink" title="以存储器为中心的结构"></a>以存储器为中心的结构</h5><ul><li>优点：<ul><li>使I/O操作尽可能绕过CPU</li><li>直接在I/O设备和存储器之间完成</li><li>以提高系统的整体运行效率</li></ul></li><li>以存储器为中心的计算机结构：<ul><li><img src="/posts/37002/存储器为中心.png" style="zoom:50%;"></li></ul></li></ul><h4 id="计算机的功能部件"><a href="#计算机的功能部件" class="headerlink" title="计算机的功能部件"></a>计算机的功能部件</h4><ul><li>传统冯诺依曼计算机与现代计算机结构 功能部件一致</li><li>包括：<ul><li>输入设备</li><li>输出设备</li><li>存储器</li><li>运算器</li><li>控制器</li></ul></li></ul><h5 id="输入设备："><a href="#输入设备：" class="headerlink" title="输入设备："></a>输入设备：</h5><ul><li>主要功能：<ul><li>将程序和数据</li><li>以机器所能识别和接受的信息形式 输入计算机</li></ul></li><li>eg：<ul><li>键盘（最常用最基本）、鼠标、扫描仪、摄像机</li></ul></li></ul><h5 id="输出设备："><a href="#输出设备：" class="headerlink" title="输出设备："></a>输出设备：</h5><ul><li>功能：<ul><li>将计算机处理的结果<ul><li>以人们所能接受的形式</li><li>或其他系统所要求的信息形式输出</li></ul></li></ul></li><li>eg：<ul><li>最常用最基本：显示器、打印机</li></ul></li></ul><h5 id="计算机输入输出设备（I-O设备）"><a href="#计算机输入输出设备（I-O设备）" class="headerlink" title="计算机输入输出设备（I/O设备）"></a>计算机输入输出设备（I/O设备）</h5><ul><li>是计算机与外界联系的桥梁</li><li>是计算机中不可缺少的重要部分</li></ul><h5 id="存储器："><a href="#存储器：" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>功能<ul><li>是计算机的存储部件</li><li>用来存放程序和数据</li></ul></li><li>分类：<ul><li>主存储器<ul><li>也称：主存，内存储器</li><li>是CPU能直接访问的存储器</li></ul></li><li>辅助存储器<ul><li>也称：辅存，外存储器</li><li>用于帮助主存储器记忆更多的信息<ul><li>辅助存储器的信息必须调入主存之后，才能被CPU所访问</li></ul></li></ul></li></ul></li></ul><h6 id="主存储器："><a href="#主存储器：" class="headerlink" title="主存储器："></a>主存储器：</h6><ul><li>组成方式：<ul><li>由许多存储单元组成<ul><li>每个存储单元包含若干存储元件<ul><li>每个存储元件存储一位二进制代码”0”或“1’’</li></ul></li><li>存储单元可存储一串二进制代码<ul><li>这串代码称为  <strong>存储字</strong></li><li>这串代码的 <strong>位数</strong> 为 <strong>存储字长</strong><ul><li>存储字长可以是1B（8bit）或是字节的偶数倍</li></ul></li></ul></li></ul></li></ul></li><li>工作方式：<ul><li>按存储单元的地址进行存取<ul><li>即：<strong>按地址存取方式</strong></li><li>扩展：<strong>相联</strong> 存储器 是按 <strong>内容</strong> 访问的</li></ul></li></ul></li><li>最基本组成：<ul><li>主存储器逻辑图：<ul><li><img src="/posts/37002/主存储器逻辑图.png" style="zoom:50%;"></li></ul></li><li>存储体：<ul><li>存放二进制信息</li></ul></li><li>地址寄存器MAR：<ul><li>存放访存地址</li><li>经过地址译码后找到所选的存储单元</li><li>作用：寻址，其位数对应存储单元的个数<ul><li>eg：MAR有10位，则有2^10=1024个存储单元，记为：1K</li></ul></li><li>长度：与PC的长度相等</li></ul></li><li>数据寄存器MDR:<ul><li>用于暂存要从存储器中读或写的信息</li><li>位数：<ul><li>与存储字长相等</li><li>一般为字节的二次幂的整数倍</li></ul></li><li>注意：<ul><li>MDR与MAR虽然是存储器一部分，但在现代CPU中却存在于CPU之中</li></ul></li></ul></li><li>时序控制逻辑：<ul><li>用于产生存储器操作所需的各种时序信号</li></ul></li></ul></li></ul><h5 id="运算器："><a href="#运算器：" class="headerlink" title="运算器："></a>运算器：</h5><ul><li>功能：<ul><li>是计算机的执行部件</li><li>用于进行算术运算和逻辑运算<ul><li>算术运算：<ul><li>按算术运算规则进行的运算</li><li>eg：加减乘除</li></ul></li><li>逻辑运算：<ul><li>包括与、或、非、异或、比较、移位等运算</li></ul></li></ul></li></ul></li><li>核心：<ul><li>算术逻辑单元ALU Arithmetic and Logical Unit</li></ul></li><li>包含：<ul><li>若干通用寄存器<ul><li>作用：<ul><li>暂存操作数和中间结果</li></ul></li><li>eg：<ul><li>累加器ACC</li><li>乘商寄存器MQ</li><li>操作数寄存器X</li><li>变址寄存器BR等等</li><li>（前三个寄存器必须有）</li></ul></li></ul></li><li>程序状态寄存器PSW<ul><li>也称 标志寄存器</li><li>用于存放ALU运算得到的一些标志信息或处理机的状态信息</li><li>eg：<ul><li>结果是否溢出</li><li>有无产生进位或错位</li><li>结果是否为负</li></ul></li></ul></li></ul></li></ul><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><ul><li>功能：<ul><li>是计算机的指挥中心</li><li>由其指挥各部件自动协调地进行工作</li></ul></li><li>包括：<ul><li>程序计数器PC<ul><li>作用：存放当前欲执行指令的地址</li><li>可以自动加一，以形成下一条指令的地址</li><li>与主存的MAR之间有一条直接通路</li></ul></li><li>指令寄存器IR<ul><li>作用：存放当前的指令</li><li>其内容来自：主存的MDR</li><li>指令中的操作啊OP(IR)送至CU<ul><li>用以分析指令并发出各种微操作命令序列</li></ul></li><li>地址码Ad(IR)送往MAR<ul><li>用以取操作数</li></ul></li></ul></li><li>控制单元CU</li></ul></li></ul><h6 id="cpu："><a href="#cpu：" class="headerlink" title="cpu："></a>cpu：</h6><ul><li>将运算器与控制器集成到同一芯片</li><li>称为中央处理器CPU</li></ul><h6 id="主机："><a href="#主机：" class="headerlink" title="主机："></a>主机：</h6><ul><li>包含：<ul><li>cpu</li><li>主存储器</li></ul></li></ul><h6 id="外部设备："><a href="#外部设备：" class="headerlink" title="外部设备："></a>外部设备：</h6><ul><li>简称：外设</li><li>除主机外的其他硬件装置（外存、I/O设备等）统称外部设备</li></ul><h5 id="冯诺依曼结构的模型机"><a href="#冯诺依曼结构的模型机" class="headerlink" title="冯诺依曼结构的模型机"></a>冯诺依曼结构的模型机</h5><ul><li>cpu包含：<ul><li>ALU</li><li>通用寄存器组GPRs</li><li>标志寄存器</li><li>控制器</li><li>指令寄存器IR</li><li>程序计数器PC</li><li>存储器地址寄存器MAR</li><li>存储器数据寄存器MDR</li></ul></li><li>结构图：<ul><li><img src="/posts/37002/冯诺依曼模型机.png" style="zoom:50%;"></li><li>从控制器送出的虚线：<strong>控制信号</strong><ul><li>可以控制修改PC以得到下一条指令的地址</li><li>可以控制ALU执行什么运算</li><li>可以控制主存是进行读操作还是写操作（读/写控制信号）</li></ul></li><li>CPU与主存之间通过一条 <strong>总线</strong> 相连<ul><li>总线中有：<ul><li>地址、控制、数据 三条信号线</li></ul></li><li>MAR中地址信息 会直接送到地址线上<ul><li>用于指向读/写操作的主存存储单元</li></ul></li><li>控制线中有读/写信号线<ul><li>指出数据<ul><li>是从CPU写入主存</li><li>还是从主存读出到CPU</li></ul></li><li>根据是读操作还是写操作来控制将MDR中的数据<ul><li>是直接送到数据线上</li><li>还是将数据线上的数据接收到MDR中</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="1-2-3-计算机软件的分类"><a href="#1-2-3-计算机软件的分类" class="headerlink" title="1.2.3 计算机软件的分类"></a>1.2.3 计算机软件的分类</h3><h4 id="系统软件和应用软件"><a href="#系统软件和应用软件" class="headerlink" title="系统软件和应用软件"></a>系统软件和应用软件</h4><ul><li>软件按功能分类，分为：<ul><li>系统软件</li><li>应用软件</li></ul></li></ul><h5 id="系统软件："><a href="#系统软件：" class="headerlink" title="系统软件："></a>系统软件：</h5><ul><li>定义：<ul><li>是一组保证计算机系统高效、正确运行的基础软件</li></ul></li><li>作用：<ul><li>通常作为系统资源提供给用户使用</li></ul></li><li>eg：<ul><li>操作系统 OS</li><li>数据库管理系统 DBMS</li><li>语言处理程序</li><li>分布式软件系统</li><li>网络软件系统</li><li>标准库程序</li><li>服务性程序</li></ul></li></ul><h5 id="应用软件："><a href="#应用软件：" class="headerlink" title="应用软件："></a>应用软件：</h5><ul><li>定义：<ul><li>是指用户为解决某个应用领域中的各类问题而编制的程序</li></ul></li><li>eg：<ul><li>各种科学计算类程序</li><li>工程设计类程序</li><li>数据统计与处理程序等</li></ul></li></ul><h5 id="数据库管理系统DBMS与数据系统DBS"><a href="#数据库管理系统DBMS与数据系统DBS" class="headerlink" title="数据库管理系统DBMS与数据系统DBS"></a>数据库管理系统DBMS与数据系统DBS</h5><ul><li><p>是有区别的</p></li><li><p>DMBS：</p><ul><li>是位于用户和操作系统之间的一层数据管理软件</li><li>是系统软件</li></ul></li><li><p>DBS:</p><ul><li><p>是指计算机系统中引入数据库后的系统</p></li><li><p>一般包括：</p><ul><li><p>数据库</p></li><li><p>数据库管理系统</p></li><li><p>数据库管理员DBA</p></li><li><p>应用系统</p></li></ul></li></ul></li></ul><h4 id="三个级别的语言"><a href="#三个级别的语言" class="headerlink" title="三个级别的语言"></a>三个级别的语言</h4><ul><li>机器语言</li><li>汇编语言</li><li>高级语言</li></ul><h5 id="机器语言："><a href="#机器语言：" class="headerlink" title="机器语言："></a>机器语言：</h5><ul><li>又称：二进制代码语言</li><li>需要编程人员记忆每条指令的二进制编码</li><li>是计算机唯一可以直接识别和执行的语言</li></ul><h5 id="汇编语言："><a href="#汇编语言：" class="headerlink" title="汇编语言："></a>汇编语言：</h5><ul><li>用英文单词或其缩写代替二进制的指令代码<ul><li>更容易记忆与理解</li></ul></li><li>使用此语言编辑的程序<ul><li>必须经过一个称为 <strong>汇编程序</strong>的系统软件的翻译</li><li>将其转换为计算机的机器语言后</li><li>才能在计算机的硬件系统上执行</li></ul></li></ul><h5 id="高级语言："><a href="#高级语言：" class="headerlink" title="高级语言："></a>高级语言：</h5><ul><li>是为方便程序设计人员<ul><li>写出解决问题的处理方案和解题过程的程序</li></ul></li><li>通常高级语言需要经过 <strong>编译程序</strong> 编译成 <strong>汇编语言程序</strong><ul><li>然后经过 <strong>汇编操作</strong>得到机器语言程序</li><li>或直接由 <strong>高级</strong> 语言程序翻译成 <strong>机器</strong> 语言程序</li></ul></li></ul><h3 id="1-2-4-计算机的工作过程"><a href="#1-2-4-计算机的工作过程" class="headerlink" title="1.2.4 计算机的工作过程"></a>1.2.4 计算机的工作过程</h3><ul><li>分为三步骤：<ul><li>把程序和数据 装入 主存储器</li><li>将 源程序 转换成 可执行文件</li><li>从 可执行文件的首地址 开始逐条执行指令</li></ul></li></ul><h4 id="从源程序到可执行文件"><a href="#从源程序到可执行文件" class="headerlink" title="从源程序到可执行文件"></a>从源程序到可执行文件</h4><ul><li>计算机中编写的C语言程序<ul><li>必须被转换成一系列的 <strong>低级机器指令</strong></li><li>这些指令 按照一种称为：<strong>可执行目标文件的格式</strong> 打包</li><li>并以 <strong>二进制磁盘文件</strong>的形式存放</li></ul></li></ul><h5 id="实例：UNIX系统中GCC编译器程序"><a href="#实例：UNIX系统中GCC编译器程序" class="headerlink" title="实例：UNIX系统中GCC编译器程序"></a>实例：UNIX系统中GCC编译器程序</h5><ul><li>读取源程序文件hello.c</li><li>并翻译成一个可执行目标文件hello</li><li>整个翻译过程可分为四个阶段完成：<ul><li>预处理阶段</li><li>编译阶段</li><li>汇编阶段</li><li>链接阶段</li></ul></li><li>过程：<ul><li><img src="/posts/37002/源程序转换过程.png" style="zoom:50%;"></li></ul></li></ul><h6 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h6><ul><li>预处理器CPP<ul><li>对源程序中以字符#开头的命令进行处理</li><li>eg：<ul><li>将#include命令后面的.h文件内容插入程序文件</li><li>输出结果：是一个以.i为扩展名的源文件hello.i</li></ul></li></ul></li></ul><h6 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h6><ul><li>编译器CCL<ul><li>对预处理后的源程序进行编译</li><li>生成一个汇编语言源程序hello.s</li><li>汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令</li></ul></li></ul><h6 id="汇编阶段："><a href="#汇编阶段：" class="headerlink" title="汇编阶段："></a>汇编阶段：</h6><ul><li>汇编器as<ul><li>将hello.s翻译成机器语言指令</li><li>把这些指令打包成一个称为 <strong>可重定位目标文件</strong>的hello.o<ul><li>它是一种二进制文件</li><li>因此在文本编辑器中打开它会显示乱码</li></ul></li></ul></li></ul><h6 id="链接阶段："><a href="#链接阶段：" class="headerlink" title="链接阶段："></a>链接阶段：</h6><ul><li>链接器ld<ul><li>将多个 <strong>可重定位目标文件</strong>和 <strong>标准库函数</strong><ul><li>合并为一个 <strong>可执行目标文件</strong></li><li>或简称：可执行文件</li></ul></li><li>本例中，链接器将hello.o和标准库函数prinft<ul><li>所在的 <strong>可重定位目标模块</strong>prinft.o合并</li><li>生成可执行文件hello</li><li>最终生成的可执行文件被保存在磁盘上</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第九章</title>
      <link href="/posts/59439.html"/>
      <url>/posts/59439.html</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-软件项目配置管理计划"><a href="#第九章-软件项目配置管理计划" class="headerlink" title="第九章 软件项目配置管理计划"></a>第九章 软件项目配置管理计划</h1><p>本章要点：</p><ul><li>软件配置管理基本概念</li><li>软件配置管理过程</li><li>敏捷项目配置管理</li><li>案例分析</li></ul><h2 id="1-软件配置管理基本概念"><a href="#1-软件配置管理基本概念" class="headerlink" title="1 软件配置管理基本概念"></a>1 软件配置管理基本概念</h2><h3 id="1-1-配置管理定义"><a href="#1-1-配置管理定义" class="headerlink" title="1.1 配置管理定义"></a>1.1 配置管理定义</h3><ul><li>记录软件产品的演化过程</li><li>得到精确地产品配置</li><li>最终保证软件产品的<ul><li>完整性</li><li>一致性</li><li>追溯性</li><li>可控性</li></ul></li></ul><h3 id="1-2-配置管理的主要功能"><a href="#1-2-配置管理的主要功能" class="headerlink" title="1.2 配置管理的主要功能"></a>1.2 配置管理的主要功能</h3><ul><li>版本管理</li><li>变更管理</li><li>其他</li></ul><h3 id="1-3-软件配置项"><a href="#1-3-软件配置项" class="headerlink" title="1.3 软件配置项"></a>1.3 软件配置项</h3><ul><li><p>SCI：</p><ul><li>software configration item</li></ul></li><li><p>受控于软件配置管理的款项</p></li><li><p>配置项例子：</p><ul><li><img src="/posts/59439/配置项例子.png" style="zoom:50%;"></li></ul></li></ul><h3 id="1-4-基线"><a href="#1-4-基线" class="headerlink" title="1.4 基线"></a>1.4 基线</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>基线提供了软件生存期中各个开发阶段的一个特定点<ul><li>标志开发过程一个阶段的结束</li><li>或者里程碑</li></ul></li><li>一个（些）配置项形成并通过审核，即形成基线</li><li>基线修改需要按照正式的程序执行</li></ul><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><img src="/posts/59439/基线例子.png" style="zoom:50%;"><h3 id="1-5-SCCB"><a href="#1-5-SCCB" class="headerlink" title="1.5 SCCB"></a>1.5 SCCB</h3><ul><li>software configuration control board</li><li>软件配置控制委员会<ul><li>评估变更</li><li>批量变更申请</li><li>在生存期内规范变更申请流程</li><li>对变更进行反馈</li><li>与项目管理层沟通</li></ul></li></ul><h2 id="2-软件配置管理过程"><a href="#2-软件配置管理过程" class="headerlink" title="2. 软件配置管理过程"></a>2. 软件配置管理过程</h2><h3 id="2-1-配置管理基本过程"><a href="#2-1-配置管理基本过程" class="headerlink" title="2.1 配置管理基本过程"></a>2.1 配置管理基本过程</h3><ul><li>配置项标识、跟踪</li><li>配置管理环境建立</li><li>基线变更管理</li><li>配置管理审计</li><li>配置状态空寂</li><li>配置管理计划</li></ul><h4 id="配置项标识、跟踪"><a href="#配置项标识、跟踪" class="headerlink" title="配置项标识、跟踪"></a>配置项标识、跟踪</h4><ul><li>将软件项目中需要进行控制的部分拆分成SCI</li><li>配置项是唯一的标识</li><li>配置项的跟踪<ul><li>建立配置项的对应关系</li><li>以便于进行跟踪和版本控制</li><li>实现数字化管理</li></ul></li></ul><h4 id="配置管理环境建立"><a href="#配置管理环境建立" class="headerlink" title="配置管理环境建立"></a>配置管理环境建立</h4><ul><li>建立配置管理库<ul><li>软件配置管理库<ul><li>是用来存储所有基线配置项</li><li>及相关文件的等内容的系统</li></ul></li><li>是在软件产品的整个生存期中建立和维护软件产品完成性的主要手段</li></ul></li></ul><h5 id="受控操作："><a href="#受控操作：" class="headerlink" title="受控操作："></a>受控操作：</h5><img src="/posts/59439/受控操作.png" style="zoom:50%;"><h4 id="基线变更管理过程"><a href="#基线变更管理过程" class="headerlink" title="基线变更管理过程"></a>基线变更管理过程</h4><ul><li>极限修改应受到控制</li><li>这种变化要经SCCB授权</li><li>按程序进行控制并记录基线修改的过程</li></ul><h5 id="基线变更系统"><a href="#基线变更系统" class="headerlink" title="基线变更系统"></a>基线变更系统</h5><img src="/posts/59439/基线变更系统.png" style="zoom:50%;"><h5 id="变更请求"><a href="#变更请求" class="headerlink" title="变更请求"></a>变更请求</h5><img src="/posts/59439/变更请求.png" style="zoom:50%;"><h5 id="变更评估"><a href="#变更评估" class="headerlink" title="变更评估"></a>变更评估</h5><p><img src="/posts/59439/%E5%8F%98%E6%9B%B4%E8%AF%84%E4%BC%B0.png" alt></p><h5 id="变更批准-拒绝"><a href="#变更批准-拒绝" class="headerlink" title="变更批准/拒绝"></a>变更批准/拒绝</h5><img src="/posts/59439/变更批准.png" style="zoom:50%;"><h5 id="变更实现"><a href="#变更实现" class="headerlink" title="变更实现"></a>变更实现</h5><img src="/posts/59439/变更实现.png" style="zoom:50%;"><h4 id="配置管理审计"><a href="#配置管理审计" class="headerlink" title="配置管理审计"></a>配置管理审计</h4><ul><li>配置管理过程审计</li><li>基线审计</li></ul><h4 id="配置状态统计"><a href="#配置状态统计" class="headerlink" title="配置状态统计"></a>配置状态统计</h4><ul><li>eg：<ul><li>被批准的配置项</li><li>变更请求的数量</li><li>配置项的所有请求的变化状态</li><li>配置项所有被批准的变更实现状态</li><li>配置管理系统以及SCCB在运作中发生异常的次数</li></ul></li></ul><h4 id="配置管理计划大纲-举例"><a href="#配置管理计划大纲-举例" class="headerlink" title="配置管理计划大纲-举例"></a>配置管理计划大纲-举例</h4><ul><li>人员职责（确定SCCB等）</li><li>配置项定义</li><li>基线定义</li><li>版本控制（说明配置管理工具）</li><li>定义变更控制系统</li></ul><h2 id="3-敏捷项目配置管理"><a href="#3-敏捷项目配置管理" class="headerlink" title="3.敏捷项目配置管理"></a>3.敏捷项目配置管理</h2><h3 id="3-1-敏捷配置管理"><a href="#3-1-敏捷配置管理" class="headerlink" title="3.1 敏捷配置管理"></a>3.1 敏捷配置管理</h3><ul><li>敏捷的一个重要特征是持续交付<ul><li>因此，配置管理是重要的因素</li></ul></li><li>敏捷需要全面配置管理</li></ul><h3 id="3-2-全面配置管理的基本要求"><a href="#3-2-全面配置管理的基本要求" class="headerlink" title="3.2 全面配置管理的基本要求"></a>3.2 全面配置管理的基本要求</h3><ul><li>代码和编译构建产物的配置管理</li><li>应用的配置管理</li><li>环境的配置管理</li></ul><h3 id="3-3-代码和编译构建产物的配置管理"><a href="#3-3-代码和编译构建产物的配置管理" class="headerlink" title="3.3 代码和编译构建产物的配置管理"></a>3.3 代码和编译构建产物的配置管理</h3><ul><li>制定有效的分支管理策略</li><li>配置管理工具</li></ul><h3 id="3-4-制定有效的分支管理策略"><a href="#3-4-制定有效的分支管理策略" class="headerlink" title="3.4 制定有效的分支管理策略"></a>3.4 制定有效的分支管理策略</h3><ul><li>基于分支的开发</li><li>基于主干的开发</li></ul><h4 id="基于分支的开发"><a href="#基于分支的开发" class="headerlink" title="基于分支的开发"></a>基于分支的开发</h4><ul><li>开发都在分支上提交</li><li>并且可能有多个并行分支</li><li>直到快要上线时甚至上线后才合并到主干</li></ul><h4 id="基于主干的开发"><a href="#基于主干的开发" class="headerlink" title="基于主干的开发"></a>基于主干的开发</h4><ul><li>所有提交到主干上，提交后自动触发持续集成进行验证和快速反馈</li><li>持续交付更倾向于使用主干的开发模式</li></ul><h3 id="3-5-配置管理工具-Git分支管理"><a href="#3-5-配置管理工具-Git分支管理" class="headerlink" title="3.5 配置管理工具-Git分支管理"></a>3.5 配置管理工具-Git分支管理</h3><ul><li>Master</li><li>Develop</li><li>Release</li><li>Hotfix</li><li>feature</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第八章</title>
      <link href="/posts/46193.html"/>
      <url>/posts/46193.html</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-软件项目质量计划"><a href="#第八章-软件项目质量计划" class="headerlink" title="第八章 软件项目质量计划"></a>第八章 软件项目质量计划</h1><p>本章要点：</p><ul><li>软件质量基本概念</li><li>软件质量活动</li><li>敏捷质量活动</li><li>软件质量计划</li><li>案例分析</li></ul><h2 id="1-软件质量基本概念"><a href="#1-软件质量基本概念" class="headerlink" title="1. 软件质量基本概念"></a>1. 软件质量基本概念</h2><h3 id="1-1-质量的定义"><a href="#1-1-质量的定义" class="headerlink" title="1.1 质量的定义"></a>1.1 质量的定义</h3><ul><li>质量是满足要求的程度</li><li>包括符合规定的要求和满足顾客隐含需求</li></ul><h3 id="1-2-软件质量的定义"><a href="#1-2-软件质量的定义" class="headerlink" title="1.2 软件质量的定义"></a>1.2 软件质量的定义</h3><ul><li>软件质量是软件满足明确说明或者隐含的需求的程度</li></ul><h3 id="1-3-软件质量模型"><a href="#1-3-软件质量模型" class="headerlink" title="1.3 软件质量模型"></a>1.3 软件质量模型</h3><ul><li>人们通常把影响软件质量的特性用软件质量模型来描述</li><li><img src="/posts/46193/软件质量模型.png" style="zoom:50%;"></li></ul><h3 id="1-4-质量的形成"><a href="#1-4-质量的形成" class="headerlink" title="1.4 质量的形成"></a>1.4 质量的形成</h3><ul><li>质量形成于产品或者服务的开发过程中</li><li>而不是事后的检查(测试)把关</li></ul><h3 id="1-5-质量成本（CoQ）"><a href="#1-5-质量成本（CoQ）" class="headerlink" title="1.5 质量成本（CoQ）"></a>1.5 质量成本（CoQ）</h3><ul><li>预防成本：前期质量成本</li><li>缺陷成本：后期质量成本</li></ul><h2 id="2-软件质量活动"><a href="#2-软件质量活动" class="headerlink" title="2. 软件质量活动"></a>2. 软件质量活动</h2><h3 id="2-1-软件质量管理活动"><a href="#2-1-软件质量管理活动" class="headerlink" title="2.1 软件质量管理活动"></a>2.1 软件质量管理活动</h3><ul><li>软件质量保证</li><li>软件质量控制</li></ul><h3 id="2-2-质量管理的对象"><a href="#2-2-质量管理的对象" class="headerlink" title="2.2 质量管理的对象"></a>2.2 质量管理的对象</h3><ul><li>过程的质量</li><li>产品的质量</li></ul><h3 id="2-3-质量保证QA"><a href="#2-3-质量保证QA" class="headerlink" title="2.3 质量保证QA"></a>2.3 质量保证QA</h3><img src="/posts/46193/QA.png" style="zoom:50%;"><h3 id="2-4-质量保证活动-审计Audit"><a href="#2-4-质量保证活动-审计Audit" class="headerlink" title="2.4 质量保证活动-审计Audit"></a>2.4 质量保证活动-审计Audit</h3><ul><li>审计Audit<ul><li>是对过程或者产品的一次独立评估</li><li>将审核的主体与为该主体以前建立的一组规程和标准进行比较</li></ul></li></ul><h3 id="2-5-软件项目中常用的质量保证活动"><a href="#2-5-软件项目中常用的质量保证活动" class="headerlink" title="2.5 软件项目中常用的质量保证活动"></a>2.5 软件项目中常用的质量保证活动</h3><ul><li>项目执行过程审计</li><li>项目产品审计</li></ul><h3 id="2-6-情景项目：质量审计"><a href="#2-6-情景项目：质量审计" class="headerlink" title="2.6 情景项目：质量审计"></a>2.6 情景项目：质量审计</h3><img src="/posts/46193/质量审计.png" style="zoom:50%;"><h3 id="2-7-质量控制QC"><a href="#2-7-质量控制QC" class="headerlink" title="2.7 质量控制QC"></a>2.7 质量控制QC</h3><img src="/posts/46193/QC.png" style="zoom:50%;"><h3 id="2-8-质量控制活动"><a href="#2-8-质量控制活动" class="headerlink" title="2.8 质量控制活动"></a>2.8 质量控制活动</h3><ul><li>技术评审</li><li>代码走查</li><li>测试</li><li>数据分析</li></ul><h3 id="2-9-质量保证与质量控制比较"><a href="#2-9-质量保证与质量控制比较" class="headerlink" title="2.9 质量保证与质量控制比较"></a>2.9 质量保证与质量控制比较</h3><ul><li>QA：后期质量活动</li><li>QC：前期质量活动</li></ul><h2 id="3-敏捷质量活动"><a href="#3-敏捷质量活动" class="headerlink" title="3.敏捷质量活动"></a>3.敏捷质量活动</h2><h3 id="3-1-敏捷项目的质量规划特征"><a href="#3-1-敏捷项目的质量规划特征" class="headerlink" title="3.1 敏捷项目的质量规划特征"></a>3.1 敏捷项目的质量规划特征</h3><ul><li>全程质量审查</li><li>早发现问题，多版本提交</li><li>不断进行质量方法评估和改进</li></ul><h3 id="3-2-敏捷项目的质量活动"><a href="#3-2-敏捷项目的质量活动" class="headerlink" title="3.2 敏捷项目的质量活动"></a>3.2 敏捷项目的质量活动</h3><img src="/posts/46193/敏捷项目.png" style="zoom:50%;"><h4 id="TDD："><a href="#TDD：" class="headerlink" title="TDD："></a>TDD：</h4><ul><li>测试驱动开发</li><li>基本思想：<ul><li>在开发功能代码之前，先编写测试代码。然后编写相关的代码满足这些测试用例</li></ul></li></ul><h4 id="持续集成与测试"><a href="#持续集成与测试" class="headerlink" title="持续集成与测试"></a>持续集成与测试</h4><ul><li>频繁地将工作集成到整体中</li><li>然后再进行重新测试</li><li>以确定整个产品仍然按照预期工作</li></ul><h4 id="不同层面自动化测试"><a href="#不同层面自动化测试" class="headerlink" title="不同层面自动化测试"></a>不同层面自动化测试</h4><ul><li>单元测试</li><li>集成测试</li><li>系统级测试</li><li>冒烟测试</li><li>回归测试</li></ul><h4 id="验收测试驱动开发-ATDD"><a href="#验收测试驱动开发-ATDD" class="headerlink" title="验收测试驱动开发 ATDD"></a>验收测试驱动开发 ATDD</h4><ul><li>与客户一起讨论验收标准</li><li>创建测试用例</li><li>据此驱动代码编写，进行自动化测试，满足验收标准</li></ul><h4 id="敏捷开发中的管理会议"><a href="#敏捷开发中的管理会议" class="headerlink" title="敏捷开发中的管理会议"></a>敏捷开发中的管理会议</h4><img src="/posts/46193/管理会议.png" style="zoom:50%;"><h4 id="重构Refactoring"><a href="#重构Refactoring" class="headerlink" title="重构Refactoring"></a>重构Refactoring</h4><ul><li>简单设计之后编写可以运行的代码</li><li>版本运行之后逐步完善代码和设计</li></ul><h2 id="4-软件质量计划"><a href="#4-软件质量计划" class="headerlink" title="4.软件质量计划"></a>4.软件质量计划</h2><ul><li>确定项目应达到的质量标准（目标）</li><li>决定如何满足质量标准的计划安排和方法</li></ul><h3 id="4-1-质量计划方法"><a href="#4-1-质量计划方法" class="headerlink" title="4.1 质量计划方法"></a>4.1 质量计划方法</h3><ul><li>试验设计</li><li>基准对照</li><li>质量成本分析</li><li>数据图形分析<ul><li>流程图方法</li><li>因果分析图</li><li>思维导图</li></ul></li></ul><h3 id="4-2-MED项目质量控制计划"><a href="#4-2-MED项目质量控制计划" class="headerlink" title="4.2 MED项目质量控制计划"></a>4.2 MED项目质量控制计划</h3><img src="/posts/46193/MED1.png" style="zoom:50%;"><h3 id="MED项目：质量保证计划"><a href="#MED项目：质量保证计划" class="headerlink" title="MED项目：质量保证计划"></a>MED项目：质量保证计划</h3><img src="/posts/46193/质量保证计划.png" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第七章</title>
      <link href="/posts/20.html"/>
      <url>/posts/20.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-软件项目进度计划"><a href="#第七章-软件项目进度计划" class="headerlink" title="第七章 软件项目进度计划"></a>第七章 软件项目进度计划</h1><ul><li>进度计划的重要性：<ul><li>按时完成项目是项目经理最大的挑战之一</li><li>时间是项目规划中灵活性最小的因素</li><li>进度问题是项目冲突的主要原因</li></ul></li><li>进度的定义：<ul><li>进度是对执行的活动和里程碑制定的工作计划日期表</li></ul></li><li>项目进度计划过程：<ul><li>任务定义</li><li>任务关系</li><li>历时估算</li><li>项目进度编排</li><li>项目进度确定</li></ul></li></ul><p>本章要点：</p><ul><li>进度管理基本概念</li><li>历时估算-传统和敏捷</li><li>进度计划编排-传统和敏捷</li><li>项目进度规划模型</li><li>案例分析</li></ul><h2 id="1-进度管理基本概念"><a href="#1-进度管理基本概念" class="headerlink" title="1.进度管理基本概念"></a>1.进度管理基本概念</h2><h3 id="1-1-任务定义-Defining-Activities"><a href="#1-1-任务定义-Defining-Activities" class="headerlink" title="1.1 任务定义 Defining Activities"></a>1.1 任务定义 Defining Activities</h3><ul><li>确定为完成项目的各个交付成果多必须进行的诸项具体活动</li><li>eg:<ul><li>编写设计说明书</li><li>设计评审</li></ul></li></ul><h3 id="1-2-项目任务的关联关系"><a href="#1-2-项目任务的关联关系" class="headerlink" title="1.2 项目任务的关联关系"></a>1.2 项目任务的关联关系</h3><ul><li>项目各项活动之间存在一定的关联关系</li><li>根据这些关系安排任务之间的顺序<ul><li>eg：<ul><li>前置活动（任务）</li><li>后置活动（任务）</li></ul></li></ul></li></ul><h3 id="1-3-任务之间的关系"><a href="#1-3-任务之间的关系" class="headerlink" title="1.3 任务之间的关系"></a>1.3 任务之间的关系</h3><ul><li>结束-开始</li><li>结束-结束</li><li>开始-开始</li><li>开始-结束</li></ul><h3 id="1-4-任务之间关联关系的依据"><a href="#1-4-任务之间关联关系的依据" class="headerlink" title="1.4 任务之间关联关系的依据"></a>1.4 任务之间关联关系的依据</h3><ul><li>强制性依赖关系</li><li>软逻辑关系</li><li>外部依赖关系</li><li>内部依赖关系</li></ul><h3 id="1-5-关系依赖矩阵"><a href="#1-5-关系依赖矩阵" class="headerlink" title="1.5 关系依赖矩阵"></a>1.5 关系依赖矩阵</h3><ul><li><img src="/posts/20/关系依赖矩阵.png" style="zoom:50%;"></li></ul><p>eg：</p><img src="/posts/20/矩阵举例.png" style="zoom:50%;"><h3 id="1-6-进度管理图示"><a href="#1-6-进度管理图示" class="headerlink" title="1.6 进度管理图示"></a>1.6 进度管理图示</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ul><li>网络图</li><li>甘特图</li><li>里程碑图</li><li>资源图</li></ul><h4 id="网络图"><a href="#网络图" class="headerlink" title="网络图"></a>网络图</h4><ul><li><p>定义：</p><ul><li>网络图是活动排序的一个输出</li><li>展示项目中各个活动以及活动之间的逻辑关系</li></ul></li><li><p>常用的网络图：</p><ul><li>PDM（Precedence Diagramming Method）<ul><li>优先图法、节点法（单代号）网络图</li></ul></li><li>ADM（Arrow Diagramming Method）<ul><li>箭线法（双代号）网络图</li></ul></li></ul></li><li><p>PDM图例</p><ul><li><img src="/posts/20/PDM.png" alt="PDM" style="zoom:50%;"></li><li><img src="/posts/20/PDM1.png" style="zoom:50%;"></li></ul></li><li><p>PDM定义：</p><ul><li>构成PDM网络图的基本特点是节点（Box）</li><li>节点（Box）表示活动（任务）</li><li>用箭线表示各活动（任务）之间的逻辑关系、</li><li>可以方便的表示活动之间的各种逻辑关系</li></ul></li><li><p>ADM图例：</p><ul><li><img src="/posts/20/ADM1.png" style="zoom:50%;"></li></ul></li><li><p>ADM定义：</p><ul><li>ADM也称为双代号项目网络图</li><li>在ADM网络图中，箭线表示活动（任务）</li><li>两个代号唯一确定一个任务</li><li>代号表示前一任务的结束，同时也表后一任务的开始</li></ul></li><li><p>ADM虚活动</p><ul><li>为了定义活动</li><li>为了表示逻辑关系</li><li>不消耗资源的</li><li><img src="/posts/20/虚活动.png" style="zoom:50%;"></li></ul></li></ul><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h4><img src="/posts/20/甘特图.png" style="zoom:50%;"><h4 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h4><img src="/posts/20/里程碑.png" style="zoom:50%;"><h4 id="资源图"><a href="#资源图" class="headerlink" title="资源图"></a>资源图</h4><img src="/posts/20/流程图.png" style="zoom:50%;"><h4 id="燃尽图、进度图"><a href="#燃尽图、进度图" class="headerlink" title="燃尽图、进度图"></a>燃尽图、进度图</h4><img src="/posts/20/燃尽图.png" style="zoom:50%;"><h4 id="燃起图、进度图"><a href="#燃起图、进度图" class="headerlink" title="燃起图、进度图"></a>燃起图、进度图</h4><img src="/posts/20/燃起图.png" style="zoom:50%;"><h2 id="2-任务历时估算-传统和敏捷"><a href="#2-任务历时估算-传统和敏捷" class="headerlink" title="2.任务历时估算-传统和敏捷"></a>2.任务历时估算-传统和敏捷</h2><h3 id="2-1-历时估算"><a href="#2-1-历时估算" class="headerlink" title="2.1 历时估算"></a>2.1 历时估算</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>估计任务、路径、项目的持续时间</li></ul><h4 id="基本方法：-传统"><a href="#基本方法：-传统" class="headerlink" title="基本方法：-传统"></a>基本方法：-传统</h4><ul><li>定额估算法</li><li>经验导出模型</li><li>CPM（关键路径法估计）</li><li>PERT（工程评估评审技术）</li><li>预留分析</li><li>其他<ul><li>Jones的一阶估算准则</li><li>类比估算</li><li>专家判断</li><li>基于承诺的估计</li></ul></li></ul><h5 id="定额估算法"><a href="#定额估算法" class="headerlink" title="定额估算法"></a>定额估算法</h5><img src="/posts/20/定额估算法.png" style="zoom:50%;"><h5 id="经验导出模型"><a href="#经验导出模型" class="headerlink" title="经验导出模型"></a>经验导出模型</h5><img src="/posts/20/参数模型.png" style="zoom:50%;"><img src="/posts/20/经验导出.png" style="zoom:50%;"><h6 id="建议掌握模型"><a href="#建议掌握模型" class="headerlink" title="建议掌握模型"></a>建议掌握模型</h6><img src="/posts/20/建议掌握模型.png" style="zoom:50%;"><h6 id="基本COCOMO举例"><a href="#基本COCOMO举例" class="headerlink" title="基本COCOMO举例"></a>基本COCOMO举例</h6><img src="/posts/20/cocomo.png" style="zoom:50%;"><h6 id="经验导出模型举例"><a href="#经验导出模型举例" class="headerlink" title="经验导出模型举例"></a>经验导出模型举例</h6><img src="/posts/20/经验举例.png" style="zoom:50%;"><h5 id="关键路径法估计CPM"><a href="#关键路径法估计CPM" class="headerlink" title="关键路径法估计CPM"></a>关键路径法估计CPM</h5><ul><li>方法：<ul><li>确定项目网络图</li><li>每个任务有单一的历时估算</li><li>确定网络图中任务的逻辑关系</li><li>关键路径是网=网络图中最长的路径</li><li>关键路径可以确定项目完成时间</li></ul></li><li>实例：<ul><li><img src="/posts/20/关键.png" style="zoom:50%;"></li></ul></li></ul><h5 id="PERT-工程评估评审技术"><a href="#PERT-工程评估评审技术" class="headerlink" title="PERT 工程评估评审技术"></a>PERT 工程评估评审技术</h5><h6 id="定义；"><a href="#定义；" class="headerlink" title="定义；"></a>定义；</h6><ul><li>Program Evaluation and Review Technique</li><li>利用网络顺序图逻辑关系</li><li>项目中某项单独的活动，存在很大的不确定性</li><li>加权算法估算任务历时</li><li>利用网络图逻辑关系、确定路径、项目历时</li></ul><h6 id="加权算法"><a href="#加权算法" class="headerlink" title="加权算法"></a>加权算法</h6><img src="/posts/20/加权算法.png" style="zoom:50%;"><h6 id="加权因子"><a href="#加权因子" class="headerlink" title="加权因子"></a>加权因子</h6><img src="/posts/20/加权因子.png" style="zoom:50%;"><h6 id="风险指标"><a href="#风险指标" class="headerlink" title="风险指标"></a>风险指标</h6><img src="/posts/20/风险指标.png" style="zoom:50%;"><h6 id="评估一条路径的指标"><a href="#评估一条路径的指标" class="headerlink" title="评估一条路径的指标"></a>评估一条路径的指标</h6><img src="/posts/20/指标.png" style="zoom:50%;"><h6 id="PERT估算举例"><a href="#PERT估算举例" class="headerlink" title="PERT估算举例"></a>PERT估算举例</h6><img src="/posts/20/估算举例.png" style="zoom:50%;"><h6 id="标准差的概率理论"><a href="#标准差的概率理论" class="headerlink" title="标准差的概率理论"></a>标准差的概率理论</h6><img src="/posts/20/概率1.png" style="zoom:50%;"><img src="/posts/20/概率2.png" style="zoom:50%;"><img src="/posts/20/概率3.png" style="zoom:50%;"><img src="/posts/20/概率4.png" style="zoom:50%;"><h6 id="PERT估算评估举例"><a href="#PERT估算评估举例" class="headerlink" title="PERT估算评估举例"></a>PERT估算评估举例</h6><img src="/posts/20/举例1.png" style="zoom:50%;"><img src="/posts/20/举例2.png" style="zoom:50%;"><h5 id="预留分析"><a href="#预留分析" class="headerlink" title="预留分析"></a>预留分析</h5><ul><li>应急预留</li><li>管理预留</li></ul><h6 id="应急预留："><a href="#应急预留：" class="headerlink" title="应急预留："></a>应急预留：</h6><ul><li>是包含在进度基准中的一段储备时间</li><li>用来应对已经接受的已识别风险</li><li>以应对进度方面的不确定性</li></ul><h6 id="管理预留："><a href="#管理预留：" class="headerlink" title="管理预留："></a>管理预留：</h6><ul><li>是为管理控制的目的而特别留出的项目预算</li><li>用来应对项目范围中不可预见的风险</li></ul><h5 id="Jones的一阶估算准则"><a href="#Jones的一阶估算准则" class="headerlink" title="Jones的一阶估算准则"></a>Jones的一阶估算准则</h5><img src="/posts/20/jones.png" style="zoom:50%;"><p>实例：<img src="/posts/20/jones1.png" style="zoom:50%;"></p><h5 id="类比估算："><a href="#类比估算：" class="headerlink" title="类比估算："></a>类比估算：</h5><ul><li>以过去类似项目的实际持续时间为依据</li><li>来估算当前项目的持续时间</li></ul><h5 id="专家判断："><a href="#专家判断：" class="headerlink" title="专家判断："></a>专家判断：</h5><p>根据下面专业知识做出的历时估算</p><ul><li>进度计划</li><li>有关估算</li><li>学科或应用知识</li></ul><h5 id="基于承诺的进度估算"><a href="#基于承诺的进度估算" class="headerlink" title="基于承诺的进度估算"></a>基于承诺的进度估算</h5><ul><li>要求开发人员做出进度承诺</li><li>不进行中间的工作量（规模）估计<ul><li>优点：<ul><li>有利于开发者对进度的关注</li></ul></li></ul></li></ul><h4 id="历时估算的基本方法-敏捷"><a href="#历时估算的基本方法-敏捷" class="headerlink" title="历时估算的基本方法-敏捷"></a>历时估算的基本方法-敏捷</h4><ul><li>开发速度稳定前<ul><li>项目经理组织 <strong>举手表决</strong><ul><li><img src="/posts/20/举手表决.png" style="zoom:50%;"></li></ul></li></ul></li><li>开发速度稳定后<ul><li>基于故事点生产率的估算</li><li>基于迭代生产率的估算</li></ul></li></ul><h5 id="基于Story-Point生产率的历时估算"><a href="#基于Story-Point生产率的历时估算" class="headerlink" title="基于Story Point生产率的历时估算"></a>基于Story Point生产率的历时估算</h5><img src="/posts/20/story.png" style="zoom:50%;"><h5 id="基于迭代生产率的历时估算"><a href="#基于迭代生产率的历时估算" class="headerlink" title="基于迭代生产率的历时估算"></a>基于迭代生产率的历时估算</h5><img src="/posts/20/迭代.png" style="zoom:50%;"><h2 id="3-进度计划编排-传统和敏捷"><a href="#3-进度计划编排-传统和敏捷" class="headerlink" title="3.进度计划编排-传统和敏捷"></a>3.进度计划编排-传统和敏捷</h2><h3 id="3-1-进度编制的基本方法"><a href="#3-1-进度编制的基本方法" class="headerlink" title="3.1 进度编制的基本方法"></a>3.1 进度编制的基本方法</h3><ul><li>超前Lead和滞后Lag<ul><li>关键路径法</li><li>时间压缩法</li><li>资源优化</li><li>敏捷计划</li></ul></li></ul><h4 id="任务滞后Lag"><a href="#任务滞后Lag" class="headerlink" title="任务滞后Lag"></a>任务滞后Lag</h4><img src="/posts/20/lag.png" style="zoom:50%;"><p>举例：</p><img src="/posts/20/lag1.png" style="zoom:50%;"><h4 id="任务超前Lead"><a href="#任务超前Lead" class="headerlink" title="任务超前Lead"></a>任务超前Lead</h4><img src="/posts/20/lead.png" style="zoom:50%;"><img src="/posts/20/lead2.png" style="zoom:50%;"><img src="/posts/20/lead3.png" style="zoom:50%;"><h4 id="关键路径法："><a href="#关键路径法：" class="headerlink" title="关键路径法："></a>关键路径法：</h4><h5 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h5><ul><li>最早开始时间 Early start</li><li>最晚开始时间 Late start</li><li>最早完成时间 Early finish</li><li>最晚完成时间 Late finish</li><li>总浮动 Total Float</li><li>自由浮动 Free Float</li></ul><img src="/posts/20/总.png" style="zoom:50%;"><h5 id="浮动时间Float"><a href="#浮动时间Float" class="headerlink" title="浮动时间Float"></a>浮动时间Float</h5><ul><li>浮动时间是一个任务的机动性</li><li>他是一个任务在不影响其他任务或者项目完成的情况下可以延迟的时间量</li></ul><h5 id="总浮动与自由浮动"><a href="#总浮动与自由浮动" class="headerlink" title="总浮动与自由浮动"></a>总浮动与自由浮动</h5><ul><li><p>总浮动：</p><ul><li>Total Float</li><li>在不影响项目最早完成时间的前提下</li><li>一个任务可以延迟的时间</li></ul></li><li><p>自由浮动</p><ul><li>Free Float</li><li>在不影响后置任务最早开始时间的前提下</li><li>一个任务可以延迟的时间</li></ul><img src="/posts/20/浮动.png" style="zoom:50%;"></li></ul><h5 id="关键路径Critical-Path"><a href="#关键路径Critical-Path" class="headerlink" title="关键路径Critical Path"></a>关键路径Critical Path</h5><ul><li>网络图中最长的路径</li><li>关键路径是决定项目完成的最短时间</li><li>时间浮动为0（Float=0）的路径</li><li>关键路径上任何活动延迟，都会导致整个项目完成时间的延迟</li><li>关键路径可能不止一条</li></ul><h5 id="项目网络图："><a href="#项目网络图：" class="headerlink" title="项目网络图："></a>项目网络图：</h5><img src="/posts/20/1.png" style="zoom:50%;"><img src="/posts/20/2.png" style="zoom:50%;"><img src="/posts/20/3.png" style="zoom:50%;"><img src="/posts/20/4.png" style="zoom:50%;"><img src="/posts/20/5.png" style="zoom:50%;"><img src="/posts/20/6.png" style="zoom:50%;"><h5 id="正推法Forward-pass"><a href="#正推法Forward-pass" class="headerlink" title="正推法Forward pass"></a>正推法Forward pass</h5><ul><li><p>定义：</p><ul><li>按照时间顺序计算最早开始时间和最早完成时间的方法</li></ul></li><li><p>确定项目的开始时间，网络图中第一个任务的最早开始时间是项目的开始时间</p></li><li><p>ES+Duration=EF</p></li><li><p>EF+Lag=ES(s)</p><ul><li>当一个任务有多个前置任务时，选择前置任务中最大的EF加上Lag作为ES</li></ul></li><li><p>依次类推，从左到右，从上到下，计算每个路径的所有任务的ES和最早完成时间EF</p></li><li><p>实例：</p><ul><li><img src="/posts/20/正推.png" style="zoom:50%;"></li></ul></li></ul><h5 id="逆推法-Backward-pass"><a href="#逆推法-Backward-pass" class="headerlink" title="逆推法 Backward pass"></a>逆推法 Backward pass</h5><ul><li><p>定义：</p><ul><li>按照逆时间顺序计算最晚开始时间和最晚结束时间的方法</li></ul></li><li><p>首先确定项目的结束时间</p><ul><li>网络图中的最后一个任务最晚完成时间是项目的结束时间</li></ul></li><li><p>LF-Duration=LS</p></li><li><p>LS-Lag=LF(p)</p><ul><li>当一个任务有多个后置任务时</li><li>选择其后置任务中最小LS减Lag作为LF</li></ul></li><li><p>依次类推，从右到左，从上倒下，计算每个任务的最晚开始时间LS和最晚结束时间LF</p></li><li><p>实例：</p><ul><li><img src="/posts/20/逆推法.png" style="zoom:50%;"></li></ul></li></ul><h5 id="课堂练习："><a href="#课堂练习：" class="headerlink" title="课堂练习："></a>课堂练习：</h5><img src="/posts/20/练习1.png" style="zoom:50%;"><img src="/posts/20/练习.png" style="zoom:50%;"><h4 id="时间压缩法"><a href="#时间压缩法" class="headerlink" title="时间压缩法"></a>时间压缩法</h4><ul><li>定义：<ul><li>是在不改变项目范围的前提下缩短项目工期的方法</li></ul></li><li>分类：<ul><li>应急法-赶工 Crash</li><li>平行作业法-快速跟进</li></ul></li></ul><h5 id="应急法-赶工"><a href="#应急法-赶工" class="headerlink" title="应急法-赶工"></a>应急法-赶工</h5><ul><li>在最小相关成本增加的条件下，压缩关键路径上的关键活动历时的方法</li><li>赶工也称为时间-成本平衡方法</li></ul><h6 id="赶工时间与赶工成本关系图"><a href="#赶工时间与赶工成本关系图" class="headerlink" title="赶工时间与赶工成本关系图"></a>赶工时间与赶工成本关系图</h6><img src="/posts/20/赶工.png" style="zoom:50%;"><ol><li>进度压缩单位成本方法<ol><li>线性关系</li></ol></li><li>Charles Symons(1991)方法<ol><li>进度压缩比普通进度短的时候，费用迅速上涨</li></ol></li></ol><h6 id="进度压缩单位成本方法"><a href="#进度压缩单位成本方法" class="headerlink" title="进度压缩单位成本方法"></a>进度压缩单位成本方法</h6><ul><li><p>压缩范围：</p><ul><li>正常值与可压缩值之间</li></ul></li><li><p>项目活动的正常值</p><ul><li>正常历时</li><li>正常成本</li></ul></li><li><p>项目活动的压缩值</p><ul><li>压缩历时</li><li>压缩成本</li></ul></li><li><p>eg：</p><ul><li>任务A：正常进度7周，成本5万<ul><li>压缩到5周的成本是6.2万</li></ul></li><li>压缩范围：7周-5周</li></ul></li><li><p>进度压缩单位成本=（压缩成本-正常成本）/（正常进度-压缩进度）</p><ul><li>eg;<ul><li><img src="/posts/20/压缩1.png" style="zoom:50%;"></li></ul></li></ul><h6 id="时间压缩例题"><a href="#时间压缩例题" class="headerlink" title="时间压缩例题"></a>时间压缩例题</h6><img src="/posts/20/压缩题1.png" style="zoom:50%;"></li></ul><img src="/posts/20/压缩题2.png" style="zoom:50%;"><img src="/posts/20/压缩题3.png" style="zoom:50%;"><img src="/posts/20/压缩题4.png" style="zoom:50%;"><img src="/posts/20/压缩题5.png" style="zoom:50%;"><img src="/posts/20/压缩题6.png" style="zoom:50%;"><h6 id="项目存在一个可能的最短进度"><a href="#项目存在一个可能的最短进度" class="headerlink" title="项目存在一个可能的最短进度"></a>项目存在一个可能的最短进度</h6><img src="/posts/20/最短进度.png" style="zoom:50%;"><h5 id="Charles-Symons方法"><a href="#Charles-Symons方法" class="headerlink" title="Charles Symons方法"></a>Charles Symons方法</h5><img src="/posts/20/ch.png" style="zoom:50%;"><h5 id="平行作业法-快速跟进"><a href="#平行作业法-快速跟进" class="headerlink" title="平行作业法-快速跟进"></a>平行作业法-快速跟进</h5><ul><li>改变活动间的逻辑关系</li><li>并行开展某些活动</li><li>提前量方法</li><li>eg：<ul><li><img src="/posts/20/平行作业法.png" style="zoom:50%;"></li></ul></li></ul><h5 id="任务超前（Lead-应用"><a href="#任务超前（Lead-应用" class="headerlink" title="任务超前（Lead)应用"></a>任务超前（Lead)应用</h5><img src="/posts/20/lead应用.png" style="zoom:50%;"><h4 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h4><ul><li>根据资源供需情况，调整活动的开始和完成日期</li><li>资源优化配置，形成最有效的利用资源<ul><li>使资源闲置的时间最小化</li><li>尽量避免超出资源能力</li></ul></li></ul><h5 id="分类：-1"><a href="#分类：-1" class="headerlink" title="分类："></a>分类：</h5><ul><li>资源平衡</li><li>资源平滑</li></ul><h5 id="资源平衡"><a href="#资源平衡" class="headerlink" title="资源平衡"></a>资源平衡</h5><ul><li>为了在资源需求与资源供给之间取得平衡<ul><li>根据资源制约因素对开始日期和完成日期进行调整的一种技术</li></ul></li><li>通过调整任务的时间来协调资源的冲突</li><li>资源平衡往往导致关键路径改变</li></ul><h6 id="资源平衡法"><a href="#资源平衡法" class="headerlink" title="资源平衡法"></a>资源平衡法</h6><img src="/posts/20/资源平衡法.png" style="zoom:50%;"><h5 id="资源平滑法"><a href="#资源平滑法" class="headerlink" title="资源平滑法"></a>资源平滑法</h5><ul><li>资源平滑法是在项目编排中进行资源的优化配置，保证资源最优化、最优效</li><li>资源平滑不会改变项目关键路径，完工日期也不会延迟。活动只在其自由和总浮动时间内延迟</li></ul><h4 id="敏捷计划"><a href="#敏捷计划" class="headerlink" title="敏捷计划"></a>敏捷计划</h4><h5 id="Agile-Planning"><a href="#Agile-Planning" class="headerlink" title="Agile Planning"></a>Agile Planning</h5><ul><li>Release planning<ul><li>发布计划 远期计划 粗计划</li></ul></li><li>Iteration planning<ul><li>迭代计划 近期计划 细计划</li></ul></li></ul><h2 id="4-项目进度规划模型"><a href="#4-项目进度规划模型" class="headerlink" title="4.项目进度规划模型"></a>4.项目进度规划模型</h2><h3 id="软件项目进度问题模型SPSP"><a href="#软件项目进度问题模型SPSP" class="headerlink" title="软件项目进度问题模型SPSP"></a>软件项目进度问题模型SPSP</h3><ul><li>软件项目进度问题Software Project Scheduling Problem,SPSP</li><li>是在给定的项目任务工作量及其关系和资源限制下，对项目确定合适的人员安排，以保证项目的时间最短，成本最小</li><li>目标：<ul><li>时间最短，成本最低</li></ul></li></ul><h4 id="Pdm网络图"><a href="#Pdm网络图" class="headerlink" title="Pdm网络图"></a>Pdm网络图</h4><img src="/posts/20/pdm111.png" style="zoom:50%;"><p>成本计算：<img src="/posts/20/成本计算.png" style="zoom:50%;"></p><h5 id="计划优化调整"><a href="#计划优化调整" class="headerlink" title="计划优化调整"></a>计划优化调整</h5><ol><li>调整资源，解决资源冲突</li><li>调整进度，优化项目，缩短工期</li><li>调整项目成本预算，以便减少项目费用</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第六章</title>
      <link href="/posts/15473.html"/>
      <url>/posts/15473.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-软件项目成本计划"><a href="#第六章-软件项目成本计划" class="headerlink" title="第六章 软件项目成本计划"></a>第六章 软件项目成本计划</h1><p>本章要点：</p><ul><li>估算过程概念</li><li>传统估算方法</li><li>敏捷估算方法</li><li>成本预算</li><li>案例分析</li></ul><h2 id="1-估算过程概念"><a href="#1-估算过程概念" class="headerlink" title="1. 估算过程概念"></a>1. 估算过程概念</h2><h3 id="1-1-关于估算"><a href="#1-1-关于估算" class="headerlink" title="1.1 关于估算"></a>1.1 关于估算</h3><ul><li>估算不是很准确、有误差</li><li>项目经验数据非常重要</li><li>不要太迷信某些数学模型</li></ul><h3 id="1-2-软件项目规模"><a href="#1-2-软件项目规模" class="headerlink" title="1.2 软件项目规模"></a>1.2 软件项目规模</h3><ul><li>软件项目规模即工作量</li><li>例如：<ul><li>软件规划、软件管理、需求</li><li>设计、编码、测试</li><li>以及后期的维护等任务</li></ul></li></ul><h3 id="1-3-软件规模单位"><a href="#1-3-软件规模单位" class="headerlink" title="1.3 软件规模单位"></a>1.3 软件规模单位</h3><ul><li>LOC(Loc of Code)<ul><li>源代码长度的测量</li></ul></li><li>FP（Function Point）<ul><li>用系统的功能数量来测量</li></ul></li><li>人月</li><li>人天</li><li>人年</li></ul><h3 id="1-4-软件项目成本"><a href="#1-4-软件项目成本" class="headerlink" title="1.4 软件项目成本"></a>1.4 软件项目成本</h3><ul><li>完成软件规模相应付出的代价</li><li>待开发的软件项目需要的资金</li><li>人的劳动的消耗所需要的代价是软件产品的主要成本</li><li>货币单位</li></ul><h3 id="1-5-软件规模和软件成本的关系"><a href="#1-5-软件规模和软件成本的关系" class="headerlink" title="1.5 软件规模和软件成本的关系"></a>1.5 软件规模和软件成本的关系</h3><ul><li>工作量-&gt;规模-&gt;成本</li></ul><h3 id="1-6-成本估算结果"><a href="#1-6-成本估算结果" class="headerlink" title="1.6 成本估算结果"></a>1.6 成本估算结果</h3><ul><li>直接成本：<ul><li>与具体项目相关的成本</li><li>eg:<ul><li>参与项目的人员成本</li></ul></li></ul></li><li>间接成本：<ul><li>可以分摊到各个具体项目中的成本<ul><li>eg：<ul><li>培训</li><li>房租水电</li><li>员工福利</li><li>市场费用</li><li>管理费</li><li>其他等等</li></ul></li></ul></li></ul></li></ul><h2 id="2-传统估算方法"><a href="#2-传统估算方法" class="headerlink" title="2. 传统估算方法"></a>2. 传统估算方法</h2><ul><li>代码行估算法</li><li>功能点估算法</li><li>用例点估算法</li><li>类比（自顶向下）估算法</li><li>自下而上估算法</li><li>三点估算法</li><li>参数估算法</li><li>专家估算法</li></ul><h3 id="2-1-传统估算方法-代码行估算法"><a href="#2-1-传统估算方法-代码行估算法" class="headerlink" title="2.1 传统估算方法-代码行估算法"></a>2.1 传统估算方法-代码行估算法</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ul><li>从软件程序两的角度定义项目规模<ul><li>与具体的编程语言有关</li><li>分解足够详细</li><li>有一定的经验数据</li></ul></li></ul><h4 id="代码行的主要优缺点："><a href="#代码行的主要优缺点：" class="headerlink" title="代码行的主要优缺点："></a>代码行的主要优缺点：</h4><ul><li>主要优点：<ul><li>代码是所有软件开发项目都有的“产品”</li><li>而且很容易计算代码行数</li></ul></li><li>主要缺陷：<ul><li>对代码行没有公认的可接受的标准定义</li><li>代码行数量依赖于所用的编程语言和个人的编程风格</li><li>在项目早期，需求不稳定，设计不成熟，实现不确定的情况下很难准确地估算代码量</li><li>代码行强调编码的工作量，只是项目实现阶段的一部分</li></ul></li></ul><h3 id="2-2-传统估算方法-功能点估算："><a href="#2-2-传统估算方法-功能点估算：" class="headerlink" title="2.2 传统估算方法-功能点估算："></a>2.2 传统估算方法-功能点估算：</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>与实现的语言和技术没有关系</li><li>用系统的功能数量来测量器规模</li><li>通过评估、加权、量化得到功能点</li></ul><h4 id="传统估算方法-Albrecht功能点估算"><a href="#传统估算方法-Albrecht功能点估算" class="headerlink" title="传统估算方法-Albrecht功能点估算"></a>传统估算方法-Albrecht功能点估算</h4><ul><li>1979年，Alan Albrecht提出</li><li>也称为IFPUG（国际功能点用户组织）功能点</li><li>适用于信息系统</li></ul><h4 id="功能点公式："><a href="#功能点公式：" class="headerlink" title="功能点公式："></a>功能点公式：</h4><ul><li>FP=UFC*TCF<ul><li>UFC:<ul><li>来调整功能点计数</li></ul></li><li>TCF：<ul><li>技术复杂度因子</li></ul></li></ul></li></ul><h4 id="UFC-未调整功能点计数"><a href="#UFC-未调整功能点计数" class="headerlink" title="UFC-未调整功能点计数"></a>UFC-未调整功能点计数</h4><ul><li>功能计数项：<ul><li>外部输入</li><li>外部输出</li><li>外部查询</li><li>内部逻辑文件</li><li>外部接口文件</li></ul></li></ul><h4 id="外部输入（External-Inputs-EI）"><a href="#外部输入（External-Inputs-EI）" class="headerlink" title="外部输入（External Inputs:EI）"></a>外部输入（External Inputs:EI）</h4><ul><li>给软件提供面向应用的数据的项<ul><li>eg：屏幕、表单、对话框、控件、文件等</li></ul></li><li>在这个过程中，数据穿越外部边界进入系统内部</li><li>eg<ul><li>课堂登录系统的登录框</li></ul></li></ul><h4 id="外部输出External-Outputs-EO"><a href="#外部输出External-Outputs-EO" class="headerlink" title="外部输出External Outputs EO"></a>外部输出External Outputs EO</h4><ul><li>向用户提供（经过处理的）面向应用的信息</li><li>eg：<ul><li>报表和出错信息等</li></ul></li><li>eg：<ul><li><img src="/posts/15473/外部输出.png" alt="外部输出" style="zoom:50%;"></li></ul></li></ul><h4 id="外部查询-External-Inquiry-EQ"><a href="#外部查询-External-Inquiry-EQ" class="headerlink" title="外部查询 External Inquiry EQ"></a>外部查询 External Inquiry EQ</h4><ul><li>外部查询是一个输入引出一个即时的简单输出</li><li>没有处理过程</li><li>eg：<ul><li><img src="/posts/15473/外部查询.png" alt="外部查询" style="zoom:50%;"></li></ul></li></ul><h4 id="外部接口文件-External-Interface-Files-EIF’s"><a href="#外部接口文件-External-Interface-Files-EIF’s" class="headerlink" title="外部接口文件 External Interface Files EIF’s"></a>外部接口文件 External Interface Files EIF’s</h4><ul><li>外部接口文件<ul><li>是用户可以识别的一组逻辑相关数据</li><li>这组数据只能被引用</li><li>用这些接口把信息传送给另一个系统</li></ul></li></ul><h4 id="内部逻辑文件-Internal-Logical-Files-ILF’s"><a href="#内部逻辑文件-Internal-Logical-Files-ILF’s" class="headerlink" title="内部逻辑文件 Internal Logical Files:ILF’s"></a>内部逻辑文件 Internal Logical Files:ILF’s</h4><ul><li>用户可以识别的一组逻辑相关的数据</li><li>而且完全存在于应用的边界之内</li><li>并且通过外部输入维护</li><li>是逻辑主文件的数目</li><li>eg：<ul><li><img src="/posts/15473/内部逻辑.png" alt="内部逻辑" style="zoom:50%;"></li></ul></li></ul><h4 id="FP计数的规则"><a href="#FP计数的规则" class="headerlink" title="FP计数的规则"></a>FP计数的规则</h4><ul><li>国际功能点用户组织IFPUG发布FP计数的规则<ul><li>IFPUG功能点估算方法使用指南</li></ul></li></ul><h4 id="事务组件进行定级"><a href="#事务组件进行定级" class="headerlink" title="事务组件进行定级"></a>事务组件进行定级</h4><img src="/posts/15473/事务组件.png" alt="事务组件" style="zoom:50%;"><h4 id="内部逻辑文件和外部接口文件"><a href="#内部逻辑文件和外部接口文件" class="headerlink" title="内部逻辑文件和外部接口文件"></a>内部逻辑文件和外部接口文件</h4><img src="/posts/15473/内部逻辑文件.png" alt="内部逻辑文件" style="zoom:50%;"><h4 id="功能计数项的复杂度等级"><a href="#功能计数项的复杂度等级" class="headerlink" title="功能计数项的复杂度等级"></a>功能计数项的复杂度等级</h4><img src="/posts/15473/复杂度.png" alt="复杂度" style="zoom:50%;"><h4 id="功能点估算方法举例"><a href="#功能点估算方法举例" class="headerlink" title="功能点估算方法举例"></a>功能点估算方法举例</h4><p><img src="/posts/15473/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%B8%BE%E4%BE%8B.png" alt="功能点举例"></p><h5 id="外贸订单：UFC"><a href="#外贸订单：UFC" class="headerlink" title="外贸订单：UFC"></a>外贸订单：UFC</h5><ul><li>外部输入：3项  </li><li>外部输出：1项</li><li>外部查询：1项</li><li>外部接口文件：1项</li><li>内部逻辑文件：2项</li></ul><img src="/posts/15473/UFC.png" alt="UFC" style="zoom:50%;"><h5 id="TCF-计数复杂度因子"><a href="#TCF-计数复杂度因子" class="headerlink" title="TCF-计数复杂度因子"></a>TCF-计数复杂度因子</h5><ul><li>TCF=0.65+0.01（sum（Fi））:Fi:0-5,TCF：0.65-1.35</li><li><img src="/posts/15473/TCF.png" alt="TCF"></li></ul><h5 id="技术复杂度因子的取值范围"><a href="#技术复杂度因子的取值范围" class="headerlink" title="技术复杂度因子的取值范围"></a>技术复杂度因子的取值范围</h5><ul><li><img src="/posts/15473/计数复杂度.png" alt="计数复杂度" style="zoom:50%;"></li></ul><h5 id="外贸订单项目-功能点计算"><a href="#外贸订单项目-功能点计算" class="headerlink" title="外贸订单项目-功能点计算"></a>外贸订单项目-功能点计算</h5><ul><li>因为：EFC=45<ul><li>TCF=0.65+0.01(14*3)=1.07</li></ul></li><li>所以：FP=UFC*TCF=45 * 1.07=48</li><li>如果：PF=15工时/功能点</li><li>则：Effort=48*15=720工时</li></ul><h4 id="其他功能点方法："><a href="#其他功能点方法：" class="headerlink" title="其他功能点方法："></a>其他功能点方法：</h4><ul><li>Mark II 功能点（主要应用在英国)</li><li>COSMIC-FFP 功能点（适用于实时系统或者嵌入式系统）</li></ul><h4 id="功能点与代码行的转换"><a href="#功能点与代码行的转换" class="headerlink" title="功能点与代码行的转换"></a>功能点与代码行的转换</h4><ul><li><img src="/posts/15473/功能点转换.png" alt="功能点转换" style="zoom:50%;"></li></ul><h3 id="2-3-用例点估算法"><a href="#2-3-用例点估算法" class="headerlink" title="2.3 用例点估算法"></a>2.3 用例点估算法</h3><h4 id="传统估算方法-用例模型"><a href="#传统估算方法-用例模型" class="headerlink" title="传统估算方法-用例模型"></a>传统估算方法-用例模型</h4><img src="/posts/15473/用例模型.png" alt="用例模型" style="zoom:50%;"><h4 id="传统估算方法-用例点估算模型"><a href="#传统估算方法-用例点估算模型" class="headerlink" title="传统估算方法-用例点估算模型"></a>传统估算方法-用例点估算模型</h4><img src="/posts/15473/用例点.png" alt="用例点" style="zoom:50%;"><h4 id="用例点估算方法的基本步骤"><a href="#用例点估算方法的基本步骤" class="headerlink" title="用例点估算方法的基本步骤"></a>用例点估算方法的基本步骤</h4><ol><li>计算未调整的角色权值UAW</li><li>计算未调整的用例权值UUCW</li><li>计算未调整的用例点UUCP</li><li>计算技术和环境因子TEF</li><li>计算调整的用例点UCP</li><li>计算工作量man-hours</li></ol><h5 id="1-计算未调整的角色权值UAW"><a href="#1-计算未调整的角色权值UAW" class="headerlink" title="1.计算未调整的角色权值UAW"></a>1.计算未调整的角色权值UAW</h5><img src="/posts/15473/UAW.png" alt="UAW" style="zoom:50%;"><h5 id="2-计算未调整的用例权值UUCW"><a href="#2-计算未调整的用例权值UUCW" class="headerlink" title="2. 计算未调整的用例权值UUCW"></a>2. 计算未调整的用例权值UUCW</h5><img src="/posts/15473/uucw.png" alt="UUCW" style="zoom:50%;"><h5 id="3-计算未调整的用例点UUCP"><a href="#3-计算未调整的用例点UUCP" class="headerlink" title="3.计算未调整的用例点UUCP"></a>3.计算未调整的用例点UUCP</h5><ul><li>UUCP=UAW+UUCW</li><li><img src="/posts/15473/UUCP.png" alt="UUCP" style="zoom:50%;"></li></ul><h5 id="4-计算技术因子TCF"><a href="#4-计算技术因子TCF" class="headerlink" title="4.计算技术因子TCF"></a>4.计算技术因子TCF</h5><ul><li><img src="/posts/15473/TCF计算.png" alt="TCF计算" style="zoom:50%;"></li></ul><h5 id="5-计算调整的用例点UCP"><a href="#5-计算调整的用例点UCP" class="headerlink" title="5.计算调整的用例点UCP"></a>5.计算调整的用例点UCP</h5><ul><li>UCP=UUCP * TCF * ECF</li><li><img src="/posts/15473/UCP.png" alt="UCP" style="zoom:50%;"></li></ul><h5 id="6-计算工作量"><a href="#6-计算工作量" class="headerlink" title="6.计算工作量"></a>6.计算工作量</h5><img src="/posts/15473/工作量.png" alt="工作量" style="zoom:50%;"><h3 id="2-4-类比（自顶向下-估算法"><a href="#2-4-类比（自顶向下-估算法" class="headerlink" title="2.4 类比（自顶向下)估算法"></a>2.4 类比（自顶向下)估算法</h3><h4 id="类比估算-定义："><a href="#类比估算-定义：" class="headerlink" title="类比估算-定义："></a>类比估算-定义：</h4><ul><li>估算人员根据以往的完成类似项目所消耗的总成本（或工作量）</li><li>来推算将要开发的软件的总成本（或工作量)</li><li>是一种自上而下的估算形式</li></ul><h5 id="类比估算-使用情况"><a href="#类比估算-使用情况" class="headerlink" title="类比估算-使用情况"></a>类比估算-使用情况</h5><ul><li>有类似的历史项目数据</li><li>信息不足（例如市场招标）的时候</li><li>要求不是非常精确估算的时候</li></ul><h5 id="类比估算-理论举例"><a href="#类比估算-理论举例" class="headerlink" title="类比估算-理论举例"></a>类比估算-理论举例</h5><img src="/posts/15473/理论举例.png" alt="理论举例" style="zoom:50%;"><h5 id="类比估算-主观判断举例"><a href="#类比估算-主观判断举例" class="headerlink" title="类比估算-主观判断举例"></a>类比估算-主观判断举例</h5><ul><li>证券交易网站<ul><li>需求类似</li><li>历史数据10万</li><li>类比估算10万</li></ul></li></ul><h3 id="2-5-自上而下估算法"><a href="#2-5-自上而下估算法" class="headerlink" title="2.5 自上而下估算法"></a>2.5 自上而下估算法</h3><h4 id="自上而下估算-定义"><a href="#自上而下估算-定义" class="headerlink" title="自上而下估算-定义"></a>自上而下估算-定义</h4><ul><li>利用任务分解图WBS<ul><li>对各个具体工作包进行详细的成本估算</li><li>然后将结果累加起来得出项目总成本</li></ul></li></ul><h4 id="自上而下估算-特点"><a href="#自上而下估算-特点" class="headerlink" title="自上而下估算-特点"></a>自上而下估算-特点</h4><ul><li>相对比较准确<ul><li>他的准确度来源于每个任务的估算情况</li></ul></li><li>花费时间</li></ul><h4 id="自上而下估算举例"><a href="#自上而下估算举例" class="headerlink" title="自上而下估算举例"></a>自上而下估算举例</h4><img src="/posts/15473/自上而下举例.png" alt="自上而下举例" style="zoom:50%;"><h3 id="2-6-三点估算法"><a href="#2-6-三点估算法" class="headerlink" title="2.6 三点估算法"></a>2.6 三点估算法</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>基于任务成本的三种估算值来计算预期成本的方法</li></ul><h4 id="三种估算值"><a href="#三种估算值" class="headerlink" title="三种估算值"></a>三种估算值</h4><ul><li>最可能成本Cm<ul><li>比较现实的估算成本</li></ul></li><li>最乐观成本Co<ul><li>最好情况所得到的估算成本</li></ul></li><li>最悲观成本Cp<ul><li>最差情况所得到的估算成本</li></ul></li></ul><h4 id="三点估算结果"><a href="#三点估算结果" class="headerlink" title="三点估算结果"></a>三点估算结果</h4><img src="/posts/15473/三点估算结果.png" alt="三点估算结果" style="zoom:50%;"><p>举例：</p><img src="/posts/15473/三点估算举例.png" alt="三点估算举例" style="zoom:50%;"><h3 id="2-7-参数估算法"><a href="#2-7-参数估算法" class="headerlink" title="2.7 参数估算法"></a>2.7 参数估算法</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><ul><li>通过项目数据<ul><li>进行回归分析</li><li>得出回归模型</li></ul></li><li>通过参数模型估算（规模）成本的方法</li></ul><h4 id="参数模型-面向LOC驱动的"><a href="#参数模型-面向LOC驱动的" class="headerlink" title="参数模型:面向LOC驱动的"></a>参数模型:面向LOC驱动的</h4><img src="/posts/15473/LOC驱动.png" alt="Loc驱动" style="zoom:50%;"><h4 id="参数模型：面向FP驱动的"><a href="#参数模型：面向FP驱动的" class="headerlink" title="参数模型：面向FP驱动的"></a>参数模型：面向FP驱动的</h4><img src="/posts/15473/FP驱动.png" alt="FP驱动" style="zoom:50%;"><h4 id="参数模型：整体公式"><a href="#参数模型：整体公式" class="headerlink" title="参数模型：整体公式"></a>参数模型：整体公式</h4><img src="/posts/15473/整体公式.png" alt="整体公式" style="zoom:50%;"><h4 id="建议掌握模型"><a href="#建议掌握模型" class="headerlink" title="建议掌握模型"></a>建议掌握模型</h4><ul><li>Walston-Felix模型</li><li>COCOMO模型</li></ul><h5 id="Walston-Felix模型"><a href="#Walston-Felix模型" class="headerlink" title="Walston-Felix模型"></a>Walston-Felix模型</h5><ul><li><img src="/posts/15473/walston公式.png" alt="walston公式" style="zoom:50%;"></li><li><p>举例：</p><ul><li><img src="/posts/15473/walston举例.png" alt="walston举例" style="zoom:50%;"></li></ul></li></ul><h5 id="COCOMO"><a href="#COCOMO" class="headerlink" title="COCOMO"></a>COCOMO</h5><ul><li><p>定义：</p><ul><li>Constructive cost model</li><li>结构化成本模型</li><li>是目前应用最广泛的参数型软件成本估计模型</li><li>由Barry Boehm团队开发</li></ul></li><li><p>分类：</p><ul><li>COCOMO 81</li><li>COCOMO II</li></ul></li><li><p>基本原理：</p><ul><li><img src="/posts/15473/cocomo基本原理.png" alt="cocomo基本原理" style="zoom:50%;"></li></ul></li><li><p>COCOMO 81</p><ul><li>模型级别：<ul><li>基本COCOMO</li><li>中等COCOMO</li><li>高级COCOMO</li></ul></li><li>项目类型：<ul><li>有机:Organic</li><li>嵌入式：Embedded</li><li>半嵌入：Semidetached</li></ul></li></ul></li></ul><h5 id="基本COCOMO-81"><a href="#基本COCOMO-81" class="headerlink" title="基本COCOMO-81"></a>基本COCOMO-81</h5><ul><li><img src="/posts/15473/81.png" alt="81" style="zoom:50%;"></li><li><p>基本COCOMO-81系数表</p><ul><li><img src="/posts/15473/81表.png" alt="81表" style="zoom:50%;"></li></ul></li><li><p>eg：</p><ul><li><img src="/posts/15473/81eg.png" alt="81eg" style="zoom:50%;"></li></ul></li></ul><h5 id="中等COCOMO-81"><a href="#中等COCOMO-81" class="headerlink" title="中等COCOMO-81"></a>中等COCOMO-81</h5><img src="/posts/15473/中等81.png" alt="中等81" style="zoom:50%;"><ul><li>乘法因子的成本驱动属性<ul><li>产品属性</li><li>平台属性</li><li>人员属性</li><li>过程属性</li></ul></li><li>乘法因子<ul><li><img src="/posts/15473/乘法因子.png" alt="乘法因子" style="zoom:50%;"></li><li>举例：<ul><li><img src="/posts/15473/乘法因子举例.png" alt="乘法因子举例" style="zoom:50%;"></li></ul></li></ul></li></ul><h5 id="高级COCOMO"><a href="#高级COCOMO" class="headerlink" title="高级COCOMO"></a>高级COCOMO</h5><ul><li>特点：<ul><li>将项目分解为一系列的子系统或者子模型</li><li>更加精确地调整一个模型的属性</li></ul></li></ul><h3 id="2-8-专家估算法"><a href="#2-8-专家估算法" class="headerlink" title="2.8 专家估算法"></a>2.8 专家估算法</h3><ul><li>由多位专家进行成本估算<ul><li>一个专家可能会有偏见</li><li>最好由多位专家进行估算，取得多个估算值</li><li>最后得出综合的估算值</li></ul></li></ul><h4 id="Deiphi"><a href="#Deiphi" class="headerlink" title="Deiphi"></a>Deiphi</h4><img src="/posts/15473/deiphi.png" alt="deiphi" style="zoom:50%;"><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><img src="/posts/15473/deiphi举例.png" alt="deiphi举例" style="zoom:50%;"><h2 id="3-敏捷估算方法"><a href="#3-敏捷估算方法" class="headerlink" title="3.敏捷估算方法"></a>3.敏捷估算方法</h2><h3 id="3-1-敏捷估算思维"><a href="#3-1-敏捷估算思维" class="headerlink" title="3.1 敏捷估算思维"></a>3.1 敏捷估算思维</h3><ul><li>采用轻量级估算方法快速生成高层级估算</li><li>短期规划可以进行详细的估算</li></ul><h3 id="3-2-Story-point估算方法"><a href="#3-2-Story-point估算方法" class="headerlink" title="3.2 Story point估算方法"></a>3.2 Story point估算方法</h3><ul><li>Story point（故事点）<ul><li>用来度量实现一个story需要付出的工作量的相对估算</li><li><img src="/posts/15473/故事点例子.png" alt="故事点例子" style="zoom:50%;"></li></ul></li></ul><h4 id="常用的两个标准："><a href="#常用的两个标准：" class="headerlink" title="常用的两个标准："></a>常用的两个标准：</h4><img src="/posts/15473/两个标准.png" alt="两个标准" style="zoom:50%;"><h4 id="Fibonacci七个等级："><a href="#Fibonacci七个等级：" class="headerlink" title="Fibonacci七个等级："></a>Fibonacci七个等级：</h4><img src="/posts/15473/七个等级.png" alt="七个等级" style="zoom:50%;"><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><img src="/posts/15473/story举例.png" alt="story举例" style="zoom:50%;"><h4 id="总估算成本（BAC）"><a href="#总估算成本（BAC）" class="headerlink" title="总估算成本（BAC）"></a>总估算成本（BAC）</h4><img src="/posts/15473/BAC.png" alt="BAC" style="zoom:50%;"><h2 id="4-成本预算"><a href="#4-成本预算" class="headerlink" title="4.成本预算"></a>4.成本预算</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><ul><li>成本预算是将项目的总成本按照项目的进度分摊到各个工作单元中去</li></ul><h3 id="4-2-目的："><a href="#4-2-目的：" class="headerlink" title="4.2 目的："></a>4.2 目的：</h3><ul><li>产生成本基线</li></ul><h3 id="4-3-估算（BAC）与预算（BCWS）"><a href="#4-3-估算（BAC）与预算（BCWS）" class="headerlink" title="4.3 估算（BAC）与预算（BCWS）"></a>4.3 估算（BAC）与预算（BCWS）</h3><img src="/posts/15473/BCWS.png" alt="BCWS" style="zoom:50%;"><h3 id="4-4-项目成本预算"><a href="#4-4-项目成本预算" class="headerlink" title="4.4 项目成本预算"></a>4.4 项目成本预算</h3><ul><li>分配项目成本预算包括三种情况：<ul><li>给任务分配资源成本</li><li>给任务分配固定资源成本</li><li>给任务分配固定成本</li></ul></li></ul><h4 id="给任务分配资源成本：常规方法"><a href="#给任务分配资源成本：常规方法" class="headerlink" title="给任务分配资源成本：常规方法"></a>给任务分配资源成本：常规方法</h4><ul><li>与资源的费率相关<ul><li>标准费率</li><li>加班费率</li><li>每次使用费率</li></ul></li></ul><h4 id="给任务分配资源成本：例子"><a href="#给任务分配资源成本：例子" class="headerlink" title="给任务分配资源成本：例子"></a>给任务分配资源成本：例子</h4><img src="/posts/15473/任务分配资源成本.png" style="zoom:50%;"><h4 id="分配固定资源成本"><a href="#分配固定资源成本" class="headerlink" title="分配固定资源成本"></a>分配固定资源成本</h4><ul><li>当一个项目的资源需要固定数量的资金时<ul><li>可以向任务分配固定资源成本</li></ul></li><li>eg：项目中的一个兼职人员成本</li></ul><h4 id="分配固定成本"><a href="#分配固定成本" class="headerlink" title="分配固定成本"></a>分配固定成本</h4><ul><li>有些任务是固定成本的典型的任务</li><li>即，管理者知道某项任务的成本不变</li><li>不管任务的工期有多长，或不管任务使用了哪些资源</li><li>在这种情况下，管理者向任务直接分配成本</li><li>eg：<ul><li>某外包任务、培训任务</li></ul></li></ul><h3 id="4-5-成本基线："><a href="#4-5-成本基线：" class="headerlink" title="4.5 成本基线："></a>4.5 成本基线：</h3><img src="/posts/15473/成本基线.png" alt="成本基线" style="zoom:50%;"><h2 id="5-案例分析"><a href="#5-案例分析" class="headerlink" title="5.案例分析"></a>5.案例分析</h2><h3 id="5-1-医疗信息商务平台成本估算"><a href="#5-1-医疗信息商务平台成本估算" class="headerlink" title="5.1 医疗信息商务平台成本估算"></a>5.1 医疗信息商务平台成本估算</h3><ul><li>工作量成本估算案例<ul><li>自下而上的估算</li><li>用例点估算</li></ul></li></ul><h4 id="MED自下而上的估算"><a href="#MED自下而上的估算" class="headerlink" title="MED自下而上的估算"></a>MED自下而上的估算</h4><img src="/posts/15473/MED.png" alt="MED" style="zoom:50%;"><h5 id="计算开发成本"><a href="#计算开发成本" class="headerlink" title="计算开发成本"></a>计算开发成本</h5><img src="/posts/15473/计算开发成本.png" alt="计算开发成本" style="zoom:50%;"><h5 id="计算直接、间接成本"><a href="#计算直接、间接成本" class="headerlink" title="计算直接、间接成本"></a>计算直接、间接成本</h5><img src="/posts/15473/间接成本.png" alt="间接成本" style="zoom:50%;"><h5 id="计算总估算成本"><a href="#计算总估算成本" class="headerlink" title="计算总估算成本"></a>计算总估算成本</h5><img src="/posts/15473/总估算成本.png" alt="总估算成本" style="zoom:50%;"><h4 id="MED用例点估算"><a href="#MED用例点估算" class="headerlink" title="MED用例点估算"></a>MED用例点估算</h4><img src="/posts/15473/MED用例点.png" alt="MED用例点" style="zoom:50%;"><h4 id="角色-user"><a href="#角色-user" class="headerlink" title="角色;user"></a>角色;user</h4><img src="/posts/15473/角色.png" alt="角色" style="zoom:50%;"><h5 id="计算未调整的角色的权值：UAW"><a href="#计算未调整的角色的权值：UAW" class="headerlink" title="计算未调整的角色的权值：UAW"></a>计算未调整的角色的权值：UAW</h5><img src="/posts/15473/UAW计算.png" alt="UAW计算" style="zoom:50%;"><h5 id="计算未调整的用例权值：UUCW"><a href="#计算未调整的用例权值：UUCW" class="headerlink" title="计算未调整的用例权值：UUCW"></a>计算未调整的用例权值：UUCW</h5><img src="/posts/15473/计算UUCW.png" alt="计算UUCW" style="zoom:50%;"><h5 id="计算未调整的用例点：UUCP"><a href="#计算未调整的用例点：UUCP" class="headerlink" title="计算未调整的用例点：UUCP"></a>计算未调整的用例点：UUCP</h5><img src="/posts/15473/计算UUCP.png" style="zoom:50%;"><h5 id="技术复杂因子TCF"><a href="#技术复杂因子TCF" class="headerlink" title="技术复杂因子TCF"></a>技术复杂因子TCF</h5><img src="/posts/15473/技术复杂因子.png" alt="技术复杂因子" style="zoom:50%;"><h5 id="环境因子ECF"><a href="#环境因子ECF" class="headerlink" title="环境因子ECF"></a>环境因子ECF</h5><img src="/posts/15473/环境因子.png" style="zoom:50%;"><h5 id="计算用例点UCP"><a href="#计算用例点UCP" class="headerlink" title="计算用例点UCP"></a>计算用例点UCP</h5><img src="/posts/15473/计算用例点.png" alt="计算用例点" style="zoom:50%;"><h5 id="规模：Effort"><a href="#规模：Effort" class="headerlink" title="规模：Effort"></a>规模：Effort</h5><img src="/posts/15473/规模.png" alt="规模" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第五章</title>
      <link href="/posts/29800.html"/>
      <url>/posts/29800.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-软件项目任务分解"><a href="#第五章-软件项目任务分解" class="headerlink" title="第五章 软件项目任务分解"></a>第五章 软件项目任务分解</h1><p>类比：</p><ul><li>房屋建筑工程项目的三级分解</li><li>日本某建筑项目任务分解过程<ul><li>标准化过程</li><li>搭积木过程</li></ul></li><li>构建厂里的生产线</li><li>生产线上下来的楼梯</li><li>工厂里贴瓷砖</li><li>工厂里出来的墙体就直接带着墙砖</li><li>卫浴间是整体安装</li></ul><p><strong>强调</strong></p><ul><li><strong>任务分解是项目管理的基础</strong></li></ul><p>本章要点：</p><ul><li>任务分解基本概念</li><li>任务分解方法</li><li>敏捷任务分解</li><li>案例分析</li></ul><h2 id="1-任务分解基本概念"><a href="#1-任务分解基本概念" class="headerlink" title="1.任务分解基本概念"></a>1.任务分解基本概念</h2><h3 id="1-1-任务分解"><a href="#1-1-任务分解" class="headerlink" title="1.1 任务分解"></a>1.1 任务分解</h3><ul><li>任务分解的过程：<ul><li>将一个项目分解为更多的工作细目或者子项目</li><li>是项目变得更小</li><li>更以管理</li><li>更易操作</li></ul></li><li>任务分解的结果：<ul><li>WBS（work breakdown structure）</li><li>任务分解结构</li></ul></li></ul><h3 id="1-2-任务需求分解"><a href="#1-2-任务需求分解" class="headerlink" title="1.2 任务需求分解"></a>1.2 任务需求分解</h3><ul><li>需求拆分以获取范围灵活性</li></ul><h3 id="1-3-WBS"><a href="#1-3-WBS" class="headerlink" title="1.3 WBS"></a>1.3 WBS</h3><ul><li>WBS是对项目由粗到细的分解过程</li><li>面向交付成果的</li><li>WBS组织并定义了整个项目范围</li></ul><h3 id="1-4-工作包-Work-packages"><a href="#1-4-工作包-Work-packages" class="headerlink" title="1.4 工作包 Work packages"></a>1.4 工作包 Work packages</h3><ul><li>WBS的最低层次的可交付成果</li><li>工作包应由唯一主体负责</li></ul><h4 id="组织结构图（图表）形式的WBS"><a href="#组织结构图（图表）形式的WBS" class="headerlink" title="组织结构图（图表）形式的WBS"></a>组织结构图（图表）形式的WBS</h4><img src="/posts/29800/图表WBS.png" alt="图表WBS" style="zoom:50%;"><h4 id="提纲（清单）式的WBS"><a href="#提纲（清单）式的WBS" class="headerlink" title="提纲（清单）式的WBS"></a>提纲（清单）式的WBS</h4><img src="/posts/29800/提纲WBS.png" alt="提纲WBS" style="zoom:50%;"><h4 id="WBS字典："><a href="#WBS字典：" class="headerlink" title="WBS字典："></a>WBS字典：</h4><img src="/posts/29800/WBS字典.png" alt="WBS字典" style="zoom:50%;"><h2 id="2-任务分解方法"><a href="#2-任务分解方法" class="headerlink" title="2.任务分解方法"></a>2.任务分解方法</h2><ul><li>类比</li><li>模版参照</li><li>自上而下</li><li>自下而上</li></ul><h3 id="2-1-模板参照"><a href="#2-1-模板参照" class="headerlink" title="2.1 模板参照"></a>2.1 模板参照</h3><img src="/posts/29800/模版参照.png" alt="模版参照" style="zoom:50%;"><h3 id="2-2-自上而下"><a href="#2-2-自上而下" class="headerlink" title="2.2 自上而下"></a>2.2 自上而下</h3><img src="/posts/29800/自上而下.png" alt="自上而下" style="zoom:50%;"><h3 id="2-3-自上而下"><a href="#2-3-自上而下" class="headerlink" title="2.3 自上而下"></a>2.3 自上而下</h3><img src="/posts/29800/自下而上.png" alt="自下而上" style="zoom:50%;"><h3 id="2-4-WBS任务分解建议"><a href="#2-4-WBS任务分解建议" class="headerlink" title="2.4 WBS任务分解建议"></a>2.4 WBS任务分解建议</h3><ul><li>最低层是可控的和可管理的，但是不必要的过细</li><li>每个Work package必须有一个提交物</li><li>定义任务完成的标准</li><li>有利于责任分配</li><li>推荐任务分解到40小时以内，敏捷项目分解到小时</li></ul><h2 id="3-敏捷项目的任务分解"><a href="#3-敏捷项目的任务分解" class="headerlink" title="3. 敏捷项目的任务分解"></a>3. 敏捷项目的任务分解</h2><ul><li><p>基于story的分解</p><ul><li>Epics</li><li>Epics break down</li></ul><img src="/posts/29800/敏捷任务分解.png" alt="敏捷任务分解" style="zoom:50%;"></li></ul><h3 id="3-1-敏捷任务分解输出"><a href="#3-1-敏捷任务分解输出" class="headerlink" title="3.1 敏捷任务分解输出"></a>3.1 敏捷任务分解输出</h3><ul><li>product (Sprint)backlog<ul><li>逐步完善</li></ul></li></ul><h2 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4. 案例分析"></a>4. 案例分析</h2><h3 id="4-1-医疗信息商务平台"><a href="#4-1-医疗信息商务平台" class="headerlink" title="4.1 医疗信息商务平台"></a>4.1 医疗信息商务平台</h3><img src="/posts/29800/医疗信息.png" alt="医疗信息" style="zoom:50%;"><h3 id="4-2-MED-任务分解结果"><a href="#4-2-MED-任务分解结果" class="headerlink" title="4.2 MED:任务分解结果"></a>4.2 MED:任务分解结果</h3><img src="/posts/29800/MED.png" alt="MED" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第四章</title>
      <link href="/posts/46806.html"/>
      <url>/posts/46806.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-软件项目需求管理"><a href="#第四章-软件项目需求管理" class="headerlink" title="第四章 软件项目需求管理"></a>第四章 软件项目需求管理</h1><h3 id="需求管理中的问题举例"><a href="#需求管理中的问题举例" class="headerlink" title="需求管理中的问题举例"></a>需求管理中的问题举例</h3><ul><li>需求的隐含错误</li><li>用户不断增加需求、变更需求</li></ul><h3 id="项目失败的原因分析"><a href="#项目失败的原因分析" class="headerlink" title="项目失败的原因分析"></a>项目失败的原因分析</h3><ul><li>不充分的需求规范</li><li>需求的改变</li><li>缺乏系统工程师</li><li>缺乏了解软件特性的经理人</li><li>缺乏合格的项目经理</li><li>缺乏软件工程师</li><li>固定价合同</li><li>系统集成阶段，交流与沟通不充分</li><li>团队缺乏经验</li><li>缺乏应用领域专家</li></ul><h3 id="软件需求定义"><a href="#软件需求定义" class="headerlink" title="软件需求定义"></a>软件需求定义</h3><ul><li>需求：<ul><li>是指用户对软件的功能的性能的要求</li></ul></li></ul><p>本章要点：</p><ul><li>软件需求管理过程</li><li>传统需求建模方法</li><li>敏捷需求建模方法</li><li>案例分析</li></ul><h2 id="1-软件需求管理的过程"><a href="#1-软件需求管理的过程" class="headerlink" title="1.软件需求管理的过程"></a>1.软件需求管理的过程</h2><img src="/posts/46806/管理过程.png" alt="管理过程" style="zoom:50%;"><h3 id="1-1-需求获取"><a href="#1-1-需求获取" class="headerlink" title="1.1 需求获取"></a>1.1 需求获取</h3><h4 id="需求获取的方法："><a href="#需求获取的方法：" class="headerlink" title="需求获取的方法："></a>需求获取的方法：</h4><ul><li>用户要求</li><li>软件需求</li></ul><h3 id="1-2-需求分析"><a href="#1-2-需求分析" class="headerlink" title="1.2 需求分析"></a>1.2 需求分析</h3><ul><li>需求分析<ul><li>是为最终用户所看到的系统建立的一个概念模型</li><li>是对需求的抽象描述</li></ul></li><li>需求分析模型<ul><li><img src="/posts/46806/需求分析模型.png" alt="需求分析模型" style="zoom:50%;"></li></ul></li></ul><h3 id="1-3-需求规格编写"><a href="#1-3-需求规格编写" class="headerlink" title="1.3 需求规格编写"></a>1.3 需求规格编写</h3><ul><li>需求分析工作完成的一个基本标志<ul><li>是形成了一份完整的、规范的需求规格说明书</li></ul></li></ul><h3 id="1-4-需求验证"><a href="#1-4-需求验证" class="headerlink" title="1.4 需求验证"></a>1.4 需求验证</h3><ul><li>需求是正确的吗</li><li>需求是一致的吗</li><li>需求是完全的吗</li><li>需求是实际可行的吗</li><li>需求是必要的吗</li><li>需求是可检验的吗</li><li>需求是可跟踪的吗</li><li>最后的签字</li></ul><h3 id="1-5-需求总在变化"><a href="#1-5-需求总在变化" class="headerlink" title="1.5 需求总在变化"></a>1.5 需求总在变化</h3><h3 id="1-6-需求变更管理"><a href="#1-6-需求变更管理" class="headerlink" title="1.6 需求变更管理"></a>1.6 需求变更管理</h3><ul><li>确定需求变更控制过程</li><li>建立变更控制委员会SCCB</li><li>进行需求变更影响分析</li><li>跟踪所有受需求变更影响的工作产品</li><li>建立需求基准版本和需求控制版本文档</li><li>维护需求变更的历史记录</li><li>跟踪每项需求的状态</li><li>衡量需求稳定性</li></ul><h3 id="1-7-需求变更控制流程"><a href="#1-7-需求变更控制流程" class="headerlink" title="1.7 需求变更控制流程"></a>1.7 需求变更控制流程</h3><img src="/posts/46806/控制流程.png" alt="控制流程" style="zoom:50%;"><h2 id="2-需求建模的基本方法介绍"><a href="#2-需求建模的基本方法介绍" class="headerlink" title="2.需求建模的基本方法介绍"></a>2.需求建模的基本方法介绍</h2><ul><li>传统方法：<ul><li>原型方法</li><li>基于数据流建模</li><li>基于UML建模</li></ul></li><li>敏捷方法</li></ul><h3 id="2-1-原型方法"><a href="#2-1-原型方法" class="headerlink" title="2.1 原型方法"></a>2.1 原型方法</h3><img src="/posts/46806/原型方法.png" alt="原型方法" style="zoom:50%;"><h3 id="2-2-基于数据流-结构化分析方法"><a href="#2-2-基于数据流-结构化分析方法" class="headerlink" title="2.2 基于数据流-结构化分析方法"></a>2.2 基于数据流-结构化分析方法</h3><ul><li>20世纪70年发展起来的面向数据流的方法</li><li>是一种自顶向下逐步求精的分析方法</li><li>根据软件内部数据传递、变换的关系进行分析的</li></ul><h4 id="基于数据流的技术："><a href="#基于数据流的技术：" class="headerlink" title="基于数据流的技术："></a>基于数据流的技术：</h4><ul><li>数据流图DFD</li><li>数据字典DD</li><li>系统流程图</li></ul><h4 id="描述银行取款过程的数据流图"><a href="#描述银行取款过程的数据流图" class="headerlink" title="描述银行取款过程的数据流图"></a>描述银行取款过程的数据流图</h4><img src="/posts/46806/数据流图1.png" alt="数据流图1" style="zoom:50%;"><h4 id="学生管理系统-数据字典-数据流"><a href="#学生管理系统-数据字典-数据流" class="headerlink" title="学生管理系统-数据字典-数据流"></a>学生管理系统-数据字典-数据流</h4><img src="/posts/46806/学生管理系统.png" alt="学生管理系统" style="zoom:50%;"><h3 id="2-3-基于UML方法"><a href="#2-3-基于UML方法" class="headerlink" title="2.3 基于UML方法"></a>2.3 基于UML方法</h3><ul><li>基于面向对象的情景分析方法</li><li>从用户角度出发考虑的功能需求</li><li>用例是系统向用户提供一个有价值的结果的某项功能</li></ul><h4 id="UML需求视图"><a href="#UML需求视图" class="headerlink" title="UML需求视图"></a>UML需求视图</h4><ul><li>用例视图Use case Diagram</li><li>顺序图 Sequence Diagram</li><li>状态图 State Diagram</li><li>活动图 Activity Diagram</li></ul><h4 id="基于UML方法综述"><a href="#基于UML方法综述" class="headerlink" title="基于UML方法综述"></a>基于UML方法综述</h4><ul><li>识别出系统的Actor</li><li>描述需要的Use case</li><li>实现用例视图</li><li>实现顺序视图、活动视图、状态视图等</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第三章</title>
      <link href="/posts/55319.html"/>
      <url>/posts/55319.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-软件生存期模型"><a href="#第三章-软件生存期模型" class="headerlink" title="第三章 软件生存期模型"></a>第三章 软件生存期模型</h1><p>本章要点：</p><ul><li>生存期模型选择</li><li>预测模型</li><li>迭代模型</li><li>增量模型</li><li>敏捷模型</li><li>混合模型</li><li>案例分析</li></ul><h2 id="1-生存期模型选择"><a href="#1-生存期模型选择" class="headerlink" title="1.生存期模型选择"></a>1.生存期模型选择</h2><h3 id="1-1-软件开发模型变迁"><a href="#1-1-软件开发模型变迁" class="headerlink" title="1.1 软件开发模型变迁"></a>1.1 软件开发模型变迁</h3><ul><li>作坊式</li><li>过程控制</li><li>敏捷</li><li>DevOps</li></ul><h3 id="1-2-项目生存期选择"><a href="#1-2-项目生存期选择" class="headerlink" title="1.2 项目生存期选择"></a>1.2 项目生存期选择</h3><ul><li>预测型<ul><li>提前进行大量的计划工作</li><li>然后一次性执行</li><li>执行是一个连续的过程</li></ul></li><li>迭代型<ul><li>允许对未完成的工作进行反馈</li><li>从而改进和修改该工作</li></ul></li><li>增量型：<ul><li>向客户提供各个已完成的，可能立即使用的可交付成果</li></ul></li><li>敏捷型：<ul><li>既有迭代、也有增量</li><li>便于完善工作，频繁交付</li></ul></li></ul><h2 id="2-预测模型"><a href="#2-预测模型" class="headerlink" title="2. 预测模型"></a>2. 预测模型</h2><img src="/posts/55319/预测模型.png" alt="预测模型" style="zoom:50%;"><h3 id="2-1-预测型-模型"><a href="#2-1-预测型-模型" class="headerlink" title="2.1 预测型-模型"></a>2.1 预测型-模型</h3><ul><li>瀑布模型</li><li>V模型</li></ul><h3 id="2-2-瀑布模型"><a href="#2-2-瀑布模型" class="headerlink" title="2.2 瀑布模型"></a>2.2 瀑布模型</h3><img src="/posts/55319/瀑布模型.png" alt="瀑布模型" style="zoom:50%;"><h4 id="适合瀑布模型的项目特征："><a href="#适合瀑布模型的项目特征：" class="headerlink" title="适合瀑布模型的项目特征："></a>适合瀑布模型的项目特征：</h4><ul><li>需求很明确</li><li>方案很明确</li><li>类似项目 ：短期项目等</li></ul><h3 id="2-3-V模型"><a href="#2-3-V模型" class="headerlink" title="2.3 V模型"></a>2.3 V模型</h3><img src="/posts/55319/v模型.png" alt="v模型" style="zoom:50%;"><h4 id="适合v模型的项目特征"><a href="#适合v模型的项目特征" class="headerlink" title="适合v模型的项目特征"></a>适合v模型的项目特征</h4><ul><li>需求很明确</li><li>方案很明确</li><li>类似项目 系统性能、安全等有严格要求等</li></ul><h2 id="3-迭代模型"><a href="#3-迭代模型" class="headerlink" title="3.迭代模型"></a>3.迭代模型</h2><img src="/posts/55319/迭代模型.png" alt="迭代模型" style="zoom:50%;"><h3 id="3-1-OR-原型模型"><a href="#3-1-OR-原型模型" class="headerlink" title="3.1 OR 原型模型"></a>3.1 OR 原型模型</h3><img src="/posts/55319/原型模型.png" alt="原型模型" style="zoom:50%;"><h3 id="3-2-适合迭代模型的项目特征"><a href="#3-2-适合迭代模型的项目特征" class="headerlink" title="3.2 适合迭代模型的项目特征"></a>3.2 适合迭代模型的项目特征</h3><ul><li><p>需求不明确</p></li><li><p>项目复杂性高</p></li><li><p>项目变更频繁</p></li></ul><h2 id="4-增量模型"><a href="#4-增量模型" class="headerlink" title="4.增量模型"></a>4.增量模型</h2><img src="/posts/55319/增量模型.png" alt="增量模型" style="zoom:50%;"><h3 id="4-1-渐进式阶段模型"><a href="#4-1-渐进式阶段模型" class="headerlink" title="4.1 渐进式阶段模型"></a>4.1 渐进式阶段模型</h3><img src="/posts/55319/渐进式.png" alt="渐进式" style="zoom:50%;"><h3 id="4-2-增量模型的优点"><a href="#4-2-增量模型的优点" class="headerlink" title="4.2 增量模型的优点"></a>4.2 增量模型的优点</h3><ul><li>阶段式提交一个可运行的产品</li><li>关键的功能更早出现</li><li>早期预警问题，避免缺陷蔓延</li><li>阶段性完成可以降低估计失误</li></ul><h2 id="5-敏捷模型"><a href="#5-敏捷模型" class="headerlink" title="5.敏捷模型"></a>5.敏捷模型</h2><h3 id="5-1-《敏捷宣言》价值观、原则和通用实践之间的关系"><a href="#5-1-《敏捷宣言》价值观、原则和通用实践之间的关系" class="headerlink" title="5.1 《敏捷宣言》价值观、原则和通用实践之间的关系"></a>5.1 《敏捷宣言》价值观、原则和通用实践之间的关系</h3><img src="/posts/55319/敏捷宣言关系.png" alt="敏捷宣言关系" style="zoom:50%;"><h3 id="5-2-敏捷与传统模型的区别"><a href="#5-2-敏捷与传统模型的区别" class="headerlink" title="5.2 敏捷与传统模型的区别"></a>5.2 敏捷与传统模型的区别</h3><img src="/posts/55319/敏捷区别.png" alt="敏捷区别" style="zoom:50%;"><h3 id="5-3-敏捷方法"><a href="#5-3-敏捷方法" class="headerlink" title="5.3 敏捷方法"></a>5.3 敏捷方法</h3><ul><li>敏捷方法：<ul><li>是一个囊括了各种框架和方法的涵盖性术语</li></ul></li></ul><h3 id="5-4-Scrum模型"><a href="#5-4-Scrum模型" class="headerlink" title="5.4 Scrum模型"></a>5.4 Scrum模型</h3><ul><li>1990年代初，肯施瓦伯在其公司使用了一种方法：<ul><li>Advanced Development Methods</li><li>先进开发方法</li></ul></li><li>这种方法后来发展为Scrum</li><li>敏捷模型的代表</li></ul><h3 id="5-5-迭代开发过程"><a href="#5-5-迭代开发过程" class="headerlink" title="5.5 迭代开发过程"></a>5.5 迭代开发过程</h3><img src="/posts/55319/迭代开发过程.png" alt="迭代开发过程" style="zoom:50%;"><h3 id="5-6-XP极限编程模型"><a href="#5-6-XP极限编程模型" class="headerlink" title="5.6 XP极限编程模型"></a>5.6 XP极限编程模型</h3><ul><li>Extreme Programming</li><li>是由Kent Beck提出的<ul><li>一套针对业务需求和软件开发实践的规则</li></ul></li></ul><h3 id="5-7-精益-Lean"><a href="#5-7-精益-Lean" class="headerlink" title="5.7 精益 Lean"></a>5.7 精益 Lean</h3><ul><li>精益模式<ul><li>提倡持续不断地改进</li><li>减少流程中的浪费</li></ul></li></ul><h3 id="5-8-持续交付"><a href="#5-8-持续交付" class="headerlink" title="5.8 持续交付"></a>5.8 持续交付</h3><ul><li>持续集成</li><li>持续部署</li><li>持续交付</li></ul><h3 id="5-9-DevOps"><a href="#5-9-DevOps" class="headerlink" title="5.9 DevOps"></a>5.9 DevOps</h3><ul><li>Development和Operation的组合</li><li>全程敏捷思维</li><li>开发与运维工作紧密合作</li><li>融合一系列基本原则和实践的方法论</li><li>是<ul><li>一种方法论</li><li>是一组过程、方法与系统的统称</li><li>用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合</li></ul></li></ul><h3 id="5-10-DevCloud"><a href="#5-10-DevCloud" class="headerlink" title="5.10 DevCloud"></a>5.10 DevCloud</h3><ul><li>一站式云端DevOps</li></ul><h2 id="6-混合模型"><a href="#6-混合模型" class="headerlink" title="6.混合模型"></a>6.混合模型</h2><img src="/posts/55319/混合模型.png" alt="混合模型" style="zoom:50%;"><h3 id="6-1-MED生存期模型-敏捷模型"><a href="#6-1-MED生存期模型-敏捷模型" class="headerlink" title="6.1 MED生存期模型-敏捷模型"></a>6.1 MED生存期模型-敏捷模型</h3><img src="/posts/55319/MED.png" alt="MED" style="zoom:50%;"><h3 id="6-2-四个迭代"><a href="#6-2-四个迭代" class="headerlink" title="6.2 四个迭代"></a>6.2 四个迭代</h3><img src="/posts/55319/四个迭代.png" alt="四个迭代" style="zoom:50%;"><h3 id="6-3-迭代模型"><a href="#6-3-迭代模型" class="headerlink" title="6.3 迭代模型"></a>6.3 迭代模型</h3><img src="/posts/55319/迭代模型1.png" alt="迭代模型1" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第二章</title>
      <link href="/posts/54382.html"/>
      <url>/posts/54382.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-软件项目确立"><a href="#第二章-软件项目确立" class="headerlink" title="第二章 软件项目确立"></a>第二章 软件项目确立</h1><p>本章要点：</p><ul><li>项目立项</li><li>项目招投标</li><li>项目章程</li><li>案例总结</li></ul><h2 id="1-项目立项"><a href="#1-项目立项" class="headerlink" title="1.项目立项"></a>1.项目立项</h2><h3 id="1-1-项目启动背景"><a href="#1-1-项目启动背景" class="headerlink" title="1.1 项目启动背景"></a>1.1 项目启动背景</h3><ul><li>符合法规、法律或社会要求</li><li>满足相关方的要求或需求</li><li>创造、改进或修复产品、过程或服务</li><li>执行、变更业务或技术战略</li></ul><h3 id="1-2-立项流程"><a href="#1-2-立项流程" class="headerlink" title="1.2 立项流程"></a>1.2 立项流程</h3><ul><li>开始</li><li>识别发起的项目</li><li>论证项目</li><li>申请项目</li><li>申请审核<ul><li>通过<ul><li>确定项目立项</li></ul></li><li>不通过<ul><li>取消项目立项</li></ul></li><li>立项审查报告</li></ul></li><li>结束</li></ul><h3 id="1-3-项目立项"><a href="#1-3-项目立项" class="headerlink" title="1.3 项目立项"></a>1.3 项目立项</h3><ul><li>定义：<ul><li>明确<ul><li>项目的目标、时间表、</li><li>项目使用的资源和经费</li></ul></li><li>而且得到执行该项目的项目经理和项目发起人的认可</li></ul></li><li>包含：<ul><li>目标</li><li>费用</li><li>时间</li></ul></li></ul><h2 id="2-项目招投标"><a href="#2-项目招投标" class="headerlink" title="2. 项目招投标"></a>2. 项目招投标</h2><h3 id="2-1-项目招投标过程"><a href="#2-1-项目招投标过程" class="headerlink" title="2.1 项目招投标过程"></a>2.1 项目招投标过程</h3><ul><li>甲方招标书定义</li><li>乙方项目分析</li><li>招标与竞标</li><li>合同签署</li></ul><h2 id="3-项目章程"><a href="#3-项目章程" class="headerlink" title="3.项目章程"></a>3.项目章程</h2><h3 id="3-1-项目章程定义"><a href="#3-1-项目章程定义" class="headerlink" title="3.1 项目章程定义"></a>3.1 项目章程定义</h3><ul><li>Project Charter</li><li>确定项目存在的文件<ul><li>包括对项目的确认</li><li>对项目经理的授权</li><li>和项目目标的概述等</li></ul></li></ul><h3 id="3-2-敏捷项目章程"><a href="#3-2-敏捷项目章程" class="headerlink" title="3.2 敏捷项目章程"></a>3.2 敏捷项目章程</h3><ul><li>基本要素：<ul><li>项目目标</li><li>发布标准</li><li>预期的工作流</li></ul></li></ul><h3 id="3-3-项目经理的职责"><a href="#3-3-项目经理的职责" class="headerlink" title="3.3 项目经理的职责"></a>3.3 项目经理的职责</h3><ul><li>项目经理是领导团队实现项目目标的个人</li><li>敏捷强调：<ul><li>仆人式领导方式</li></ul></li></ul><h3 id="3-4-项目经理的能力"><a href="#3-4-项目经理的能力" class="headerlink" title="3.4 项目经理的能力"></a>3.4 项目经理的能力</h3><ul><li>PMI人才三角<ul><li>技术项目管理</li><li>领导力</li><li>战略和商务管理</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第一章</title>
      <link href="/posts/17428.html"/>
      <url>/posts/17428.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-软件项目管理概述"><a href="#第一章-软件项目管理概述" class="headerlink" title="第一章 软件项目管理概述"></a>第一章 软件项目管理概述</h1><p>本章要点：</p><ul><li>项目与软件项目</li><li>项目管理与软件项目管理</li><li>PMBOK与软件项目管理体系</li><li>敏捷项目管理</li><li>软件项目管理过程</li></ul><h2 id="1-项目与软件项目"><a href="#1-项目与软件项目" class="headerlink" title="1.项目与软件项目"></a>1.项目与软件项目</h2><h3 id="项目的定义"><a href="#项目的定义" class="headerlink" title="项目的定义"></a>项目的定义</h3><p>项目project</p><ul><li>是为了<ul><li>创造一个 <strong>唯一</strong> 的产品</li><li>或提供一个唯一的服务<ul><li>而进行的 <strong>临时性</strong> 的努力</li></ul></li></ul></li></ul><h3 id="项目的特征"><a href="#项目的特征" class="headerlink" title="项目的特征"></a>项目的特征</h3><ul><li>有明确的目标</li><li>项目之间的活动具有相关性</li><li>限定的周期</li><li>有独特性</li><li>资源成本的约束性</li><li>项目的不确定性</li></ul><h3 id="项目与日常运作"><a href="#项目与日常运作" class="headerlink" title="项目与日常运作"></a>项目与日常运作</h3><ul><li>项目：<ul><li>野餐活动</li><li>集体婚礼</li><li>开发操作系统</li><li>神舟飞船计划</li></ul></li><li>日常运作<ul><li>上课</li><li>社区保安</li><li>每天的卫生保洁</li></ul></li></ul><h3 id="项目集-programs与项目-project"><a href="#项目集-programs与项目-project" class="headerlink" title="项目集 programs与项目 project"></a>项目集 programs与项目 project</h3><ul><li><p>项目组合管理 portfolio</p><ul><li><p>eg：承办奥运会</p></li><li><p>项目集 Programs</p><ul><li><p>eg：奥运体育馆建设</p></li><li><p>项目 project</p><ul><li><p>eg：游泳馆建设</p></li><li><p>子项目</p><ul><li>eg：游泳池建造</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="软件项目的特殊性"><a href="#软件项目的特殊性" class="headerlink" title="软件项目的特殊性"></a>软件项目的特殊性</h3><ul><li>逻辑实体</li><li>相互作用的系统</li><li>渐进明细</li><li>变更</li></ul><h2 id="2-项目管理与软件项目管理"><a href="#2-项目管理与软件项目管理" class="headerlink" title="2.项目管理与软件项目管理"></a>2.项目管理与软件项目管理</h2><h3 id="2-1-项目管理背景"><a href="#2-1-项目管理背景" class="headerlink" title="2.1 项目管理背景"></a>2.1 项目管理背景</h3><ul><li>生活中的小项目：<ul><li>生日聚会</li><li>野餐活动</li><li>集体婚礼</li></ul></li><li>工作中的大项目<ul><li>微软的操作系统</li><li>阿波罗计划</li><li>神舟飞船计划</li></ul></li></ul><h3 id="2-2-项目管理定义"><a href="#2-2-项目管理定义" class="headerlink" title="2.2 项目管理定义"></a>2.2 项目管理定义</h3><ul><li>项目管理<ul><li>是一系列的 伴随着项目的进行而进行的</li><li>目的是 为了确保项目能达到期望的结果的</li><li>一系列管理行为</li></ul></li></ul><h3 id="2-3-软件项目管理"><a href="#2-3-软件项目管理" class="headerlink" title="2.3 软件项目管理"></a>2.3 软件项目管理</h3><ul><li>是软件工程组成部分</li><li>确保软件项目满足预算、成本等约束<ul><li>提交高质量软件产品</li></ul></li></ul><h2 id="3-PMBOK与软件项目管理体系"><a href="#3-PMBOK与软件项目管理体系" class="headerlink" title="3.PMBOK与软件项目管理体系"></a>3.PMBOK与软件项目管理体系</h2><h3 id="3-1-PMBOK"><a href="#3-1-PMBOK" class="headerlink" title="3.1 PMBOK"></a>3.1 PMBOK</h3><ul><li>A guide to the Project management Body Of Knowledge</li><li>项目管理知识体系指南</li></ul><h4 id="PMI："><a href="#PMI：" class="headerlink" title="PMI："></a>PMI：</h4><ul><li>对项目管理所需的知识、技能和工具进行的概括性描述</li></ul><h3 id="3-2-PMBOK体系图"><a href="#3-2-PMBOK体系图" class="headerlink" title="3.2 PMBOK体系图"></a>3.2 PMBOK体系图</h3><img src="/posts/17428/体系图.png" alt="体系图" style="zoom:50%;"><h3 id="3-3-项目管理五大过程组"><a href="#3-3-项目管理五大过程组" class="headerlink" title="3.3 项目管理五大过程组"></a>3.3 项目管理五大过程组</h3><ul><li><img src="/posts/17428/五大过程.png" alt="五大过程" style="zoom:50%;"></li></ul><h2 id="4-敏捷项目管理"><a href="#4-敏捷项目管理" class="headerlink" title="4.敏捷项目管理"></a>4.敏捷项目管理</h2><h3 id="4-1-软件项目很特殊"><a href="#4-1-软件项目很特殊" class="headerlink" title="4.1 软件项目很特殊"></a>4.1 软件项目很特殊</h3><ul><li>脑力成果</li><li>唯一性（一次性）</li><li>依赖用户需求</li></ul><h3 id="4-2-传统软件开发面临挑战"><a href="#4-2-传统软件开发面临挑战" class="headerlink" title="4.2 传统软件开发面临挑战"></a>4.2 传统软件开发面临挑战</h3><ul><li>低质量</li><li>特性无法被测试</li><li>使用性与用户经历不好</li><li>花费过高</li><li>团队不交流合作</li><li>过多新手，缺乏技术</li><li>过多文件</li><li>不能很好维持</li></ul><h3 id="4-3-敏捷模型-Agile-Development"><a href="#4-3-敏捷模型-Agile-Development" class="headerlink" title="4.3 敏捷模型 Agile Development"></a>4.3 敏捷模型 Agile Development</h3><ul><li>敏捷组织提出的一个灵活开发方法</li><li>应对迅速变化需求的快速软件开发方法</li><li>是一种迭代、循序渐进的开发方法</li></ul><h3 id="4-4-敏捷开发过程"><a href="#4-4-敏捷开发过程" class="headerlink" title="4.4 敏捷开发过程"></a>4.4 敏捷开发过程</h3><ul><li>一开始都不知道细节</li><li>慢慢改进</li></ul><h3 id="4-5-敏捷宣言-四价值"><a href="#4-5-敏捷宣言-四价值" class="headerlink" title="4.5 敏捷宣言 四价值"></a>4.5 敏捷宣言 四价值</h3><ul><li>个体和互动<ul><li>高于 流程和工具</li></ul></li><li>可工作的软件<ul><li>高于 详尽的文档</li></ul></li><li>客户合作<ul><li>高于 合同谈判</li></ul></li><li>响应变化<ul><li>高于 遵循计划</li></ul></li></ul><h3 id="4-6-敏捷原则-Principles"><a href="#4-6-敏捷原则-Principles" class="headerlink" title="4.6 敏捷原则 Principles"></a>4.6 敏捷原则 Principles</h3><ul><li>我们最先要做的是通过尽早地、持续交付有价值的软件来使客户满意</li><li>即使到了开发后期，也欢迎改变需求。敏捷过程利用适应变化来为客户创造竞争优势</li><li>经常性地交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好</li><li>在整个项目开发期间，业务人员和开发人员可以的话尽可能在一起工作</li></ul><h3 id="4-7-《敏捷宣言》价值观、原则和通用实践之间的关系"><a href="#4-7-《敏捷宣言》价值观、原则和通用实践之间的关系" class="headerlink" title="4.7 《敏捷宣言》价值观、原则和通用实践之间的关系"></a>4.7 《敏捷宣言》价值观、原则和通用实践之间的关系</h3><ul><li>敏捷是一种思维模式</li><li>它由《敏捷宣言》的价值观所界定</li><li>受《敏捷宣言》原则指导</li><li>并通过各种实践实现</li></ul><h2 id="5-软件项目管理过程"><a href="#5-软件项目管理过程" class="headerlink" title="5.软件项目管理过程"></a>5.软件项目管理过程</h2><h3 id="5-1-项目管理过程"><a href="#5-1-项目管理过程" class="headerlink" title="5.1 项目管理过程"></a>5.1 项目管理过程</h3><ul><li>项目初始</li><li>项目计划</li><li>项目执行控制</li><li>项目结束</li></ul><h3 id="5-2-软件项目管理过程"><a href="#5-2-软件项目管理过程" class="headerlink" title="5.2 软件项目管理过程"></a>5.2 软件项目管理过程</h3><ul><li>项目初始</li><li>项目计划</li><li>项目执行控制</li><li>项目结束</li></ul><h4 id="5-2-1-项目初始"><a href="#5-2-1-项目初始" class="headerlink" title="5.2.1 项目初始"></a>5.2.1 项目初始</h4><ul><li>项目确立</li><li>生存期</li></ul><h4 id="5-2-2-项目计划"><a href="#5-2-2-项目计划" class="headerlink" title="5.2.2 项目计划"></a>5.2.2 项目计划</h4><ul><li>范围计划</li><li>成本计划</li><li>进度计划</li><li>质量计划</li><li>配置管理计划</li><li>团队计划</li><li>风险计划</li><li>合同计划</li></ul><h4 id="5-2-3-项目执行控制"><a href="#5-2-3-项目执行控制" class="headerlink" title="5.2.3 项目执行控制"></a>5.2.3 项目执行控制</h4><ul><li>集成计划执行控制</li><li>核心计划执行控制</li><li>辅助计划执行控制</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter的第一个实验</title>
      <link href="/posts/12105.html"/>
      <url>/posts/12105.html</url>
      
        <content type="html"><![CDATA[<p>首先打开jmeter文件夹内bin目录下的 <code>jmeter.bat</code>  从而运行jmeter程序</p><p>再在jmeter中 <code>open file</code>,打开实验要运行的文件， <code>first test plan</code></p><p><img src="/posts/12105/1.png" alt="1"></p><p><code>comment</code>：注释</p><p>刚创立test plan时内部是空的，在设置完名称和注释之后先记得把这个test plan保存</p><p>保存完后，为了利用这个test plan做些东西，就要 add something</p><p>即：</p><ul><li>右键first test plan</li><li>add</li><li>Threads（Users）</li><li>Thread Group<ul><li>即成功添加第一个线程组</li></ul></li></ul><p>但是添加完这个线程组之后还是做不了什么事情，要再在 <code>thread group</code>里 添加一些设置</p><ul><li><p>点击thread group:</p><p><img src="/posts/12105/2.png" alt="2"></p></li><li><p><code>Number of Threads(users)</code>:</p><ul><li>即需要多少线程 或者可以说虚拟用户</li></ul></li><li><p><code>Ramp-up period</code>：</p><ul><li>即这些用户用多久时间生成</li></ul></li><li><p><code>Loop count</code>:</p><ul><li>即循环次数</li></ul></li></ul><p>因为这个test plan意图访问web系统的界面类</p><p>我们不直接对界面进行操作，而是对接口发送请求</p><p>在jmeter中，所有的请求要发出去，都要用到 <code>Add</code>里面的 <code>Sampler</code>(采样器)  </p><p>其中有许多采样器，我们这个实验中使用 <code>Http request</code></p><p>其中设置好名称和网址，如图：</p><p><img src="/posts/12105/3.png" alt="3"></p><ul><li><code>port number</code><ul><li>端口号<ul><li>如果使用默认端口，可以不填</li></ul></li></ul></li><li><code>path</code><ul><li>路径</li><li>因为这里是要访问首页，所以不需要填路径</li></ul></li></ul><p>经过以上操作，我们已经有了一个可以发请求的采样器，现在可以来跑一下。</p><p>但是虽然这时候已经可以跑了，但是结果我们看不到</p><p>因此，需要增加 <code>listener</code>来查看结果</p><ul><li>右键Thread Group</li><li><code>add</code></li><li><code>listener</code></li><li>选择 <code>view results tree</code></li></ul><p>加上之后即可选择start，开始测试，并得到结果</p><p>如果要清除listener，即可选择右上角 <code>clear all</code>   （如果只是清掉当前的view result tree，按clear即可）</p><p>我们查看view result tree里面详情，可以看到一次httprequest包含了两次请求</p><p>这是因为被重定向了</p><p><img src="/posts/12105/4.png" alt="4"></p><p>通过以上操作，我们明白了这样添加线程组并运行</p><p>但我们也要知道，实际操作中还需要添加<code>Config element</code></p><ul><li><code>add</code></li><li><code>config element</code></li><li><code>Http request defaults</code></li></ul><p><img src="/posts/12105/5.png" alt="5"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言学 第一章</title>
      <link href="/posts/17942.html"/>
      <url>/posts/17942.html</url>
      
        <content type="html"><![CDATA[<h2 id="语言学分类-按研究对象分"><a href="#语言学分类-按研究对象分" class="headerlink" title="语言学分类-按研究对象分"></a>语言学分类-按研究对象分</h2><ul><li>linguistics<ul><li>Theoretical Ling</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语语言学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组 第一章 绪论</title>
      <link href="/posts/7573.html"/>
      <url>/posts/7573.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-计算机的发展史"><a href="#1-1-计算机的发展史" class="headerlink" title="1.1 计算机的发展史"></a>1.1 计算机的发展史</h2><h3 id="1-1-1-计算简史"><a href="#1-1-1-计算简史" class="headerlink" title="1.1.1 计算简史"></a>1.1.1 计算简史</h3><h4 id="人类创造工具"><a href="#人类创造工具" class="headerlink" title="人类创造工具"></a>人类创造工具</h4><ul><li>机械工具</li><li>测试工具</li><li>计算工具</li></ul><h4 id="计算经历阶段"><a href="#计算经历阶段" class="headerlink" title="计算经历阶段"></a>计算经历阶段</h4><ul><li><p>手工计算</p></li><li><p>机械计算</p></li><li><p>电子计算</p></li></ul><h4 id="手工计算阶段"><a href="#手工计算阶段" class="headerlink" title="手工计算阶段"></a>手工计算阶段</h4><h5 id="计数工具"><a href="#计数工具" class="headerlink" title="计数工具"></a>计数工具</h5><ul><li>穴石、绳结、刻痕</li><li>十指</li><li>算盘<ul><li>应用时间最长</li><li>功能最完善</li><li>非自然化计数工具</li></ul></li><li>计算尺<ul><li>用长度模拟数值大小</li><li>可进行一些四则运算和复杂非四则运算</li></ul></li></ul><h5 id="计数法："><a href="#计数法：" class="headerlink" title="计数法："></a>计数法：</h5><ul><li>十进制<ul><li>是数学体系计数制基础</li></ul></li></ul><h5 id="口诀："><a href="#口诀：" class="headerlink" title="口诀："></a>口诀：</h5><ul><li>基本操作指令</li><li>算盘指令系统、珠算语言</li></ul><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li>人的技能水平、精力、智力影响计算速度、正确性</li><li>无法进行大的复杂运算</li></ul><h4 id="机械计算阶段"><a href="#机械计算阶段" class="headerlink" title="机械计算阶段"></a>机械计算阶段</h4><ul><li><p>pascal[法]</p><ul><li>1642年</li><li>可做成加减法的机械计算起</li></ul></li><li><p>Leibnitz[德]</p><ul><li>1673年</li><li>改进pascal设计</li><li>增加乘除运算</li></ul></li><li><p>19世纪</p><ul><li>手摇计算机商品化生产</li></ul></li><li><p>Babbage[英]  计算机之父</p><ul><li>首先提出整个计算过程自动化概念</li><li>设计第一台通用自动时序控制机械式计算机<ul><li>但未能制造出来</li></ul></li><li>认为自动计算机必须有五大功能<ul><li>输入</li><li>输出</li><li>处理</li><li>存储</li><li>控制</li></ul></li><li>提出计算机实现自动计算的前提<ul><li>具有记忆功能</li><li>能记住数据和要进行的步骤</li><li>并按步骤规定对机器进行自动控制</li></ul></li></ul></li><li><p>缺陷</p><ul><li>频繁的人工干预限制计算速度提高</li></ul></li></ul><h4 id="电子计算阶段"><a href="#电子计算阶段" class="headerlink" title="电子计算阶段"></a>电子计算阶段</h4><h5 id="电子计算"><a href="#电子计算" class="headerlink" title="电子计算"></a>电子计算</h5><ul><li>理论基础：<ul><li>二进制<ol><li>中国最早使用</li><li>阳爻-&gt;1  阴爻-&gt;0</li></ol></li></ul></li></ul><h5 id="George-Boole-英"><a href="#George-Boole-英" class="headerlink" title="George Boole [英]"></a>George Boole [英]</h5><ul><li><p>发表：</p><ul><li>《逻辑的数学分析》</li><li>《思维规律的研究》<ul><li>两本书核心：<ul><li>现代《布尔代数》精髓</li></ul></li></ul></li></ul></li><li><p>把运算和逻辑理论建立在</p><ul><li>0和1两种数值</li><li>”与“”或“”非“三种基本逻辑运算</li></ul></li><li><p>是现代数字式设备理论基础</p></li></ul><h5 id="V-Atanasolf-美-伊阿华大学"><a href="#V-Atanasolf-美-伊阿华大学" class="headerlink" title="V.Atanasolf 美 伊阿华大学"></a>V.Atanasolf 美 伊阿华大学</h5><ul><li><p>首次</p><ul><li>使用电子原件</li><li>按二进制原理<ul><li>制造一台电子管计算机</li></ul></li></ul></li><li><p>在Cliffod Berry协助下</p><ul><li>制造出一台电子管计算机Atanasoff Berry Computer</li></ul></li></ul><h5 id="ENIAC-Electronic-Numerical-Integrator-and-Computer"><a href="#ENIAC-Electronic-Numerical-Integrator-and-Computer" class="headerlink" title="ENIAC Electronic Numerical Integrator and Computer"></a>ENIAC Electronic Numerical Integrator and Computer</h5><ul><li>地位：<ul><li>世界上第一台电子数字计算机（试运行：1945）</li><li>现代电子数字计算机始祖</li></ul></li><li>大小：<ul><li>高8英尺 长100英尺 宽3英尺 </li><li>18000个真空管 1500个电子继电器</li><li>18000个电容 70000个电阻</li><li>重30吨</li></ul></li><li>计算：<ul><li>弹道计算：<ul><li>60s射程弹道计算为30s</li></ul></li><li>性能：<ul><li>不高<ul><li>5000次加法运算</li><li>50次乘法运算</li></ul></li><li>每秒可进行<ul><li>平方</li><li>立方</li><li>sin</li><li>cos<ul><li>数值运算</li></ul></li></ul></li></ul></li><li>其他领域<ul><li>eg：<ul><li>天气预报</li><li>原子核能</li><li>风洞试验</li></ul></li><li>关于原子裂变的能量计算<ul><li>冯诺依曼邀请</li><li>促进世界第一颗原子弹问世</li></ul></li></ul></li><li>圆周率计算（1949）<ul><li>70小时，计算至小数点后2037位</li><li>人类第一次用机器算的最精确圆周率数值</li></ul></li></ul></li><li>1955年 退休</li></ul><h5 id="EDSAC-英-剑桥"><a href="#EDSAC-英-剑桥" class="headerlink" title="EDSAC [英 剑桥]"></a>EDSAC [英 剑桥]</h5><ul><li>Electronic Delay Storage Automatic Computer<ul><li>世界上第一台通用电子数字计算机<ul><li>人类开始进入电子数字计算机时代</li></ul></li></ul></li></ul><h3 id="1-1-2-计算机发展简史"><a href="#1-1-2-计算机发展简史" class="headerlink" title="1.1.2 计算机发展简史"></a>1.1.2 计算机发展简史</h3><h4 id="经历4代："><a href="#经历4代：" class="headerlink" title="经历4代："></a>经历4代：</h4><ul><li>第一代计算机 20世纪40代中-50末</li><li>第二代计算机 20世纪50中后-60中</li><li>第三代计算机 20世纪60中-70中</li><li>第四代计算机 20世纪70中-今</li></ul><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><ul><li><p>电子器件</p><ul><li>是划分时代最重要标志</li></ul></li></ul><h4 id="第一代计算机：电子管计算机"><a href="#第一代计算机：电子管计算机" class="headerlink" title="第一代计算机：电子管计算机"></a>第一代计算机：电子管计算机</h4><ul><li>逻辑元件：<ul><li>电子管</li></ul></li><li>主存储器：<ul><li>阴极射线管</li><li>声泵延迟线</li><li>磁带、磁鼓</li></ul></li><li>数据表示<ul><li>定点表示</li></ul></li><li>编程语言：<ul><li>机器语言</li><li>汇编语言</li></ul></li><li>机器：<ul><li>ENIAC\EDSCAC</li><li>冯诺依曼为首研制的存储程序计算机<ul><li>IAS</li><li>UNIVAC-1</li><li>IBM 704</li></ul></li><li>我国自己研制的第一代计算机<ul><li>主要<ul><li>104机</li><li>103机</li><li>119机</li></ul></li></ul></li></ul></li></ul><h4 id="第二代计算机：晶体管计算机"><a href="#第二代计算机：晶体管计算机" class="headerlink" title="第二代计算机：晶体管计算机"></a>第二代计算机：晶体管计算机</h4><ul><li><h5 id="逻辑元件："><a href="#逻辑元件：" class="headerlink" title="逻辑元件："></a>逻辑元件：</h5><ul><li>晶体管</li></ul></li><li><p>主存储器元件：</p><ul><li>磁芯</li></ul></li><li><p>运算：</p><ul><li>引入浮点运算硬件</li></ul></li><li><p>建立：</p><ul><li>子程序库</li><li>批处理管理程序</li></ul></li><li><p>语言：</p><ul><li>FORTRAN</li><li>COBOL</li><li>ALGOL<ul><li>等高级语言<ul><li>简化了程序设计</li></ul></li></ul></li></ul></li><li><p>优点：</p><ul><li>体积小</li><li>功耗快</li><li>速度快</li><li>可靠性高</li></ul></li><li><p>机器：</p><ul><li>国外：<ul><li>IBM 7040,7070,7090</li><li>CDC 1604</li></ul></li><li>国内：<ul><li>109机</li><li>441B机</li><li>108机</li></ul></li></ul></li></ul><h4 id="第三代计算机"><a href="#第三代计算机" class="headerlink" title="第三代计算机"></a>第三代计算机</h4><ul><li>基础器件：<ul><li>集成电路<ul><li>微电子技术与计算机技术相结合的一大突破</li></ul></li></ul></li><li>电路：<ul><li>采用<ul><li>小规模</li><li>中规模<ul><li>集成电路</li></ul></li></ul></li></ul></li><li>存储器：<ul><li>半导体存储器</li></ul></li><li>改进：<ul><li>引进多道程序和并行处理等新的技术</li><li>操作系统日趋成熟</li></ul></li><li>机器：<ul><li>国外：<ul><li>IBM 360系列</li><li>CDC 6600/7600系列</li><li>CYBER系列</li></ul></li><li>国产:<ul><li>150,151<ul><li>DJS-2000系列</li><li>DJS-1000系列</li></ul></li></ul></li></ul></li></ul><h4 id="第四代计算机"><a href="#第四代计算机" class="headerlink" title="第四代计算机"></a>第四代计算机</h4><ul><li>电路：<ul><li>大规模集成电路</li><li>超大规模集成电路</li></ul></li><li>改进：<ul><li>技术：<ul><li>并行处理</li><li>多机系统</li><li>分布式计算机</li><li>计算机网络<ul><li>等技术飞速发展</li></ul></li></ul></li><li>机器：<ul><li>微处理机、微型计算机<ul><li>迅速发展</li></ul></li><li>小型机、超级小型机、大型机、巨型机<ul><li>不断问世</li></ul></li></ul></li></ul></li></ul><h2 id="1-2-计算机系统组成"><a href="#1-2-计算机系统组成" class="headerlink" title="1.2 计算机系统组成"></a>1.2 计算机系统组成</h2><h3 id="1-2-1-存储程序原理"><a href="#1-2-1-存储程序原理" class="headerlink" title="1.2.1 存储程序原理"></a>1.2.1 存储程序原理</h3><h4 id="《关于电子计算装置逻辑结果初探》"><a href="#《关于电子计算装置逻辑结果初探》" class="headerlink" title="《关于电子计算装置逻辑结果初探》"></a>《关于电子计算装置逻辑结果初探》</h4><ul><li>美籍匈牙利数学家 冯诺依曼</li><li>所阐述思想构建了<ul><li>现代电子计算机的组成原理</li></ul></li><li>提出了<ul><li>以存储程序为核心的通用电子数字计算机体系结构原理</li></ul></li><li>奠定了<ul><li>当代电子计算机体系结构的基础</li></ul></li></ul><h4 id="“存储程序计算机”："><a href="#“存储程序计算机”：" class="headerlink" title="“存储程序计算机”："></a>“存储程序计算机”：</h4><ul><li>按照存储程序原理构建的计算机</li></ul><h4 id="存储程序原理"><a href="#存储程序原理" class="headerlink" title="存储程序原理"></a>存储程序原理</h4><h5 id="存储程序原理基本思想"><a href="#存储程序原理基本思想" class="headerlink" title="存储程序原理基本思想"></a>存储程序原理基本思想</h5><ul><li>计算机要自动完成解题任务</li><li>必须将实现设计好、用以描述计算机解题过程中的程序<ul><li>和数据一样</li><li>按 <strong>二进制</strong> 形式存储在机器中</li></ul></li><li>计算机在工作时 <strong>自动高速</strong> 地从机器中 <strong>逐条取出指令</strong> 并加以执行</li></ul><h6 id="程序的定义："><a href="#程序的定义：" class="headerlink" title="程序的定义："></a>程序的定义：</h6><ul><li>程序即指令的有序集合</li></ul><h6 id="计算器与计算机不同之处："><a href="#计算器与计算机不同之处：" class="headerlink" title="计算器与计算机不同之处："></a>计算器与计算机不同之处：</h6><ul><li>计算器解题步骤<ul><li>即程序是在执行过程中由人工临时编制和控制执行的</li></ul></li></ul><h5 id="存储程序原理-计算机五大功能"><a href="#存储程序原理-计算机五大功能" class="headerlink" title="存储程序原理 计算机五大功能"></a>存储程序原理 计算机五大功能</h5><ol><li>数据传送功能<ul><li>计算机将 <strong>原始数据</strong> 和 <strong>解题程序</strong> 输入到机器中</li><li>计算机结果与计算过程中情况 也能 <strong>随时输出</strong> 给用户</li><li>即 计算机必须有 <strong>输入和输出</strong> 的功能</li></ul></li><li>数据存储功能<ul><li>计算机能记住<ul><li>输入的原始数据</li><li>解题步骤 即程序</li><li>解题过程中产生中间结果</li></ul></li><li>即具备数据存储功能</li><li>是计算机能实现<strong>自动运算关键</strong></li></ul></li><li>数据处理功能<ul><li>能进行一些基本运算<ul><li>组合成所需要的一切复杂运算和操作</li></ul></li><li>这是计算机 进行<strong>运算、处理、控制的基础</strong></li></ul></li><li>操作控制功能<ul><li>保证程序执行的<strong>正确性</strong></li><li><strong>协调控制</strong> 组成计算机的各部件</li></ul></li><li>操作判断功能<ul><li>完成一步操作后<ul><li>从预先无法确定的几种方案中选择一种方案</li><li>保证解题操作正确完成</li></ul></li></ul></li></ol><h4 id="经典“存储程序计算机”"><a href="#经典“存储程序计算机”" class="headerlink" title="经典“存储程序计算机”"></a>经典“存储程序计算机”</h4><ul><li>即经典冯诺依曼结构计算机框图</li><li><img src="/posts/7573/冯诺依曼计算机.png" alt="冯诺依曼计算机" style="zoom:67%;">- 实线：  - 数据线- 虚线：  - 控制线  - 反馈线</li></ul><h3 id="1-2-2-计算机系统的组成"><a href="#1-2-2-计算机系统的组成" class="headerlink" title="1.2.2 计算机系统的组成"></a>1.2.2 计算机系统的组成</h3><h4 id="完整的计算机系统构成"><a href="#完整的计算机系统构成" class="headerlink" title="完整的计算机系统构成"></a>完整的计算机系统构成</h4><ul><li>硬件系统</li><li>软件系统</li></ul><h4 id="计算机硬件系统"><a href="#计算机硬件系统" class="headerlink" title="计算机硬件系统"></a>计算机硬件系统</h4><h5 id="硬件的定义："><a href="#硬件的定义：" class="headerlink" title="硬件的定义："></a>硬件的定义：</h5><ul><li>Hardware</li><li>是组成电子计算机的所有电子器件和机电装置的总称</li><li>是计算机系统中实际存在的物理实体，看得见摸得着</li></ul><h5 id="硬件系统的构成"><a href="#硬件系统的构成" class="headerlink" title="硬件系统的构成"></a>硬件系统的构成</h5><ul><li>物理构成上看：<ul><li>电子器件</li><li>插件板</li><li>电源</li><li>机架</li><li>各种功能的外部设备</li></ul></li><li>逻辑功能上看：<ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li><li>之间的互连结构</li></ul></li></ul><h5 id="硬件系统地位："><a href="#硬件系统地位：" class="headerlink" title="硬件系统地位："></a>硬件系统地位：</h5><ul><li><p>是构成计算机的物质基础</p></li><li><p>是计算机系统的核心</p></li></ul><h4 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h4><h5 id="软件的定义："><a href="#软件的定义：" class="headerlink" title="软件的定义："></a>软件的定义：</h5><ul><li>按iso国际标准化组织的定义：<ul><li>是电子计算机程序及运用数据处理系统所必须的<ul><li>手续</li><li>规则</li><li>文件<ul><li>的总称</li></ul></li></ul></li></ul></li></ul><h5 id="软件的构成"><a href="#软件的构成" class="headerlink" title="软件的构成"></a>软件的构成</h5><ul><li>程序</li><li>文档</li></ul><h5 id="程序："><a href="#程序：" class="headerlink" title="程序："></a>程序：</h5><ul><li>定义：<ul><li>为了取得一定的结果而编写的计算机指令的有序集合</li></ul></li><li>特点：<ul><li>可由计算机执行</li><li>是计算机软件的主体</li><li>一般说到软件，主要指程序</li></ul></li></ul><h5 id="文档："><a href="#文档：" class="headerlink" title="文档："></a>文档：</h5><ul><li><p>定义：</p><ul><li>是描述程序操作及使用的有关资料</li></ul></li><li><p>特点：</p><ul><li>不能由计算机执行</li></ul></li></ul><h4 id="计算机软件系统和硬件系统关系"><a href="#计算机软件系统和硬件系统关系" class="headerlink" title="计算机软件系统和硬件系统关系"></a>计算机软件系统和硬件系统关系</h4><h5 id="软硬件关系"><a href="#软硬件关系" class="headerlink" title="软硬件关系"></a>软硬件关系</h5><ul><li>软硬件之间是<ul><li>相互渗透、相互依存</li><li>相互配合、相互促进的关系</li><li>二者缺一不可</li></ul></li><li>硬件<ul><li>是躯体，是物质基础</li></ul></li><li>软件<ul><li>是智慧、灵魂、是硬件功能的完善和扩充</li><li>作为计算机用户与硬件之间接口界面<ul><li>在计算机系统中 起指挥管理作用</li></ul></li></ul></li><li>硬件与软件的组合<ul><li>构成了完善实用的计算机系统</li></ul></li></ul><h5 id="软硬件功能："><a href="#软硬件功能：" class="headerlink" title="软硬件功能："></a>软硬件功能：</h5><ul><li>计算机系统功能<ul><li>由硬件或软件实现</li></ul></li><li>软件与硬件在逻辑功能上等价<ul><li>硬件实现的功能可用软件实现</li><li>反之亦然</li></ul></li><li>由软硬件实现的计算机系统的<ul><li>成本</li><li>效率<ul><li>不同</li><li>一般在系统设计时加以权衡</li></ul></li></ul></li></ul><h5 id="软硬件转化："><a href="#软硬件转化：" class="headerlink" title="软硬件转化："></a>软硬件转化：</h5><ul><li><p>随着超大规模集成电路技术的发展</p><ul><li><p>软件硬化成固化是</p><ul><li>提高 <strong>计算机处理能力</strong> 的 最常用手段</li></ul></li><li><p>固件Firmware</p><ul><li><p>是将程序固化在ROM中组成的部件</p></li><li><p>是一种具有软件特性的硬件</p><ul><li><p>具有</p><ul><li><p>硬件的 快速性</p></li><li><p>软件的 灵活性</p></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="1-2-3-计算机硬件系统组成"><a href="#1-2-3-计算机硬件系统组成" class="headerlink" title="1.2.3 计算机硬件系统组成"></a>1.2.3 计算机硬件系统组成</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><h5 id="两类计算机结构"><a href="#两类计算机结构" class="headerlink" title="两类计算机结构"></a>两类计算机结构</h5><ul><li>冯诺依曼计算机结构<ul><li>以 <strong>运算器</strong> 为中心</li><li>计算机效率不高<ul><li>原因：<ul><li>输入输出设备速度慢</li><li>传输操作都需通过运算器</li></ul></li></ul></li></ul></li><li>现代计算机结构<ul><li>以 <strong>存储器</strong> 为中心</li></ul></li></ul><h5 id="中央处理器："><a href="#中央处理器：" class="headerlink" title="中央处理器："></a>中央处理器：</h5><ul><li>Central Processing Unit,CPU<ul><li>包含：<ul><li>运算器</li><li>控制器</li></ul></li><li>名称原因：<ul><li>运算器、控制器逻辑关系联系紧密</li><li>大规模集成电路出现后<ul><li>两部件集中在同一芯片上</li></ul></li></ul></li></ul></li></ul><h5 id="存储器："><a href="#存储器：" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>功能：<ul><li>存储二进制信息</li></ul></li><li>分类<ul><li>内存储器：<ul><li>又称主存储器</li><li>特点：<ul><li>存取速度快</li><li>存储容量较小</li><li>与CPU直接打交道</li><li>有半导体元器件构成</li></ul></li></ul></li><li>外存储器<ul><li>也称辅助存储器</li><li>特点：<ul><li>存取速度慢</li><li>存储容量较大</li><li>但不能直接与CPU打交道</li><li>必须把其中的信息送到内存后再由CPU处理</li></ul></li><li>eg：<ul><li>磁盘、磁带、光盘</li></ul></li></ul></li></ul></li></ul><h5 id="主机："><a href="#主机：" class="headerlink" title="主机："></a>主机：</h5><ul><li>包含<ul><li>内存储器</li><li>CPU</li></ul></li></ul><h5 id="外部设备："><a href="#外部设备：" class="headerlink" title="外部设备："></a>外部设备：</h5><ul><li><p>包含</p><ul><li><p>输入输出设备</p></li><li><p>外存储器</p></li></ul></li></ul><h4 id="运算器-Arithmetic-Unit"><a href="#运算器-Arithmetic-Unit" class="headerlink" title="运算器 Arithmetic Unit"></a>运算器 Arithmetic Unit</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h5><h6 id="运算器定义："><a href="#运算器定义：" class="headerlink" title="运算器定义："></a>运算器定义：</h6><ul><li>是进行数据处理</li><li>即执行<ul><li>算术运算</li><li>逻辑运算<ul><li>的部件</li></ul></li></ul></li></ul><h6 id="算术运算："><a href="#算术运算：" class="headerlink" title="算术运算："></a>算术运算：</h6><ul><li>是按照算数规则进行的运算</li><li>eg：<ul><li>加减乘除</li><li>及它们的复合运算等</li></ul></li></ul><h6 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h6><ul><li>即非算数性运算<ul><li>eg：<ul><li>比较</li><li>移位</li><li>逻辑加、逻辑乘</li><li>异或操作等</li></ul></li></ul></li></ul><h6 id="带输入锁存器的运算器"><a href="#带输入锁存器的运算器" class="headerlink" title="带输入锁存器的运算器"></a>带输入锁存器的运算器</h6><ul><li><p>含有：</p><ul><li>算术逻辑单元</li><li>内部总线</li><li>通用寄存器组</li><li>锁存器</li><li>标志寄存器</li><li>移位器</li></ul></li><li><p>结构图：</p><ul><li><img src="/posts/7573/%E5%B8%A6%E8%BE%93%E5%85%A5%E9%94%81%E5%AD%98%E5%99%A8%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8.png" alt="带输入锁存器的运算器"></li></ul></li></ul><h6 id="1-算数逻辑单元"><a href="#1-算数逻辑单元" class="headerlink" title="1.算数逻辑单元"></a>1.算数逻辑单元</h6><ul><li>Arithmetic and logic unit</li><li>功能：<ul><li>是具体完成算术逻辑运算的部件</li></ul></li><li>包含：<ul><li>加法器</li><li>逻辑运算器件</li></ul></li><li>地位：<ul><li>是运算器的核心</li></ul></li></ul><h6 id="2-内部总线"><a href="#2-内部总线" class="headerlink" title="2.内部总线"></a>2.内部总线</h6><ul><li>连接：<ul><li>ALU</li><li>通用寄存器组</li><li>锁存器</li><li>标志寄存器Flag</li><li>移位器</li></ul></li><li>地位：<ul><li>是CPU内部的数据通路</li></ul></li><li>与系统总线的区别：<ul><li>内部总线 仅用来传送数据</li></ul></li></ul><h6 id="3-通用寄存器组R0-R-n-1）"><a href="#3-通用寄存器组R0-R-n-1）" class="headerlink" title="3.通用寄存器组R0-R(n-1）"></a>3.通用寄存器组R0-R(n-1）</h6><ul><li>功能：<ul><li>用于存放参与运算的操作数<ul><li>eg：<ul><li>加、减、乘、被除数、积、商等</li></ul></li></ul></li><li>连续运算中，还存放<ul><li>中间结果</li><li>最终结果</li></ul></li><li>通用寄存器中的数据<ul><li>均从存储器中取得</li><li>最终结果也存放到存储器中</li></ul></li></ul></li></ul><h6 id="4-锁存器"><a href="#4-锁存器" class="headerlink" title="4.锁存器"></a>4.锁存器</h6><ul><li>位置：<ul><li>ALU的两个输入端各有一个锁存器<ul><li>用来暂存要参与运算的操作数</li></ul></li></ul></li><li>实现R0&lt;-(R0)+(R2)的方法：<ol><li>通过内部总线 将R0中的数据送入锁存器1</li><li>通过内部总线将R2中的数据送入锁存器2</li><li>再在ALU中相加</li><li>将结果通过内部总线送入R0</li></ol></li></ul><h6 id="5-标志寄存器Flag"><a href="#5-标志寄存器Flag" class="headerlink" title="5.标志寄存器Flag"></a>5.标志寄存器Flag</h6><ul><li>寄存运算的状态信息<ul><li>eg：<ul><li>结果是否为0</li><li>是正数还是负数</li><li>溢出与否</li></ul></li></ul></li></ul><h6 id="6-移位器："><a href="#6-移位器：" class="headerlink" title="6.移位器："></a>6.移位器：</h6><ul><li><p>是一个多路开关</p></li><li><p>可对ALU的加工结果进行辅助操作</p></li><li><p>eg：</p><ul><li><p>可实现</p><ul><li><p>左移</p></li><li><p>右移</p></li><li><p>直接传送</p><ul><li>等功能</li></ul></li></ul></li></ul></li></ul><h6 id="带多路选择器的运算器"><a href="#带多路选择器的运算器" class="headerlink" title="带多路选择器的运算器"></a>带多路选择器的运算器</h6><ul><li>除了带输入所存期的运算器外</li><li>还有带多路选择器的运算器<ul><li>相似点：<ul><li>基本组成相同</li></ul></li><li>差异点：<ul><li>通用寄存器与ALU的连接方式不同</li></ul></li></ul></li></ul><h4 id="控制器-Control-Unit"><a href="#控制器-Control-Unit" class="headerlink" title="控制器 Control Unit"></a>控制器 Control Unit</h4><h5 id="地位："><a href="#地位：" class="headerlink" title="地位："></a>地位：</h5><ul><li>是计算机的管理机构和指挥中心</li><li>协调计算机的各部件自动地工作</li></ul><h5 id="完成的工作："><a href="#完成的工作：" class="headerlink" title="完成的工作："></a>完成的工作：</h5><ul><li>实质上是 解释程序<ul><li>每次从存储器中读取一条指令</li><li>经过<ul><li>分析译码</li><li>产生一系列控制信号</li></ul></li><li>发往各个部件以控制他们的操作</li></ul></li><li>连续不断地继续上述动作<ul><li>即所谓执行程序</li></ul></li></ul><h5 id="控制器的结构图："><a href="#控制器的结构图：" class="headerlink" title="控制器的结构图："></a>控制器的结构图：</h5><p><img src="/posts/7573/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90.png" alt="控制器结构图"></p><h5 id="控制器的类别："><a href="#控制器的类别：" class="headerlink" title="控制器的类别："></a>控制器的类别：</h5><ul><li>组合逻辑控制器</li><li>微程序控制器</li></ul><h5 id="组合逻辑控制器："><a href="#组合逻辑控制器：" class="headerlink" title="组合逻辑控制器："></a>组合逻辑控制器：</h5><h6 id="结构组成："><a href="#结构组成：" class="headerlink" title="结构组成："></a>结构组成：</h6><ul><li><p>指令控制部件</p></li><li><p>地址形成部件</p></li><li><p>定时部件</p></li><li><p>微操作控制部件</p></li></ul><h5 id="1-指令控制部件"><a href="#1-指令控制部件" class="headerlink" title="1.指令控制部件"></a>1.指令控制部件</h5><h6 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h6><ul><li>程序计数器 Program Counter ,PC</li><li>指令寄存器 Instruction Register,IR</li><li>指令译码器 Instruction Decoder,ID</li></ul><h6 id="程序计数器PC："><a href="#程序计数器PC：" class="headerlink" title="程序计数器PC："></a>程序计数器PC：</h6><ul><li>又叫指令计数器</li><li>作用：<ul><li>给出程序中指令在存储器中的单位地址</li><li>兼有<ul><li>指令地址寄存器</li><li>计数器<ul><li>的功能</li></ul></li></ul></li></ul></li><li>工作过程：<ul><li>取指令时，PC指向要取指令的地址</li><li>当一条指令执行完毕时<ul><li>pc作为指令地址寄存器</li><li>其内容已变成下一条指令的地址</li></ul></li><li>控制器依据PC的内容从存储器取出指令到IR后<ul><li>pc将自动加1</li><li>指向下一条指令的地址</li></ul></li><li>假定一个存储单元存储一条指令<ul><li>若非顺序执行</li><li>只要将pc的内容作相应改变</li><li>就可以按新的序列顺序执行</li></ul></li></ul></li></ul><h6 id="指令寄存器IR"><a href="#指令寄存器IR" class="headerlink" title="指令寄存器IR:"></a>指令寄存器IR:</h6><ul><li>保存当前正在执行的指令代码</li><li>在指令执行过程中由它决定指令的<ul><li>操作性质</li><li>参与操作的操作数地址</li></ul></li></ul><h6 id="指令译码器ID："><a href="#指令译码器ID：" class="headerlink" title="指令译码器ID："></a>指令译码器ID：</h6><ul><li>也称操作码译码器</li><li>将指令的操作码转换为相应的控制电位信号<ul><li>只是各部件做什么操作</li></ul></li></ul><h5 id="2-地址形成部件"><a href="#2-地址形成部件" class="headerlink" title="2.地址形成部件"></a>2.地址形成部件</h5><ul><li>包括：<ul><li>地址寄存器Address Register AR</li><li>变址寄存器Index Register XR</li><li>地址计算部件</li></ul></li><li>功能：<ul><li>依据<ul><li>指令的寻址方式</li><li>指令的地址码部分<ul><li>生成实际的操作数地址</li></ul></li></ul></li></ul></li></ul><h5 id="3-定时部件"><a href="#3-定时部件" class="headerlink" title="3.定时部件"></a>3.定时部件</h5><ul><li>又称时序部件</li></ul><h6 id="组成：-1"><a href="#组成：-1" class="headerlink" title="组成："></a>组成：</h6><ul><li>时钟 Clock Pulses,CP</li><li>时序信号产生器 Timing Signal Generator ,TSG</li></ul><h6 id="时钟-CP："><a href="#时钟-CP：" class="headerlink" title="时钟 CP："></a>时钟 CP：</h6><ul><li>是协调计算机各部件进行操作的同步时钟</li><li>其工作频率<ul><li>成为计算机的 <strong>主频</strong></li><li><strong>主频</strong>的高低直接影响计算机的工作速度</li></ul></li></ul><h6 id="时序信号产生器TSG："><a href="#时序信号产生器TSG：" class="headerlink" title="时序信号产生器TSG："></a>时序信号产生器TSG：</h6><ul><li>功能：<ul><li>按时间顺序<ul><li>周而复始地发出若干节拍信号和脉冲</li></ul></li></ul></li><li>节拍：<ul><li>即相邻两个时钟脉冲的时间间隔</li><li>即主频周期</li></ul></li></ul><h6 id="定时部件工作特点："><a href="#定时部件工作特点：" class="headerlink" title="定时部件工作特点："></a>定时部件工作特点：</h6><ul><li>根据机器的时钟脉冲<ul><li>发出全机所需的<ul><li>定时节拍信号</li><li>脉冲</li></ul></li></ul></li><li>各部件在不同的节拍信号控制下依次进行工作</li></ul><h5 id="4-微操作控制器"><a href="#4-微操作控制器" class="headerlink" title="4.微操作控制器"></a>4.微操作控制器</h5><h6 id="微操作的定义："><a href="#微操作的定义：" class="headerlink" title="微操作的定义："></a>微操作的定义：</h6><ul><li>Micro-operation</li><li>是指计算机各部件在一个节拍内能完成的基本操作</li></ul><h6 id="微操作的意义："><a href="#微操作的意义：" class="headerlink" title="微操作的意义："></a>微操作的意义：</h6><ul><li>计算机任意一条指令的执行都需要分解成许多微操作来执行</li></ul><h6 id="微操作控制部件："><a href="#微操作控制部件：" class="headerlink" title="微操作控制部件："></a>微操作控制部件：</h6><ul><li>是控制器的<ul><li>核心部件</li><li>最复杂的部件</li></ul></li><li>工作过程：<ul><li>根据<ul><li>指令控制部件给出的指令译码电位信号（进行什么操作）</li><li>时序部件给出的节拍信号和脉冲（指令执行到那一步）</li><li>运算器Flag提供的状态信息</li></ul></li><li>产生 计算机指令系统中所有指令所需的各种微操作控制信号</li><li>再讲这些控制信号发送给<ul><li>运算器</li><li>存储器</li><li>输入、输出设备</li><li>控制其本身</li></ul></li></ul></li><li>与组合逻辑控制器关系：<ul><li>除将微操作控制部件用微程序库代替外</li><li>其他部件和组合逻辑控制器相似</li></ul></li></ul><h4 id="内存储器"><a href="#内存储器" class="headerlink" title="内存储器"></a>内存储器</h4><h5 id="存储器：-1"><a href="#存储器：-1" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>主要功能：<ul><li>存放<ul><li>数据</li><li>程序</li></ul></li></ul></li><li>数据：<ul><li>是计算机操作的对象</li></ul></li><li>程序：<ul><li>是计算机指令的有序集合</li></ul></li><li>数据与程序必须存放在内存储器中原因：<ul><li>数据与程序均以二进制的形式表示</li><li>为实现自动运行程序</li></ul></li></ul><h5 id="内存储器的构成："><a href="#内存储器的构成：" class="headerlink" title="内存储器的构成："></a>内存储器的构成：</h5><ul><li>存储体</li><li>选址系统</li><li>读写系统</li><li>存储时序控制线路</li></ul><h5 id="存储体："><a href="#存储体：" class="headerlink" title="存储体："></a>存储体：</h5><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><ul><li>被分成一个一个存储单元</li><li>每个存储单元存放多位二进制信息</li><li>通常每个单元存放一个数据或一条指令</li></ul><h6 id="信息的特点："><a href="#信息的特点：" class="headerlink" title="信息的特点："></a>信息的特点：</h6><ul><li>信息的位数通常是计算机的字长</li><li>一般字长为字节的整数倍</li></ul><h6 id="存储体的定义："><a href="#存储体的定义：" class="headerlink" title="存储体的定义："></a>存储体的定义：</h6><ul><li>即存储单元的集合</li></ul><h6 id="存储单元的特点："><a href="#存储单元的特点：" class="headerlink" title="存储单元的特点："></a>存储单元的特点：</h6><ul><li><p>按顺序编号</p></li><li><p>每个存储单元对应一个编号</p><ul><li>此编号为存储单元地址<ul><li>简称地址</li></ul></li></ul></li><li><p>只要给定一个地址</p><ul><li>就可以通过地址译码器译码</li><li>找到对应的存储单元</li><li>从而可<ul><li>从该单元读取信息</li><li>或将信息写入该单元</li></ul></li></ul></li><li><p>地址与存储单元的关系：</p><ul><li><p>地址与存储单元一一对应</p></li><li><p>每个存储单元只有一个地址</p></li></ul></li></ul><h5 id="选址系统：Addressing-System"><a href="#选址系统：Addressing-System" class="headerlink" title="选址系统：Addressing System"></a>选址系统：Addressing System</h5><h6 id="包含："><a href="#包含：" class="headerlink" title="包含："></a>包含：</h6><ul><li>存储地址寄存器 Memory Address Register ,MAR</li><li>地址译码器</li><li>地址驱动器</li></ul><h6 id="访问存储器过程："><a href="#访问存储器过程：" class="headerlink" title="访问存储器过程："></a>访问存储器过程：</h6><ul><li>CPU或I/O与内存储器交换信息以存储单元为单位</li><li>访问存储器：<ul><li>即向存储单元存入或从存储单元取出信息</li></ul></li></ul><h6 id="CPU或i-o访存过程："><a href="#CPU或i-o访存过程：" class="headerlink" title="CPU或i/o访存过程："></a>CPU或i/o访存过程：</h6><ul><li>先将访存地址送MAR</li><li>经地址译码器找到被访问的存储单元</li><li>最后由地址驱动器驱动该存储单元以实现读和写</li></ul><h5 id="读写系统-Read-and-Write-System"><a href="#读写系统-Read-and-Write-System" class="headerlink" title="读写系统 Read and Write System"></a>读写系统 Read and Write System</h5><ul><li>包含：<ul><li>存储缓冲寄存器 Mcmory Buffer Register ,MBR</li><li>读写线路</li></ul></li><li>工作过程：<ul><li>读出时：<ul><li>控制器发出读控制信号</li><li>借助于读出线路<ul><li>将由选址系统确定的存储单元内容<ul><li>读出送至MBR</li></ul></li></ul></li><li>以供I/O或CPU使用</li></ul></li><li>写入时：<ul><li>先将要写入的数据送至MBR</li><li>控制器发出写控制信号</li><li>借助于写入线路<ul><li>将BMR内容写入<ul><li>由选址系统确定的存储单元</li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="存储时序控制线路-Memory-Sequential-Control-Circuit"><a href="#存储时序控制线路-Memory-Sequential-Control-Circuit" class="headerlink" title="存储时序控制线路 Memory Sequential Control Circuit"></a>存储时序控制线路 Memory Sequential Control Circuit</h5><ul><li>包含：<ul><li>控制触发器</li><li>各种门电路</li><li>延迟线路</li></ul></li><li>工作过程：<ul><li>接收来自I/O或CPU的<ul><li>启动</li><li>读写</li><li>清除<ul><li>等命令</li></ul></li></ul></li><li>产生一系列控制内存储器<ul><li>完成读写等操作的信号</li></ul></li></ul></li></ul><h4 id="输入设备和输出设备"><a href="#输入设备和输出设备" class="headerlink" title="输入设备和输出设备"></a>输入设备和输出设备</h4><h5 id="输入设备："><a href="#输入设备：" class="headerlink" title="输入设备："></a>输入设备：</h5><ul><li>作用：<ul><li>将<ul><li>数据</li><li>程序<ul><li>送入计算机</li></ul></li></ul></li></ul></li><li>常见的输入设备：<ul><li>键盘</li><li>鼠标</li><li>数字化仪</li><li>扫描仪</li><li>摄像机</li></ul></li><li>特点：<ul><li>多是电子和机电混合的装置</li><li>一般需要通过被称之为接口的电子部件与<ul><li>运算器</li><li>控制器</li><li>存储器相连接<ul><li>原因：<ul><li>与运算器、控制器、内存储器等纯电子部件相比<ul><li>速度较慢</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备:"></a>输出设备:</h5><h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><ul><li>将计算处理的结果转化为<ul><li>人或其它设备</li><li>所能识别或接收的信息形式的装置</li></ul></li></ul><h6 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h6><ul><li>显示器能将信息转化为字符、图像、图形，并在屏幕上显示</li><li>打印机能将文件打印出来</li><li>绘图机可将图形绘制出来</li></ul><h6 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h6><ul><li><p>与输入设备一样</p><ul><li><p>输出设备也多为机电装置</p></li><li><p>也需要通过接口与</p><ul><li><p>运算器</p></li><li><p>控制器</p></li><li><p>存储器</p><ul><li>相连接</li></ul></li></ul></li></ul></li></ul><h4 id="互连结构"><a href="#互连结构" class="headerlink" title="互连结构"></a>互连结构</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><ul><li>计算机的五大部件<ul><li>需通过互连结构Interconnection Structure<ul><li>连接成一个有机的整体</li></ul></li></ul></li></ul><h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><ul><li>现代计算机通常采用 <strong>总线</strong>互连结构</li></ul><h5 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h5><ul><li>是连接计算机各部件进行信息传送的一组共同传输线</li><li>其类型和结构形式繁多</li></ul><h2 id="1-3-计算机的工作过程"><a href="#1-3-计算机的工作过程" class="headerlink" title="1.3 计算机的工作过程"></a>1.3 计算机的工作过程</h2><h3 id="1-3-1-使用计算机求解一个简单例子"><a href="#1-3-1-使用计算机求解一个简单例子" class="headerlink" title="1.3.1 使用计算机求解一个简单例子"></a>1.3.1 使用计算机求解一个简单例子</h3><h4 id="计算机求解问题步骤："><a href="#计算机求解问题步骤：" class="headerlink" title="计算机求解问题步骤："></a>计算机求解问题步骤：</h4><ul><li>首先，由用户提出任务并建立数学模型</li><li>确定便于计算机实现的算法</li><li>选择合适的语言编写程序</li><li>上机调试运行</li><li>不论采用哪种程序设计语言编写源程序<ul><li>都必需转换为机器语言程序</li><li>即目标程序</li><li>然后计算机才能执行</li></ul></li></ul><h4 id="机器语言程序的定义："><a href="#机器语言程序的定义：" class="headerlink" title="机器语言程序的定义："></a>机器语言程序的定义：</h4><ul><li>是机器指令（简称指令）的有序集合</li></ul><h4 id="计算机的工作过程："><a href="#计算机的工作过程：" class="headerlink" title="计算机的工作过程："></a>计算机的工作过程：</h4><ul><li>就是执行指令的过程</li></ul><h4 id="简单例子-1-1"><a href="#简单例子-1-1" class="headerlink" title="简单例子 1.1"></a>简单例子 1.1</h4><p>用计算机求解代数多项式：x=ax^3+bx^2+cx+d,其中a,b,c,d,x为已知数</p><ul><li>对该代数多项式可直接进行四则运算<ul><li>先求出x^2和x^3</li><li>然后计算每项乘积ax^3,bx^2和cx</li><li>最后两两相加求得y值<ul><li>此算法需要5次乘法和3次加法</li><li>共8次运算</li></ul></li></ul></li><li>如果将多项式的幂、乘加形式 变换为 乘、加迭代形式<ul><li>即：y=((ax+b)x+c)x+d<ul><li>此时计算需要乘、加各3次</li><li>共6次计算</li></ul></li></ul></li><li>更改后：<ul><li>8次运算减少到了6次</li><li>运算次数减少了四分之一</li></ul></li><li>运算的操作对象：<ul><li>有两个<ul><li>一个为寄存器中的操作数</li><li>一个为存储器中的操作数</li></ul></li><li>能完成计算任务的指令字格式为：<ul><li><img src="/posts/7573/%E6%8C%87%E4%BB%A4%E5%AD%97%E6%A0%BC%E5%BC%8F.png" alt="指令字格式"></li></ul></li></ul></li></ul><h4 id="指令与指令系统简介："><a href="#指令与指令系统简介：" class="headerlink" title="指令与指令系统简介："></a>指令与指令系统简介：</h4><h5 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h5><ul><li>是计算机设计者赋予计算机实现某种基本操作的命令</li><li>一般包含两个字段：<ul><li>操作码字段</li><li>地址码字段</li></ul></li></ul><h5 id="操作码字段："><a href="#操作码字段：" class="headerlink" title="操作码字段："></a>操作码字段：</h5><ul><li>指出计算机要执行什么类型的操作</li><li>即决定了指令的功能</li></ul><h5 id="地址码字段："><a href="#地址码字段：" class="headerlink" title="地址码字段："></a>地址码字段：</h5><ul><li>指出参与操作的操作数或操作数的地址</li><li>即规定了指令的操作对象</li><li>地址码字段的操作对象可以是零个到多个</li></ul><h5 id="指令字："><a href="#指令字：" class="headerlink" title="指令字："></a>指令字：</h5><ul><li>由操作码和地址码共同构成</li></ul><h5 id="指令系统："><a href="#指令系统：" class="headerlink" title="指令系统："></a>指令系统：</h5><ul><li><p>特点：</p><ul><li>包含一台计算机所能执行的所有指令</li><li>表征着计算机的基本功能和使用属性</li><li>计算机只能执行自己指令系统中的指令</li></ul></li><li><p>包括：</p><ul><li>算术运算</li><li>数据传送</li><li>处理机控制</li></ul></li><li><p>假如在某32位字长，设有16个通用寄存器的计算机上进行例1.1要求的计算机</p><ul><li>其指令格式如下：</li><li><img src="/posts/7573/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="指令格式"></li><li>OP<ul><li>操作码，占八位</li><li>表示该机指令系统中最多包含256条指令</li><li>这些指令包括<ul><li>算术运算，例如加，乘</li><li>数据传送，例如存数、取数</li><li>处理机控制，例如停机</li></ul></li></ul></li><li>Ri：<ul><li>操作数在寄存器中的地址</li><li>指向某通用寄存器，用4位表示</li><li>16个通用寄存器的地址（编号）可以分别用16进制的0~F来表示</li></ul></li><li>D：<ul><li>操作数在存储器中的地址</li><li>指向内存储器某存储单元</li><li>用20位表示</li><li>表示该计算机最多能访问2^20个存储单元</li></ul></li><li>该计算机的地址码：<ul><li>由Ri和D共同构成</li></ul></li><li>计算机的指令字:<ul><li>由OP,Ri，D构成</li></ul></li></ul></li><li><p>为完成例1.1工作，该计算机提供5条指令</p><ul><li><p>他们的操作码和指令功能见表1.1</p></li><li><p><img src="/posts/7573/%E8%A1%A81-1.png" alt="表1.1"></p></li><li><p>根据此表</p><ul><li>该指令将寄存器R8中的数据<ul><li>与地址为04000H的存储单元中的数据做加法</li></ul></li><li>结果放入寄存器R8中</li></ul></li><li><p>对于同一条指令的表示，可采用两种方法：</p><ul><li>二进制<ul><li>在计算机中存储的指令为二进制形式</li></ul></li><li>十六进制<ul><li>只是为了方便人们的书写和阅读</li></ul></li></ul></li></ul></li></ul><h4 id="编写求Y的机器语言程序"><a href="#编写求Y的机器语言程序" class="headerlink" title="编写求Y的机器语言程序"></a>编写求Y的机器语言程序</h4><h5 id="编写机器语言程序之前："><a href="#编写机器语言程序之前：" class="headerlink" title="编写机器语言程序之前："></a>编写机器语言程序之前：</h5><ul><li>必须进行存储单元分配</li></ul><h5 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h5><ul><li><p>假定将初始数据x,a,b,c,d分别存放在地址为</p><ul><li>00B00H~00B04H的存储单元中</li></ul></li><li><p>计算结果y存储到地址为00B05H的存储单元</p></li><li><p>程序存放在以00A00H为始地址的存储单元中</p></li><li><p>过程如表：</p></li><li><img src="/posts/7573/求y程序.png" alt="求y程序" style="zoom:60%;"></li><li><p>存储形式：</p><ul><li>如上图，指令和数据<ul><li>都是以代码形式存储在同一存储器的</li><li>计算机在执行时才加以区分</li></ul></li><li>这是冯诺依曼计算机最基本的原理</li></ul></li></ul><h3 id="1-3-2-指令执行过程"><a href="#1-3-2-指令执行过程" class="headerlink" title="1.3.2 指令执行过程"></a>1.3.2 指令执行过程</h3><h4 id="计算机总体框图"><a href="#计算机总体框图" class="headerlink" title="计算机总体框图"></a>计算机总体框图</h4><img src="/posts/7573/计算机总体框图.png" alt="计算机总体框图" style="zoom:67%;"><ul><li>实线箭头：<ul><li>代表数据信号</li></ul></li><li>虚线箭头<ul><li>代表控制信号</li></ul></li></ul><h4 id="指令工作过程简介："><a href="#指令工作过程简介：" class="headerlink" title="指令工作过程简介："></a>指令工作过程简介：</h4><h5 id="计算机工作过程："><a href="#计算机工作过程：" class="headerlink" title="计算机工作过程："></a>计算机工作过程：</h5><ul><li>实质是执行程序的过程<ul><li>执行程序的过程实质是<ul><li>逐条执行指令的过程</li></ul></li></ul></li></ul><h5 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h5><ul><li>取指令过程</li><li>执行指令过程</li></ul><h5 id="取指令过程"><a href="#取指令过程" class="headerlink" title="取指令过程"></a>取指令过程</h5><ul><li>程序计数器PC内容送往内存储器选址系统的MAR，即MAR&lt;-PC</li><li>控制器向内存储器发出读命令<ul><li>内存储器把MAR所指存储单元的内容读出送MBR</li><li>即MBR&lt;-M(MAR)</li><li>注意：此时MBR存放的是指令</li></ul></li><li>程序计数器内容加1<ul><li>为下一条指令准备好地址</li><li>即PC&lt;-PC+1</li></ul></li><li>经系统总线<ul><li>把MBR中的指令送控制器的指令寄存器IR</li><li>即IR&lt;-MBR</li></ul></li></ul><h5 id="执行指令过程"><a href="#执行指令过程" class="headerlink" title="执行指令过程"></a>执行指令过程</h5><ul><li>指令送到IR之后，计算机就进入执行指令过程</li><li>指令操作码经ID译码后<ul><li>确定执行操作的内容</li><li>然后将操作控制信号送入微操作控制部件</li></ul></li><li>在时序部件和运算状态的配合下<ul><li>由微操作控制部件向相关部件</li><li>发送执行该指令需要的所有 <strong>微操作控制信号</strong></li></ul></li><li>指令不同，微操作控制信号序列也不同<ul><li>执行不同的指令，涉及和使用的部件也不相同</li></ul></li><li>有些指令<ul><li>仅涉及和使用控制器部件</li><li>有些既涉及和使用控制器<ul><li>也涉及和使用内存储器、运算器、I/O等部件</li></ul></li></ul></li><li>但无论执行什么部件<ul><li>执行完最后一个微操作后，</li><li>都会返回到取指令的公共操作阶段</li></ul></li></ul><h5 id="以执行加法指令为例说明指令执行过程："><a href="#以执行加法指令为例说明指令执行过程：" class="headerlink" title="以执行加法指令为例说明指令执行过程："></a>以执行加法指令为例说明指令执行过程：</h5><ul><li>当ID译码后，加法控制电位为有效</li><li>在TSG配合下，微操作控制部件首先发出控制信号MAR&lt;-D<ul><li>将存储器操作数的地址送至MAR</li></ul></li><li>然后读存储器<ul><li>并将读出的数据送至MBR</li><li>即MBR&lt;-M(MAR)</li></ul></li><li>接着分别将加数、被加数送往两个锁存器</li><li>最后完成加法操作<ul><li>并将结果送回Ri</li><li>即Ri&lt;-锁存器1+锁存器2</li></ul></li><li>加法指令执行完成后，又回到下一条指令的取指令过程</li><li>如此周而复始执行程序中的每条指令，直至程序执行完毕</li></ul><img src="/posts/7573/指令执行过程.png" alt="指令执行过程" style="zoom:60%;"><h3 id="1-3-3-计算机工作的过程"><a href="#1-3-3-计算机工作的过程" class="headerlink" title="1.3.3 计算机工作的过程"></a>1.3.3 计算机工作的过程</h3><h4 id="程序设计好后如何装入内存储器？"><a href="#程序设计好后如何装入内存储器？" class="headerlink" title="程序设计好后如何装入内存储器？"></a>程序设计好后如何装入内存储器？</h4><ul><li>通过操作系统下的调试程序<ul><li>送到内存储器指令存储区域</li></ul></li><li>同时通过它把机器语言程序的始地址送给程序计数器PC</li></ul><h4 id="例1-1计算机工作过程"><a href="#例1-1计算机工作过程" class="headerlink" title="例1.1计算机工作过程"></a>例1.1计算机工作过程</h4><h5 id="启动计算机："><a href="#启动计算机：" class="headerlink" title="启动计算机："></a>启动计算机：</h5><ul><li>把程序始地址00A00H送PC</li><li>然后可启动计算机工作<ul><li>计算机开始执行程序<ul><li>即开始了指令执行的过程</li></ul></li></ul></li></ul><h5 id="指令执行的过程："><a href="#指令执行的过程：" class="headerlink" title="指令执行的过程："></a>指令执行的过程：</h5><ul><li>从00A00H存储单元取出指令10800B01H放入IR</li><li>PC内容加1变为00A01H</li><li>IR的内容经ID译码发现是取数指令</li><li>于是在执行指令阶段<ul><li>将存储单元00B01H中的数a读到R8寄存器中</li></ul></li><li>接着又进入取指令阶段<ul><li>从00A01H存储单元取出指令08800 B00H放入IR</li><li>PC内容加1变为00A02H</li><li>IR的内容经ID译码发现是乘法指令</li></ul></li><li>于是在执行指令阶段<ul><li>从00B00H存储单元取出乘数</li><li>将它与R8中的被乘数a进行乘法运算</li><li>乘积存入R8</li></ul></li><li>接着又从00A02H存储单元取出指令02800B02H放入IR<ul><li>PC内容加1变成00A03H</li><li>IR的内容经ID译码发现是加法指令</li><li>执行加法指令</li></ul></li><li>如果此执行程序中的每条指令<ul><li>直至从00A08H存储单元取出停机指令并执行</li><li>停机指令使TSG不再发出节拍信号</li><li>计算机也停止了指令执行过程</li><li>该程序执行完毕</li></ul></li></ul><h2 id="1-4-计算机的性能指标和分类"><a href="#1-4-计算机的性能指标和分类" class="headerlink" title="1.4 计算机的性能指标和分类"></a>1.4 计算机的性能指标和分类</h2><h3 id="1-4-1-计算机的性能指标"><a href="#1-4-1-计算机的性能指标" class="headerlink" title="1.4.1 计算机的性能指标"></a>1.4.1 计算机的性能指标</h3><h4 id="与硬件相关的几个性能指标："><a href="#与硬件相关的几个性能指标：" class="headerlink" title="与硬件相关的几个性能指标："></a>与硬件相关的几个性能指标：</h4><ul><li>主频</li><li>运算速度</li><li>运算精度</li><li>主存存储容量</li><li>主存存储周期</li></ul><h4 id="主频："><a href="#主频：" class="headerlink" title="主频："></a>主频：</h4><h5 id="主频（或时钟周期）："><a href="#主频（或时钟周期）：" class="headerlink" title="主频（或时钟周期）："></a>主频（或时钟周期）：</h5><ul><li>是计算机的主要性能指标之一</li><li>很大程度上决定计算机的运行速度</li></ul><h5 id="主频的特点："><a href="#主频的特点：" class="headerlink" title="主频的特点："></a>主频的特点：</h5><ul><li>主频越高<ul><li>CPU的工作节拍就越快</li><li>运算速度就越高</li></ul></li><li>主频通常用一秒钟内处理器能发出电子脉冲数来表示<ul><li>单位一般为兆赫兹MHZ</li></ul></li></ul><h5 id="时钟CP："><a href="#时钟CP：" class="headerlink" title="时钟CP："></a>时钟CP：</h5><ul><li>CPU的工作节拍是由时钟CP控制的</li><li>时钟不断产生固定频率的时钟脉冲</li><li>这个脉冲就是 CPU的 <strong>主频f</strong></li></ul><h5 id="以Intel系列微型计算机为例："><a href="#以Intel系列微型计算机为例：" class="headerlink" title="以Intel系列微型计算机为例："></a>以Intel系列微型计算机为例：</h5><ul><li>最早8086的主频为5MHZ</li><li>80386的主频为16MHZ</li><li>586的主频可达到266MHZ</li><li>奔腾二代的主频可达450MHZ</li><li>奔腾三代的主频可达1.2GHZ</li><li>奔腾四代的主频现已达3GHZ甚至更高</li></ul><h4 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h4><h5 id="运算速度的概念："><a href="#运算速度的概念：" class="headerlink" title="运算速度的概念："></a>运算速度的概念：</h5><ul><li>是计算机工作能力和工作效率的主要表征</li><li>取决于在给定时间内处理器所能处理的数据量以及处理器的时钟频率</li></ul><h5 id="运算速度的表示："><a href="#运算速度的表示：" class="headerlink" title="运算速度的表示："></a>运算速度的表示：</h5><ul><li>通常用每秒执行指令的条数来表示</li><li>计量单位：<ul><li>MIPS 百万条指令每秒<ul><li>用来描述计算机的定点运算速度</li></ul></li><li>MFLOPS 百万次浮点预算每秒<ul><li>用来描述计算机的浮点运算速度</li></ul></li></ul></li></ul><h5 id="运算速度的计算方法："><a href="#运算速度的计算方法：" class="headerlink" title="运算速度的计算方法："></a>运算速度的计算方法：</h5><h6 id="吉普森混合法："><a href="#吉普森混合法：" class="headerlink" title="吉普森混合法："></a>吉普森混合法：</h6><ul><li>也称 混合比率计算法</li><li>原理<ul><li>从应用课题程序中统计各类指令所占百分比</li><li>然后用指令混合比计算指令的平均执行速度</li></ul></li><li>具体计算方法：<ul><li>假定第i类指令(i=1,2,…,n)在使用过程中<ul><li>出现的概率为P</li><li>执行时间为ti</li><li>则指令的平均执行时间tE为：<ul><li><img src="/posts/7573/%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="执行时间"></li><li>tE的倒数是 吉布森混合法平均执行速度<ul><li>其中Pi的集合即为混合比</li></ul></li></ul></li></ul></li></ul></li><li>缺陷：<ul><li>现代计算机的指令系统十分复杂<ul><li>不少指令执行时间不固定</li><li>采用固定比例可能脱离实际</li><li>所以这种方法较少采用</li></ul></li></ul></li></ul><h6 id="计算各种指令的执行速度"><a href="#计算各种指令的执行速度" class="headerlink" title="计算各种指令的执行速度"></a>计算各种指令的执行速度</h6><ul><li>原理：<ul><li>根据计算机的主频f（MHZ）</li><li>求出处理器的基本节拍周期T=1/f（ns）</li><li>再根据处理器结构模型和指令操作流程</li><li>可推算出 <ul><li>执行各种指令的基本节拍数 和每秒执行指令的条数</li></ul></li></ul></li><li>缺陷：<ul><li>这种方法得到的性能并不十分精确<ul><li>有时甚至做了一些理想化的假定<ul><li>例如：假定全部功能部件都处在满负荷的最佳工作状态下</li></ul></li><li>这种在理想状态下得到的最佳性能被称为 <strong>峰值执行速度</strong><ul><li>在实际指令执行时是不可能出现的</li></ul></li></ul></li></ul></li></ul><h6 id="计算典型程序的运算速度"><a href="#计算典型程序的运算速度" class="headerlink" title="计算典型程序的运算速度"></a>计算典型程序的运算速度</h6><ul><li>选取应用中具有代表性的课题<ul><li>eg：<ul><li>快速傅里叶变换FFT</li><li>图形图像的处理</li><li>等等</li></ul></li><li>计算这些典型程序的运算速度</li></ul></li></ul><h6 id="计算计算机运算速度其他方法："><a href="#计算计算机运算速度其他方法：" class="headerlink" title="计算计算机运算速度其他方法："></a>计算计算机运算速度其他方法：</h6><ul><li>模型分析与模型模拟</li><li>实际测量</li><li>等等</li></ul><h4 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a>运算精度</h4><h5 id="衡量标准："><a href="#衡量标准：" class="headerlink" title="衡量标准："></a>衡量标准：</h5><ul><li>运算精度通常用计算机能直接处理的 <strong>二进制信息位数</strong> 来衡量</li></ul><h5 id="二进制信息位数："><a href="#二进制信息位数：" class="headerlink" title="二进制信息位数："></a>二进制信息位数：</h5><ul><li>特点：<ul><li>一般与CPU中存储数据寄存器的位数相同</li><li>位数越多，精度越高</li></ul></li></ul><h5 id="基本字长："><a href="#基本字长：" class="headerlink" title="基本字长："></a>基本字长：</h5><ul><li>定义：<ul><li>参与运算操作数的基本位数成为 <strong>基本字长</strong></li></ul></li><li>特点：<ul><li>在一定情况下标志着计算精度</li><li>决定着<ul><li>寄存器</li><li>加法器</li><li>数据总线<ul><li>等的位数</li></ul></li></ul></li><li>直接影响着硬件的造价</li></ul></li></ul><h5 id="变字长计算："><a href="#变字长计算：" class="headerlink" title="变字长计算："></a>变字长计算：</h5><ul><li>原因：<ul><li>为适应不同类型计算的需要</li><li>并较好地协调精度与造价的关系</li></ul></li><li>eg：<ul><li>半字长</li><li>全字长</li><li>双字长</li><li>等等</li></ul></li></ul><h5 id="计算机字长："><a href="#计算机字长：" class="headerlink" title="计算机字长："></a>计算机字长：</h5><ul><li>早期微型计算机<ul><li>字长多为 <strong>8位</strong> 和 <strong>16</strong>位</li><li>现在多为 <strong>32</strong>位</li></ul></li><li>大中型计算机<ul><li>多为 <strong>32</strong>位 和 <strong>64位</strong></li></ul></li><li>巨型计算机<ul><li>一般都是 <strong>64</strong>位</li></ul></li></ul><h4 id="主存存储容量"><a href="#主存存储容量" class="headerlink" title="主存存储容量"></a>主存存储容量</h4><h5 id="主存储器作用："><a href="#主存储器作用：" class="headerlink" title="主存储器作用："></a>主存储器作用：</h5><ul><li>用来存储数据和程序</li><li>直接与CPU交换信息</li></ul><h5 id="主存储器特点："><a href="#主存储器特点：" class="headerlink" title="主存储器特点："></a>主存储器特点：</h5><ul><li>主存容量越大<ul><li>可存储的数据和程序就越多</li><li>处理问题的能力也就越强</li></ul></li><li>主存与外存储器的<ul><li>信息交换次数越少</li><li>系统的效率就越高</li></ul></li></ul><h5 id="主存容量的地位"><a href="#主存容量的地位" class="headerlink" title="主存容量的地位;"></a>主存容量的地位;</h5><ul><li>是衡量计算机的主要性能指标之一</li></ul><h5 id="主存容量的表示："><a href="#主存容量的表示：" class="headerlink" title="主存容量的表示："></a>主存容量的表示：</h5><ul><li>以字为单位的计算机<ul><li>常用 <strong>字数</strong> 乘以 <strong>字长</strong> 表示主存容量</li><li>eg：<ul><li>4K x 16位<ul><li>表示主存有4096个存储单元</li><li>每个单元字长16位</li></ul></li></ul></li></ul></li><li>以字节为单位的计算机<ul><li>以 <strong>字节数</strong> 表示主存容量</li><li>eg：<ul><li>32KB</li><li>表示主存容量为<ul><li>32768x8位</li></ul></li></ul></li></ul></li></ul><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><ul><li>现在的高档微机<ul><li>主存容量从128MB,256MB不等</li><li>有的为2GB甚至更高</li></ul></li></ul><h4 id="主存存取周期"><a href="#主存存取周期" class="headerlink" title="主存存取周期"></a>主存存取周期</h4><h5 id="“写入”的定义："><a href="#“写入”的定义：" class="headerlink" title="“写入”的定义："></a>“写入”的定义：</h5><ul><li>将信息存入主存</li></ul><h5 id="“读出”的定义："><a href="#“读出”的定义：" class="headerlink" title="“读出”的定义："></a>“读出”的定义：</h5><ul><li>将信息从主存中取出</li></ul><h5 id="“访存”的定义："><a href="#“访存”的定义：" class="headerlink" title="“访存”的定义："></a>“访存”的定义：</h5><ul><li>对主存的读写</li></ul><h5 id="存取周期："><a href="#存取周期：" class="headerlink" title="存取周期："></a>存取周期：</h5><ul><li>定义：<ul><li>对主存连续两次访存所允许的最小时间间隔</li></ul></li><li>地位：<ul><li>既是 表征主存性能的基本参数</li><li>也是反应计算机整机性能的重要参数</li></ul></li><li>特点：<ul><li>存取周期越小<ul><li>表明从主存存取信息的时间越短</li><li>计算机系统性能越高</li></ul></li></ul></li><li>数值：<ul><li>现代 计算机主存存取周期 一般在<ul><li>几十纳秒</li><li>有时甚至几个纳秒</li></ul></li></ul></li></ul><h5 id="计算机技术性能评价的因素："><a href="#计算机技术性能评价的因素：" class="headerlink" title="计算机技术性能评价的因素："></a>计算机技术性能评价的因素：</h5><ul><li><p>计算机技术性能高低好坏，考虑因素应多方面：</p><ul><li>如<ul><li>系统结构、硬件组成、外设配置</li><li>软件种类、吞吐率、响应时间</li><li>可靠性、可用性、可维性</li><li>完整性、安全性</li></ul></li><li>不能片面强调一项指标，应综合全面考虑</li></ul></li><li><p>综合性指标：</p><ul><li>通常以 <strong>性能价格比</strong> 为综合性指标</li><li>性能：<ul><li>指机器的综合性能</li><li>包括：<ul><li>硬件、软件的各种性能</li></ul></li></ul></li><li>价格：<ul><li>指的是整个系统的价格</li></ul></li><li>性能价格比 <strong>越大越好</strong><ul><li>它是选择和设计计算机的重要依据</li></ul></li></ul></li></ul><h3 id="1-4-2-计算机的分类"><a href="#1-4-2-计算机的分类" class="headerlink" title="1.4.2 计算机的分类"></a>1.4.2 计算机的分类</h3><h4 id="电子计算机的定义："><a href="#电子计算机的定义：" class="headerlink" title="电子计算机的定义："></a>电子计算机的定义：</h4><ul><li>是一种由电子线路构成的设备</li><li>能对信息进行记忆、传送、处理<ul><li>从而实现计算的功能</li></ul></li></ul><h4 id="计算机常见分类方法："><a href="#计算机常见分类方法：" class="headerlink" title="计算机常见分类方法："></a>计算机常见分类方法：</h4><ul><li>按计算机用途分类：<ul><li>通用计算机</li><li>专用计算机</li></ul></li><li>按计算机规模分类：<ul><li>巨型机</li><li>大型计算机</li><li>小型计算机</li><li>微型计算机</li><li>单片机</li></ul></li></ul><h4 id="专用计算机："><a href="#专用计算机：" class="headerlink" title="专用计算机："></a>专用计算机：</h4><ul><li><p>定义：</p><ul><li>是针对某一特定应用领域<ul><li>或面向某种算法</li><li>的计算机</li></ul></li></ul></li><li><p>eg：</p><ul><li>工业过程中的控制计算机</li><li>军事上武器设备的控制指挥仪</li><li>卫星图像处理和天气预报使用的大型并行处理机</li><li>等等</li></ul></li><li><p>特点：</p><ul><li>专用机的结构和软件是专门针对其应用领域设计的</li><li>因而对该领域的应用是高效的</li></ul></li><li><p>缺点：</p><ul><li>若用于其他领域<ul><li>则效率较低甚至无法运行</li></ul></li></ul></li><li><p>优点：</p><ul><li>功能单一、结构较简单</li><li>成本较低、可靠性较高</li></ul></li></ul><h4 id="通用计算机"><a href="#通用计算机" class="headerlink" title="通用计算机"></a>通用计算机</h4><ul><li>定义：<ul><li>即人们常说的计算机</li></ul></li><li>配置:<ul><li>通常根据不同计算机系列型号配备一定外设</li><li>它配备多种系统软件<ul><li>eg：<ul><li>操作系统</li><li>数据库管理软件</li><li>多种工具软件</li></ul></li></ul></li><li>只要再配备相应应用软件<ul><li>就可以应用于各种领域</li></ul></li></ul></li><li>特点：<ul><li>通用性强</li><li>功能全</li></ul></li></ul><h4 id="规模："><a href="#规模：" class="headerlink" title="规模："></a>规模：</h4><ul><li>是综合计算机多方面因素而言</li><li>通常涉及<ul><li>计算机的运算速度、字长、存储容量、外部设备等硬件配置</li><li>以及软件、价格等诸多方面</li></ul></li><li>按规模分类实际是<ul><li>按计算机性能分类</li></ul></li><li>变化：<ul><li>随计算机科学技术飞速发展<ul><li>这种规模或性能的概念也在不断变化</li></ul></li><li>昔日超级计算机<ul><li>可能赶不上现在的微型机</li></ul></li></ul></li></ul><h4 id="巨型机："><a href="#巨型机：" class="headerlink" title="巨型机："></a>巨型机：</h4><ul><li>名称：<ul><li>Supercomputer</li><li>也称 超级计算机</li></ul></li><li>地位：<ul><li>是一个国家科技水平、经济水平、军事威力的象征<ul><li>目前只有美英俄法日等少数几个国家拥有巨型机</li></ul></li></ul></li><li>优点：<ul><li>速度最快、性能最高</li><li>功能最强、技术最复杂</li></ul></li><li>作用：<ul><li>拥有巨大的数值计算和信息处理能力</li><li>是计算机高精尖技术的集中代表</li></ul></li><li>特点：<ul><li>一般字长为64位</li><li>每秒平均执行百亿次以上的浮点运算</li><li>主存容量1~4百万字以上</li><li>其高速数据通道每秒可传送数据几千万个字以上</li><li>具有丰富的系统软件</li></ul></li><li>举例：<ul><li>IBM公司SP2系列<ul><li>速度可达每秒3万亿次浮点运算</li></ul></li><li>Intel公司使用Pentium Pro构成的巨型计算机Paragon<ul><li>速度可达到每秒1万亿次</li></ul></li><li>我国自行研制的<ul><li>银河二型巨型机<ul><li>运算速度达到每秒10亿次</li></ul></li><li>银河三型巨型机<ul><li>运算速度达到每秒130亿次</li></ul></li><li>曙光巨型机<ul><li>运算速度达到每秒3000亿次</li></ul></li></ul></li></ul></li></ul><h4 id="大型计算机"><a href="#大型计算机" class="headerlink" title="大型计算机"></a>大型计算机</h4><ul><li>名称：<ul><li>Large Scale Computer/Mainframe</li></ul></li><li>地位：<ul><li>是计算机家族中 通用性最强、功能很强的计算机</li><li>是体现所在时代计算机科技水平的一类高性能大容量计算机</li></ul></li><li>特点：<ul><li>一般字节32~64位</li><li>每秒执行数百万到数千万条指令</li><li>主存容量几十万到几百万字</li><li>有较多的外设和通信接口</li><li>有很强的I/O处理能力和丰富的系统软件及应用软件</li></ul></li><li>典型机种：<ul><li>20世纪<ul><li>60年代的IBM360系列</li><li>70年代的IBM370系列</li><li>80年代的IBM 370-XA系列</li><li>90年代的IBM390系列</li></ul></li></ul></li></ul><h4 id="小型计算机"><a href="#小型计算机" class="headerlink" title="小型计算机"></a>小型计算机</h4><ul><li>名称：<ul><li>Minicomputer</li></ul></li><li>优点：<ul><li>性能较好</li><li>价格便宜</li><li>应用领域广泛</li></ul></li><li>特点：<ul><li>一般字长32位</li><li>速度每秒几十万到几百万次</li><li>内存容量几万到几十万字</li><li>配有一定数量的外设与通信接口</li><li>有汇编语言和多种高级语言</li><li>有功能较强的操作系统</li></ul></li><li>超级小型计算机：<ul><li>Super Minicomputer</li><li>处理能力、内存容量、操作系统功能远超一般小型计算机</li></ul></li><li>典型机种：（包括小型与超级小型)<ul><li>NOVA系列</li><li>PDP-11系列</li><li>VAX-11系列</li><li>MicroVAX系列</li><li>王安VS系列</li></ul></li></ul><h4 id="微型计算机"><a href="#微型计算机" class="headerlink" title="微型计算机"></a>微型计算机</h4><ul><li>简称：<ul><li>微型机</li><li>微机</li></ul></li><li>特点：<ul><li>以微处理器为中央处理器</li></ul></li><li>优点：<ul><li>性能价格比最高</li><li>应用领域最广</li></ul></li><li>发展状况：<ul><li>发展最快、市场占有率最高</li><li>许多性能达到甚至超过小型机水平</li><li>正不断向微型化、网络化、高性能、多用途方向发展</li></ul></li><li>分类方法：<ul><li>按字长分：<ul><li>8位</li><li>16位</li><li>32位</li></ul></li><li>按组装形式分：<ul><li>非便携式<ul><li>eg：台式机</li></ul></li><li>便携式<ul><li>eg：可移动的微型机<ul><li>笔记本型或掌上型计算机</li></ul></li></ul></li></ul></li><li>按最终是否由用户使用分：<ul><li>独立式<ul><li>可由最终用户直接使用</li><li>eg：个人计算机 PC Personal Computer</li></ul></li><li>嵌入式<ul><li>将其作为一个信息处理部件装入一个应用设备</li><li>最终用户不直接使用计算机，而使用该设备</li><li>eg：<ul><li>包含计算机的医疗设备、家用电器等</li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="单片机："><a href="#单片机：" class="headerlink" title="单片机："></a>单片机：</h4><ul><li>定义：<ul><li>将中央处理器、存储器、输入输出接口集成在一块芯片上的微型计算机<ul><li>简称：<ul><li>单片机 Single Chip Computer</li></ul></li></ul></li><li>由于主要应用于控制系统，所以又通常称：<ul><li>微控制器 Micro Control Unit ,MCU</li></ul></li></ul></li><li>特点：<ul><li>一般采用 <strong>面向控制</strong> 的系统结构和指令系统</li><li>字长<ul><li>从4位、8位、到16位</li><li>20世纪90年代推出32位单片机</li></ul></li><li>显著特点：<ul><li>多功能的输入、输出结构</li></ul></li></ul></li><li>常有：<ul><li>定时计数器</li><li>并行接口</li><li>串行接口</li><li>数模转换器</li><li>模数转换器</li></ul></li><li>地位：<ul><li>与个人计算器一样，是目前应用最广、产量最高的两种计算机</li></ul></li><li>应用：<ul><li>单片机 多作为MCU装入各种设备<ul><li>是嵌入式微型化计算机最主要的形式</li></ul></li><li>通常在家用电器、一般控制及高速控制等应用领域</li><li>家用电器中：<ul><li>多采用4位单片机或低档8位单片机</li></ul></li><li>在一般控制应用中：<ul><li>多采用高性能8位或16位单片机</li></ul></li><li>在高速控制应用中：<ul><li>多采用高性能16位或32位单片机</li></ul></li></ul></li></ul><h2 id="1-5-计算机应用与发展"><a href="#1-5-计算机应用与发展" class="headerlink" title="1.5 计算机应用与发展"></a>1.5 计算机应用与发展</h2><h3 id="1-5-1-计算机的应用"><a href="#1-5-1-计算机的应用" class="headerlink" title="1.5.1 计算机的应用"></a>1.5.1 计算机的应用</h3><h4 id="大体分类："><a href="#大体分类：" class="headerlink" title="大体分类："></a>大体分类：</h4><ul><li><p>科学计算</p></li><li><p>数据处理</p></li><li><p>实时控制</p></li><li><p>辅助设计</p></li><li><p>智能模拟</p><p>（虽覆盖计算机大多数领域，但未能包括全部）</p></li></ul><h4 id="1-科学计算"><a href="#1-科学计算" class="headerlink" title="1.科学计算"></a>1.科学计算</h4><ul><li>是计算机一个重要领域</li><li>有效地使用数字计算机<ul><li>来求解数学问题的近似解的理论、方法和过程<ul><li>已形成专门的学科：</li><li>数值计算 Numerical Computation</li></ul></li></ul></li><li>eg:<ul><li>求解上千阶微分方程组</li></ul></li><li>大大促进科学研究与国民经济发展</li></ul><h4 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2.数据处理"></a>2.数据处理</h4><ul><li>主要功能：<ul><li>将输入设备送来的数据及时记录、整理、分类、加工<ul><li>以得到需要的信息</li></ul></li><li>eg：<ul><li>企业管理、库存管理、账目计算、情报检索、图像处理等等</li></ul></li></ul></li><li>特点：<ul><li>原始数据量大、算数运算比较简单、有大量逻辑与判断</li><li>处理的结果多以报表或文件形式存储或输出</li><li>对于这些工作，人力无法完成，采用计算机可很快得出结果</li></ul></li><li>实例：<ul><li>利用数据库系统软件，如Sybase,Oracle,Access等开发的各种应用软件系统<ul><li>eg：<ul><li>财务管理系统、交通客票预定系统、人事管理系统</li><li>办公自动化系统、数字地图系统、情报分析与检测系统</li></ul></li></ul></li></ul></li><li>优点：<ul><li>使人们从大量繁杂的数据统计与管理事务中解脱出来<ul><li>大大提高了工作效率与质量</li></ul></li><li>利用计算机网络与通信技术<ul><li>实现资源共享与远程信息传输</li><li>更使数据处理这类应用焕发生机</li></ul></li></ul></li></ul><h4 id="3-实时控制："><a href="#3-实时控制：" class="headerlink" title="3.实时控制："></a>3.实时控制：</h4><ul><li>是计算机在过程控制中的重要应用</li><li>“实时”的定义：<ul><li>就是指计算机的运算和控制时间与被控制过程的实际时间相适应</li></ul></li><li>“实时性”<ul><li>是以计算机速度为基础的</li><li>不同受控对象其物理过程的时间参数是不同的</li><li>eg：<ul><li>生产过程控制时间参数较大<ul><li>对计算机速度要求不高</li></ul></li><li>对武器发射过程控制时间参数较小<ul><li>对计算机速度要求高</li></ul></li></ul></li></ul></li><li>过程控制应用：<ul><li>最初：<ul><li>主要应用于导弹、卫星、飞船等</li><li>现代化武器系统和航空航天等领域</li></ul></li><li>现在：<ul><li>已广泛运用于工业生产过程</li><li>过程控制发挥神经系统功能<ul><li>由于高灵敏度、高精确度控制</li><li>使得上述领域工作能在人的意志控制下准确无误完成</li></ul></li></ul></li></ul></li></ul><h4 id="4-辅助设计"><a href="#4-辅助设计" class="headerlink" title="4.辅助设计"></a>4.辅助设计</h4><ul><li>定义：<ul><li>Computer Aided Design,CAD</li><li>是利用计算机能帮助设计人员进行工程、产品等设计工作的过程和技术</li></ul></li><li>应用：<ul><li>在航天航空、船舶交通、机械电子、基建和化工等部门</li><li>由计算机辅助产生的设计结果通过图形设备与设计人员交互<ul><li>可及时对设计进行判断和修改</li><li>最终完成设计工作</li></ul></li></ul></li><li>优点：<ul><li>提高了设计的自动化水平</li><li>缩短了设计周期</li><li>减轻了设计人员的劳动</li><li>大大提高了设计质量</li></ul></li><li>计算机辅助制造CAM：<ul><li>CAD发展带动了CAM进步</li><li>定义：<ul><li>CAM是在制造业中<ul><li>利用计算机辅助各种设备完成产品的加工、装配、检测、和包装等的过程和技术</li></ul></li></ul></li><li>优点：<ul><li>显著提高了企业的生产效率</li><li>缩短了工作周期</li><li>降低了产品成本</li><li>提高了产品质量</li></ul></li><li>CAD/CAM系统：<ul><li>有CAD与CAM紧密结合一起而构成</li></ul></li></ul></li><li>计算机辅助教学CAI：<ul><li>定义：<ul><li>是利用计算机辅助教师对学生进行教学的过程和技术</li></ul></li><li>最大特点：<ul><li>在计算机和学生之间实现对话</li><li>学生可以根据个人特点进行学习，变被动为主动</li><li>生动直观形象，极大提高学习兴趣与效果</li></ul></li></ul></li></ul><h4 id="5-智能模拟"><a href="#5-智能模拟" class="headerlink" title="5.智能模拟"></a>5.智能模拟</h4><h5 id="人工智能："><a href="#人工智能：" class="headerlink" title="人工智能："></a>人工智能：</h5><ul><li>地位：<ul><li>是计算机应用研究最前沿的学科</li></ul></li><li>定义：<ul><li>是采用计算机来研究开发用于模拟、延伸和扩展人的只能</li><li>eg：智能、推理、学习、理解</li><li>是在质的方面扩充计算机的能力<ul><li>提高它的智能水平</li></ul></li></ul></li><li>研究与应用：<ul><li>已在模式识别、景物分析、自然语言的理解与生成</li><li>博弈、自动定理证明、自动程序设计、专家系统</li><li>模拟训练系统、智能决策系统以及机器人领域得到发展</li></ul></li></ul><h5 id="智能模拟："><a href="#智能模拟：" class="headerlink" title="智能模拟："></a>智能模拟：</h5><ul><li>优点：<ul><li>将计算机的应用提高到了一个更高的阶段</li><li>为计算机的推广应用开拓出一个全新的领域</li></ul></li></ul><h3 id="1-5-2-计算机发展前景"><a href="#1-5-2-计算机发展前景" class="headerlink" title="1.5.2 计算机发展前景"></a>1.5.2 计算机发展前景</h3><h4 id="趋势："><a href="#趋势：" class="headerlink" title="趋势："></a>趋势：</h4><ul><li>巨型化</li><li>微型化</li><li>网络化</li><li>智能化</li></ul><h4 id="1-巨型化："><a href="#1-巨型化：" class="headerlink" title="1.巨型化："></a>1.巨型化：</h4><ul><li>原因：<ul><li>航空航天、气象预报、地震分析、原子裂变、生物工程等领域中<ul><li>大型科学计算和数据处理的需要</li><li>对超大规模、高性能巨型计算机提出永无止境的性能要求</li></ul></li></ul></li><li>实例：<ul><li>日本NEC公司2002年制造的Earth-Simulator超级计算机<ul><li>由5120个处理器构成</li><li>每秒能完成35亿次的浮点运算</li><li>它是世界上最快的计算机</li></ul></li></ul></li></ul><h4 id="2-微型化："><a href="#2-微型化：" class="headerlink" title="2.微型化："></a>2.微型化：</h4><ul><li>计算机向微型化、高性能、多用途方向发展</li><li>原因：<ul><li>微处理器芯片性能不断提高<ul><li>eg：奔腾4芯片主频已达到3GHz以上</li><li>目前微处理器芯片计算能力已经超过早期巨型机计算能力</li></ul></li><li>微型机所需的配套期间的性能也在不断提高<ul><li>如：<ul><li>主存芯片的集成度、读写速度和数据传输率</li><li>光盘、移动硬盘和硬盘的容量、速度和数据传输率</li><li>显示器的综合性能</li><li>各种多媒体和大量预装软件等</li></ul></li></ul></li></ul></li></ul><h4 id="3-网络化："><a href="#3-网络化：" class="headerlink" title="3.网络化："></a>3.网络化：</h4><ul><li>原因：<ul><li>Internet建立与信息高速公路崛起<ul><li>使人类社会处理和传播信息能力大大增强</li></ul></li><li>为适应网络化需要<ul><li>可移动式计算机及网络配套用的硬件与软件不断推出新产品<ul><li>eg：<ul><li>调制解调器，声卡</li><li>视频卡，电源等装置</li></ul></li></ul></li></ul></li></ul></li><li>将成为 信息时代和知识经济时代强大的助推器</li></ul><h4 id="4-智能化："><a href="#4-智能化：" class="headerlink" title="4.智能化："></a>4.智能化：</h4><ul><li><p>应用：</p><ul><li>计算机科学与控制论、仿生学、心理学等等相结合</li><li>用计算机模拟人类的某些智能行为<ul><li>如触觉、嗅觉、视觉等感觉功能</li><li>对声音、图像、图形及其他模式的识别能力</li><li>提供只是进行推理和自我学习的能力等等</li></ul></li></ul></li><li><p>优点：</p><ul><li><p>使计算机不但能储存、计算和处理数据</p></li><li><p>而且在模式识别、定理证明、学习研究、联想探索、语言理解等领域都成为人类助手</p></li></ul></li></ul><h4 id="计算机发展特点："><a href="#计算机发展特点：" class="headerlink" title="计算机发展特点："></a>计算机发展特点：</h4><ul><li><p>新型元器件、体系结构及实现技术的发展，将大大提高计算机系统性能及性能价格比</p><ul><li>eg：<ul><li>集成电路纳米极微细加工技术<ul><li>促使提高半导体各种芯片集成度、速度</li></ul></li><li>光电子器件与生物器件若产生<ul><li>将提高计算机运算速度</li></ul></li><li>计算机辅助技术及信息工艺技术应用<ul><li>将使计算机整体性能大幅提高</li></ul></li></ul></li></ul></li><li><p>计算机与通信技术融合与渗透，将加速人类社会信息化进程</p><ul><li>全球性计算机联网<ul><li>促进信息资源的开发与利用</li></ul></li><li>计算机成为人类生活必需品<ul><li>计算机科学与技术成为人类必须学习与具备基础知识</li></ul></li></ul></li><li><p>以智能化、集成化、自动化、并行化、开放化、自然化为标志的</p><ul><li>计算机软件新技术的而深入研究、开发与利用</li><li>不但将软件的功能与性能迅速提高</li><li>还将解决软件生产率低下的问题<ul><li>软件理论与软件工程发展<ul><li>将从理论与实践两方面解决计算机系统开发的软件瓶颈问题</li></ul></li><li>信息产业与软件产业将成为新的经济增长点<ul><li>成为国民经济的支柱产业</li></ul></li></ul></li></ul></li><li><p>在Internet与信息高速公路迅速发展普及形势下</p><ul><li>为保证信息资源共享</li><li>计算机系统与网络的互操作性、开放性、标准化将受到高度重视</li></ul></li><li><p>完全新型的计算机不断问世</p><ul><li>传统计算机：<ul><li>基本工作方式：<ul><li>是顺序执行指令的串行工作方式</li></ul></li><li>将导致传统计算机在并行处理、字符处理、知识处理等方面的低效能</li></ul></li><li>为突破传统的存储程序计算机结构的局限性<ul><li>人们研究开发了一些非传统计算机</li><li>例如：<ul><li>数据流计算机、归约机、</li><li>逻辑推理机、神经计算机等</li></ul></li></ul></li><li>为进一步提高计算机系统的性能<ul><li>研究开发不采用传统电子器件的计算机也是一个重要方向与课题</li><li>eg：<ul><li>光计算机</li><li>生物计算机</li><li>量子计算机</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 绿皮书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-10-可靠性测试</title>
      <link href="/posts/41234.html"/>
      <url>/posts/41234.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件可靠性定义"><a href="#软件可靠性定义" class="headerlink" title="软件可靠性定义"></a>软件可靠性定义</h2><ul><li>软件可靠性<ul><li>是软件系统在规定的时间内及规定的环境条件下</li><li>完成规定功能的能力</li></ul></li></ul><h2 id="软件可靠性三要素"><a href="#软件可靠性三要素" class="headerlink" title="软件可靠性三要素"></a>软件可靠性三要素</h2><ul><li>规定的时间</li><li>规定的运行环境条件</li><li>规定的功能</li></ul><h2 id="可靠性的度量"><a href="#可靠性的度量" class="headerlink" title="可靠性的度量"></a>可靠性的度量</h2><ul><li>可靠性的最常用的度量<ul><li>是平均无故障时间</li></ul></li><li>例如：<ul><li>通过压力测试</li><li>并借助<ul><li>软件失效模式</li><li>影响分析<ul><li>来获得有关可靠性数据</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.9 容错性测试</title>
      <link href="/posts/54896.html"/>
      <url>/posts/54896.html</url>
      
        <content type="html"><![CDATA[<h2 id="容错性测试的分类"><a href="#容错性测试的分类" class="headerlink" title="容错性测试的分类"></a>容错性测试的分类</h2><ul><li>负面测试</li><li>故障转移测试</li></ul><h2 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h2><ul><li><p>容错性测试就是</p><ul><li>在各种异常条件下对系统的功能进行测试</li><li>以检验系统是否具有防护性的举措或者某种灾难性恢复的手段或能力</li></ul></li><li><p>容错性可分为两个层次：</p><ul><li>功能层次的容错性测试<ul><li>也称 <strong>负面</strong> 测试<ul><li>negative test</li></ul></li><li>或 <strong>例外</strong> 测试<ul><li>exception test</li></ul></li></ul></li><li>系统层次的容错性测试<ul><li>主要是<ul><li>灾难恢复性测试</li><li>故障转移测试</li></ul></li></ul></li></ul></li></ul><h2 id="负面测试"><a href="#负面测试" class="headerlink" title="负面测试"></a>负面测试</h2><ul><li><p>负面测试</p><ul><li>是从<strong>逆向思维</strong>出发</li><li>检查系统在 <strong>异常条件</strong> 下或用户的 <strong>非法操作</strong> 下系统是如何 <strong>响应</strong> 的</li><li>是否有 <strong>异常行为</strong> 或执行了 <strong>不应该执行的动作</strong></li></ul></li><li><p>无效等价类的测试用例就是一种 <strong>负面的测试</strong></p></li><li><p>在一些 <strong>异常的</strong> 或 <strong>恶劣</strong>的条件下进行操作</p></li><li><p><strong>探索式</strong> 测试</p></li></ul><h2 id="故障转移机制"><a href="#故障转移机制" class="headerlink" title="故障转移机制"></a>故障转移机制</h2><p><img src="/posts/54896/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6.jpg" alt="故障转移机制"></p><h2 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h2><ul><li>故障转移测试<ul><li>就是验证 <strong>故障转移机制</strong> 能否 <strong>正常实现</strong>，满足事先的设计要求</li><li>是在 <strong>软件系统发生故障</strong> 的情况下<ul><li>去检验系统的恢复能力</li><li>验证系统已保存的用户数据是否丢失</li><li>系统和数据是否能尽快恢复或在指定时间内恢复</li><li>包括<ul><li>验证重新初始化</li><li>检查点</li><li>数据恢复</li><li>重新启动<ul><li>等机制的正确性</li></ul></li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美国文学绪论</title>
      <link href="/posts/28139.html"/>
      <url>/posts/28139.html</url>
      
        <content type="html"><![CDATA[<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ol><li>The Literature of Colonial America<ul><li>Puritan Thoughts</li></ul></li><li>The Literature of Reason and Revolution<ul><li>American Enlightenment</li><li>Benjamin Franklin: The Autobiography</li><li>Philip Freneau:The Wild Honey Suckle </li></ul></li><li>The Literature of Romanticism<ul><li>American Romanticism</li><li>Washington Irving: The Legend of Sleepy Hollow</li><li>William Cullen Bryant:To a Waterfowl</li><li>Edgar Allan Poe: To Helen; Annabel Lee;The Fall of the House of Usher</li><li>Transcendentalism</li><li>Henry David Thoreau:Walden</li><li>Nathaniel Hawthorne :The Scarlet Letter</li><li>Herman Melville:Moby Dick</li><li>Henry Wadsworth Longfellow:A Psalm of Life</li></ul></li><li>The Literature of Realism<ul><li>American Realism</li><li>free verse</li><li>Walt Whitman: Song of Myself</li><li>Emily Dickinson:I heard a Fly buzz—when I died</li><li>Mark Twain:The Adventures of Tom Sawyer</li><li>Henry James:The Portrait of a Lady</li><li>American Naturalism</li><li>Jack London:The Sea-Wolf,Martin Eden</li><li>Theodore Dreiser:Sister Carrie</li></ul></li><li>Twentieth-Century Literature<ul><li>Modernism</li><li>Imagism</li><li>Ezra Pound:In a Station of the Metro</li><li>Robert Frost:The Road Not Taken;Stopping by Woods on a Snowy Evening</li><li>Carl Sandburg:Chicago</li><li>F.Scott Fitzgerald:The Great Gatsby</li><li>Ernest Hemingway:A Farewell to Arms</li><li>John Steinbeck:The Grapes of Wrath</li><li>William Faulkner:A Rose for Emily</li></ul></li></ol><h2 id="The-Literature-of-Colonial-America"><a href="#The-Literature-of-Colonial-America" class="headerlink" title="The Literature of Colonial America"></a>The Literature of Colonial America</h2><h3 id="historical-introduction"><a href="#historical-introduction" class="headerlink" title="historical introduction"></a>historical introduction</h3><ul><li><p>The colonial period stretched roughly from the settlement of America in the early 17th century through the end of the 18th.</p><ul><li>The first permanent settlement in America was established by English in 1607.</li><li>(A group of people was sent by the English <strong>King James I</strong> to hunt for <strong>gold</strong>.They arrived at Virginia in 1607.They named the <strong>James River</strong> and bulid the <strong>James town</strong>.)</li></ul></li><li><p>The pre-revolutionary writing in the colonies was essentially of two kinds:   分为两类</p><ol><li>Practical matter-of-fact accounts of farming,hunting,travel,etc.designed to inform people “at home” what life was like in the new world,and,often,to induce their immigration</li><li>Highly theoretical,generally polemical,discussions of religious questions</li></ol></li></ul><h3 id="The-first-American-writer"><a href="#The-first-American-writer" class="headerlink" title="The first American writer"></a>The first American writer</h3><ul><li><p>The first writings that we call American were the narratives and journals of these settlements.They wrote about their voyage to the new land,their lives in the new land,their dealings with indians.</p></li><li><p>Captain John Smith is the first American writer.</p></li><li><p>A true Relation of such Occurrences and Accidents of Note as Hath Happened in verginia since the First Planting of That Colony.(1608)</p></li><li><p>A Map of virginia: A Description of the Country(1612)</p></li><li><p>General History of Virginia(1624):the Indian princess Pocahontas.</p></li><li><p><strong>Captain John Smith</strong></p><ul><li>was one of the first early 17th century British settlers in North America.</li><li>One of the things he wrote about that has become an American legend was his capture by the Indians and his rescue by the famous Indian Princess,Pocahontas.</li><li>宝嘉康蒂</li></ul></li></ul><h3 id="Puritan-Thoughts-（重点）"><a href="#Puritan-Thoughts-（重点）" class="headerlink" title="Puritan Thoughts   （重点）"></a>Puritan Thoughts   （重点）</h3><ul><li>the origin of puritan<ul><li>in the mediaeval Europe,there was widespread religious revolution.In the 16th Century,the English King Henry VIII(At that time)，the Catholics were not allowed to divorce unless they have the Pope’s permission.</li><li>Henry VIII wanted to divorce his wife because she couldn‘t bear him a son.But the pope didn’t allow him    to divorce,so he broke away the roman catholics Church&amp;established the Church of England.</li><li>But there was no radical difference between the doctrines of the Church of England and the Catholic Church.A group of people thought the church of England was too Catholic and wanted to purify the church.</li><li>Then came the name Puritans.</li></ul></li></ul><ul><li>Puritanism is the practises and beliefs on the Puritans.<ul><li>The puritans were originally members of a division of the Protestant Church,who came into existence in the reigns of Queen Elizabeth and King James I.</li><li>The first settlers who became the founding fathers of the American nation were quite a few of them Puritans.</li><li>They came to America out of various reasons,but it should be remembered that they were a group of serious,religious people,advocating highly religious and moral principles.As the word itself hints,Puritans wanted to purify their religous beliefs and practices.They felt that the Church of England was too close to the Church of Rome in doctrine from worship,and organization of authority.</li></ul></li></ul><p>主要教义 predestination</p><ol><li>God’s elect<ul><li>Puritans believed they are predestined before they were born.</li><li>Nothing or no good work can change their fate.</li><li>They believed the success of one’s business is the sign to show he is the God‘s elect.So the Puritans works very hard,spend very little and invest more for the future business.They lived a very frugal life.This is their ethics.</li></ul></li><li>Original sin and total depravity<ul><li>Man is born sinful.This determines some puritans pessimistic attitude towards life.</li></ul></li><li>Limited atonement(the salvation of a selected few)</li><li>theocracy  政教合一<ul><li>They combined state with religion.Their government is at least not a liberal one</li><li>The puritans established American tradition–intolerant moralism.They strictly punished drunks,adultery&amp;heretics</li><li>Puritans changed gradually due to the severity of frontier environment.</li></ul></li></ol><h4 id="影响Influence"><a href="#影响Influence" class="headerlink" title="影响Influence"></a>影响Influence</h4><ol><li>its optimism<ul><li>American literature was from the outset conditioned by the Puritan heritage.It can be said American literature is based on the Biblical myth.After Adam and Eve were driven out of the Garden of Eden,man have on illusion to restore the paradise.The puritans,after arriving at America,believing that God must have sent them to this new land to restore the lost paradise,to build the wildness into a new Garden of Eden.Fired with such a strong sense of mission,they treated life with a tremendous amount of optimism.The optimistic Puritans has exerted a great influence on American literature.</li></ul></li><li>Puritan’s metaphorical mode of perception changed gradually into a literary symbolism.</li></ol><h3 id="American-Dream"><a href="#American-Dream" class="headerlink" title="American Dream"></a>American Dream</h3><ul><li><p>The <strong>American</strong> <strong>Dream</strong> is a national ethos of the United States,a set of ideals in which freedom includes….</p></li><li><p>The idea of the American Dream is rooted in the United States Declaration of Independence which proclaims that”all men are created equal” and that they are “endowed by their Creator with certain inalienable Rights”including “life,Liberty and the pursuit of Happiness.”</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美国文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.8 安全性测试</title>
      <link href="/posts/41073.html"/>
      <url>/posts/41073.html</url>
      
        <content type="html"><![CDATA[<h2 id="安全性测试定义"><a href="#安全性测试定义" class="headerlink" title="安全性测试定义"></a>安全性测试定义</h2><h3 id="软件安全性测试就是"><a href="#软件安全性测试就是" class="headerlink" title="软件安全性测试就是"></a>软件安全性测试就是</h3><ul><li>检验系统权限设置有效性</li><li>防范违法入侵的能力</li><li>数据备份和恢复能力等</li><li>设法找出各种安全性漏洞</li></ul><h3 id="漏洞举例："><a href="#漏洞举例：" class="headerlink" title="漏洞举例："></a>漏洞举例：</h3><ul><li>跨站点脚本(cross-site scripting , XSS)攻击</li><li>SQL注入式漏洞</li><li>缓冲区溢出</li><li>不安全的数据存储或传递</li><li>不安全的配置管理</li><li>有问题的访问控制、权限分配有问题</li><li>口令设置不严、包括长度、构成和更新频</li><li>暴露的端口或入口</li></ul><h2 id="安全性测试的范围"><a href="#安全性测试的范围" class="headerlink" title="安全性测试的范围"></a>安全性测试的范围</h2><ul><li>系统级别的安全性</li><li>应用程序级别的安全性（important）<ul><li>用户权限</li><li>数据输入验证</li><li>敏感数据加密</li><li>数据存储安全性</li><li>用户口令</li><li>验证系统的日志文件是否得到保护</li></ul></li></ul><h2 id="web安全性测试"><a href="#web安全性测试" class="headerlink" title="web安全性测试"></a>web安全性测试</h2><ul><li>跨站脚本攻击</li><li>SQL注入式攻击</li><li>URL和API的身份验证</li><li>其他</li></ul><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><ul><li>在页面某些输入域中使用跨站脚本（写入一段javascript）来发送恶意代码给没有发觉的用户，让浏览器执行document.write等危险指令<ul><li>窃取用户的资料或者信息</li></ul></li></ul><h2 id="输入域验证"><a href="#输入域验证" class="headerlink" title="输入域验证"></a>输入域验证</h2><ul><li>防止<ul><li>HTML标签：&lt;…&gt;…&lt;/…&gt;</li><li>转义字符：&amp;amp(&amp;);&amp;lt(&lt;);&amp;gt(&lt;);&amp;nbsp(空格)</li><li>脚本语言，如javascript <script language="javascript">......</script></li><li>特殊字符： ‘ ‘ &lt;&gt; /</li></ul></li><li>最好进行更严格的保护和验证</li></ul><h2 id="SQL注入式攻击"><a href="#SQL注入式攻击" class="headerlink" title="SQL注入式攻击"></a>SQL注入式攻击</h2><ul><li>根据SQL语句的编写规则，附加一个永远为”真”的条件<ul><li>使系统中的某个认证条件总是成立</li><li>从而欺骗系统、躲过认证</li><li>进而侵入系统</li></ul></li></ul><h2 id="安全性测试工具的评估标准"><a href="#安全性测试工具的评估标准" class="headerlink" title="安全性测试工具的评估标准"></a>安全性测试工具的评估标准</h2><ul><li>支持常见的web服务器平台</li><li>能同时提供对源代码和二进制文件进行扫描的功能</li><li>漏洞检测和纠正分析</li><li>检测实时系统的问题</li><li>不改变被测试的软件，不影响代码</li><li>良好的报告</li><li>非安全专业认识也易于上手</li><li>可管理部署的多种扫描器、尽可能小的错误误差等</li></ul><h2 id="常见的安全性测试工具"><a href="#常见的安全性测试工具" class="headerlink" title="常见的安全性测试工具"></a>常见的安全性测试工具</h2><p><img src="/posts/41073/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.jpg" alt="安全性测试工具"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7 兼容性测试</title>
      <link href="/posts/14844.html"/>
      <url>/posts/14844.html</url>
      
        <content type="html"><![CDATA[<h2 id="兼容性测试的定义"><a href="#兼容性测试的定义" class="headerlink" title="兼容性测试的定义"></a>兼容性测试的定义</h2><p>兼容性测试</p><ul><li>是在 <strong>不同软硬件环境</strong> 下，验证软件系统能否正常地运行</li><li>这些软硬件一般有但不限于以下种类：<ul><li>硬件 hardware</li><li>操作系统 </li><li>数据库 </li><li>浏览器 </li><li>第三方系统</li><li>内部业务系统</li><li>自身系统的不同版本的用户数据</li></ul></li></ul><h2 id="兼容性测试的内容"><a href="#兼容性测试的内容" class="headerlink" title="兼容性测试的内容"></a>兼容性测试的内容</h2><ul><li>硬件兼容性的测试</li><li>数据兼容性的测试</li><li>系统版本之间的兼容性</li></ul><ul><li>向后兼容：<ul><li>指新发布的软件版本可以使用该软件的以前版本所产生的数据</li></ul></li><li>向前兼容：<ul><li>指在设计和开发一个新版本时，考虑如何和未来版本的数据兼容</li></ul></li></ul><h2 id="系统兼容性测试"><a href="#系统兼容性测试" class="headerlink" title="系统兼容性测试"></a>系统兼容性测试</h2><ul><li>B/S系统兼容性测试（考虑兼容哪个浏览器）</li><li>C/S系统兼容性测试（考虑兼容哪个客户端）</li></ul><h2 id="数据兼容性测试"><a href="#数据兼容性测试" class="headerlink" title="数据兼容性测试"></a>数据兼容性测试</h2><ul><li>是否遵守统一的国际标准、国家标准或业界认可的事实标准等</li><li>提供相应的导入、导出功能</li><li>剪贴板或ODBC等类似方法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 性能测试工具</title>
      <link href="/posts/30377.html"/>
      <url>/posts/30377.html</url>
      
        <content type="html"><![CDATA[<h1 id="特性及其使用"><a href="#特性及其使用" class="headerlink" title="特性及其使用"></a>特性及其使用</h1><ul><li>能模拟实际用户的 <strong>操作行为</strong>，<ul><li><strong>记录和回放</strong> <strong>多用户</strong> 测试中的 <strong>事务处理过程</strong></li><li><strong>自动生成</strong>相应的 <strong>测试脚本</strong></li></ul></li><li>能针对 <strong>脚本</strong> 进行修改<ul><li>增加 <strong>逻辑控制</strong></li><li>完成 <strong>参数化</strong> 和 <strong>数据关联</strong></li></ul></li><li>可以设置不同的 <strong>应用环境和场景</strong>，通过 <strong>虚拟用户</strong> 执行相应的测试脚本</li><li>通过 <strong>系统监控工具</strong> 获得系统性能的相关指标的值</li></ul><h1 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h1><h2 id="nGrinder"><a href="#nGrinder" class="headerlink" title="nGrinder"></a>nGrinder</h2><ul><li>是一个基于Grinder 开发的、易于管理和使用的、分布式性能测试系统</li></ul><h2 id="Flood"><a href="#Flood" class="headerlink" title="Flood"></a>Flood</h2><ul><li>是人们经常使用的一个Web性能测试工具</li></ul><h2 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h2><ul><li>是一个开源的web压力测试和评测系统</li></ul><h2 id="openSTA"><a href="#openSTA" class="headerlink" title="openSTA"></a>openSTA</h2><ul><li>可以模拟大量的虚拟用户来完成性能测试</li><li>并通过script来完成丰富的自定义设置</li></ul><h2 id="DBMonster"><a href="#DBMonster" class="headerlink" title="DBMonster"></a>DBMonster</h2><ul><li>是一个生成随机数据</li><li>用来测试SQL数据库的压力测试工具</li></ul><h2 id="LoadSim"><a href="#LoadSim" class="headerlink" title="LoadSim"></a>LoadSim</h2><ul><li>网络应用程序的负载模拟器</li></ul><h1 id="商业工具"><a href="#商业工具" class="headerlink" title="商业工具"></a>商业工具</h1><ul><li>HP LoadRunner</li><li>IBM Rational performance Tester</li><li>Radview webload</li><li>compuware QA Load</li><li>Quest Benchmark Factory</li><li>微软WAS (web access stress test)</li><li>Paessler Webserver Stress Tool</li><li>MINQ PureLoad</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 压力测试</title>
      <link href="/posts/27406.html"/>
      <url>/posts/27406.html</url>
      
        <content type="html"><![CDATA[<h1 id="压力测试的定义"><a href="#压力测试的定义" class="headerlink" title="压力测试的定义"></a>压力测试的定义</h1><ul><li>是在系统（eg：CPU、内存、网络带宽等）处于 <strong>饱和</strong> 状态下</li><li>测试系统<ul><li>是否还具有正常的 <strong>会话</strong> 能力、<strong>数据处理</strong> 能力</li><li>或 是否会 <strong>出现错误</strong></li></ul></li><li>以检查软件系统对 <strong>异常情况的抵抗</strong> 能力</li><li>找出 <strong>性能瓶颈</strong>、<strong>功能不稳定性</strong> 等问题</li></ul><h1 id="压力测试的类型"><a href="#压力测试的类型" class="headerlink" title="压力测试的类型"></a>压力测试的类型</h1><h2 id="稳定性压力测试"><a href="#稳定性压力测试" class="headerlink" title="稳定性压力测试"></a>稳定性压力测试</h2><ul><li>高负载下持续运行24小时以上的压力测试</li></ul><h2 id="破坏性压力测试"><a href="#破坏性压力测试" class="headerlink" title="破坏性压力测试"></a>破坏性压力测试</h2><ul><li>通过不断加载的手段</li><li>快速总成系统的崩溃</li><li>让问题尽快地暴露出来</li></ul><h2 id="渗入测试"><a href="#渗入测试" class="headerlink" title="渗入测试"></a>渗入测试</h2><ul><li><p><strong>soak</strong> <strong>test</strong></p></li><li><p>通过长时间运行</p></li><li><p>使问题逐渐渗透出来</p></li><li><p>从而发现</p><ul><li><p>内存泄漏</p></li><li><p>垃圾收集 <strong>GC</strong></p></li><li><p>或系统的其他问题</p><p>以检验系统的 <strong>健壮性</strong></p></li></ul></li></ul><h2 id="峰谷测试"><a href="#峰谷测试" class="headerlink" title="峰谷测试"></a>峰谷测试</h2><ul><li><strong>peak-rest test</strong></li><li>采用 <strong>高低突变加载方式</strong> 进行<ul><li>先加载到 <strong>高水平</strong> 的负载</li><li>然后 <strong>急剧降低</strong> 负载</li><li><strong>稍微平息</strong> 一段时间</li><li>再加载到 <strong>高水平</strong> 的负载</li></ul></li><li><strong>重复</strong> 这样的过程</li><li>容易发现问题的 <strong>蛛丝马迹</strong></li><li>最终找到问题的 <strong>根源</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 性能测试</title>
      <link href="/posts/11040.html"/>
      <url>/posts/11040.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何确定性能需求"><a href="#如何确定性能需求" class="headerlink" title="如何确定性能需求"></a>如何确定性能需求</h1><h2 id="性能指标预期来源"><a href="#性能指标预期来源" class="headerlink" title="性能指标预期来源"></a>性能指标预期来源</h2><ol><li><strong>最终用户的体验</strong>      eg:2-5-10原则</li><li><strong>商业需求</strong>        eg：”比竞争对手的产品好”</li><li><strong>技术需求</strong>        eg：”cpu使用率不超过70%”</li><li><strong>标准要求</strong></li></ol><h2 id="包含下列性能指标："><a href="#包含下列性能指标：" class="headerlink" title="包含下列性能指标："></a>包含下列性能指标：</h2><ol><li><strong>时间</strong> time<ul><li>响应时间</li><li>页面下载时间等等</li></ul></li><li><strong>容量</strong> capacity<ul><li>正常工作能承受的最大负载</li><li>eg：<ul><li>最大并发用户数</li><li>最大数据容量</li><li>最大在线用户数</li></ul></li></ul></li><li><strong>吞吐量</strong> throughput<ul><li>eg：<ul><li>每秒请求数RPS</li><li>每秒点击数HPS</li><li>每秒事务数TPS</li><li>每秒接受或发送的数据量等</li></ul></li></ul></li><li><strong>系统资源利用率</strong> utilization<ul><li>eg：<ul><li>cpu</li><li>memory<ul><li>使用率</li></ul></li><li>等等</li></ul></li></ul></li></ol><h2 id="不同角色对于性能指标关注什么"><a href="#不同角色对于性能指标关注什么" class="headerlink" title="不同角色对于性能指标关注什么"></a>不同角色对于性能指标关注什么</h2><h3 id="用户："><a href="#用户：" class="headerlink" title="用户："></a>用户：</h3><ul><li>响应时间</li></ul><h3 id="产品市场团队"><a href="#产品市场团队" class="headerlink" title="产品市场团队"></a>产品市场团队</h3><ul><li>容量</li><li>数据吞吐量</li></ul><h3 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h3><ul><li>系统资源占用率</li></ul><h1 id="性能测试类型"><a href="#性能测试类型" class="headerlink" title="性能测试类型"></a>性能测试类型</h1><h2 id="性能验证测试"><a href="#性能验证测试" class="headerlink" title="性能验证测试"></a>性能验证测试</h2><ul><li>验证事先已定义的系统性能指标、系统能否满足系统的性能需求</li></ul><h2 id="性能基准测试"><a href="#性能基准测试" class="headerlink" title="性能基准测试"></a>性能基准测试</h2><ul><li>在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线</li></ul><h2 id="性能规划测试"><a href="#性能规划测试" class="headerlink" title="性能规划测试"></a>性能规划测试</h2><ul><li>在多种 <strong>特定</strong> 的环境下，获得 <strong>不同配置</strong> 的系统的 <strong>性能指标</strong> ，从而决定在系统部署时采用什么样的 <strong>软</strong>、<strong>硬件配置</strong></li></ul><h2 id="容量测试"><a href="#容量测试" class="headerlink" title="容量测试"></a>容量测试</h2><ul><li>可以看作是 <strong>性能</strong> 的测试的一种</li><li>因为系统的容量可以看作 <strong>系统性能指标</strong> 之一</li></ul><h1 id="性能测试步骤"><a href="#性能测试步骤" class="headerlink" title="性能测试步骤"></a>性能测试步骤</h1><ol><li>确定性能测试 <strong>需求</strong></li><li><strong>计划和设计测试</strong> ；包括确定关键业务流程、测试类型和测试方法，选择合适的测试工具、设计测试场景等等</li><li><strong>测试工具</strong> 的选择</li><li>配置 <strong>测试环境</strong>、尽量接近实际运行环境、即建立仿真环境作为性能测试环境，测试结果才能可信</li><li>实现 <strong>测试设计</strong>（开发测试脚本）</li><li><strong>执行测试</strong></li><li><strong>分析</strong> 测试结果</li><li>重复4-6步骤，直至 <strong>测试计划完成</strong> ，结果 <strong>满意</strong></li><li>提交 <strong>性能测试报告</strong></li></ol><h1 id="一些常见的性能问题"><a href="#一些常见的性能问题" class="headerlink" title="一些常见的性能问题"></a>一些常见的性能问题</h1><ul><li><strong>资源泄漏</strong>，包括内存泄漏</li><li><strong>资源瓶颈</strong>，内部资源（线程、放入池的对象）变得稀疏</li><li>cpu使用率达到<strong>100</strong>%、系统 <strong>被锁定</strong> （eg：鼠标键盘不响应）等等</li><li>线程 <strong>死锁</strong>、线程 <strong>阻塞</strong> 等等</li><li><strong>数据库连接</strong> 成为性能瓶颈（数据库连接时间过长）</li><li>查询 <strong>速度慢</strong> 或 列表 <strong>效率低</strong>（eg:没用上索引）</li><li>受 <strong>外部系统影响</strong> 越来越大</li></ul><h1 id="容量测试-1"><a href="#容量测试-1" class="headerlink" title="容量测试"></a>容量测试</h1><h2 id="容量测试的定义"><a href="#容量测试的定义" class="headerlink" title="容量测试的定义"></a>容量测试的定义</h2><ul><li><p><strong>capacity</strong> test</p></li><li><p>通过负载测试或其它测试方法，预先分析出反应软件系统应用特征的某项指标的极限值（eg：最大并发用户数、数据库记录数等等）</p></li><li><p>在其极限值状态下系统主要功能还能保持正常运行</p></li></ul><h2 id="与其他测试的关系"><a href="#与其他测试的关系" class="headerlink" title="与其他测试的关系"></a>与其他测试的关系</h2><ul><li>属于性能测试的一种</li></ul><h2 id="采用的方法"><a href="#采用的方法" class="headerlink" title="采用的方法"></a>采用的方法</h2><ul><li>一般采用 逐步加载 的负载测试方法</li><li>也可以<ul><li>先采用 <strong>逐步加载</strong> 的方式</li><li>获得一个 基本的 <strong>容量值或容量范围</strong></li><li>再考虑用 <strong>一次性加载方式</strong></li><li>来决定 <strong>实际可支持</strong> 的 <strong>容量值</strong></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 负载测试技术</title>
      <link href="/posts/19168.html"/>
      <url>/posts/19168.html</url>
      
        <content type="html"><![CDATA[<h1 id="pre：演示一个使用JMETER的例子"><a href="#pre：演示一个使用JMETER的例子" class="headerlink" title="pre：演示一个使用JMETER的例子"></a>pre：演示一个使用JMETER的例子</h1><h2 id="背景要求："><a href="#背景要求：" class="headerlink" title="背景要求："></a>背景要求：</h2><p>当120个用户同时访问ecshop,其中所有的用户会访问首页并搜索商品</p><p>要求平均响应时间&lt;=2000ms,并且cpu的利用率&lt;=75%</p><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>先启动xapp，把apache和mysql打开</p><p><img src="/posts/19168/Xapp.png" alt="Xapp"></p><p>jmeter启动测试计划 <code>pre7.3</code></p><p><img src="/posts/19168/jmeter.png" alt="jmeter"></p><ul><li><code>User</code> <code>Defined</code> <code>Variable</code><ul><li>用户定义变量</li></ul></li><li><code>HTTP Request Defaults</code><ul><li>HTTP请求的默认值</li></ul></li><li><code>HTTP Cookie Manager</code><ul><li>http cookie管理器</li></ul></li><li><code>Thread Group</code><ul><li>线程</li><li>模仿用户给服务器发请求</li><li>![thread group](7-3-负载测试技术/thread group.png)<ul><li><code>number of threads</code>:<ul><li>线程数</li></ul></li><li><code>ramp-up preriod</code><ul><li>执行完这些线程所用的时间 （秒数）</li></ul></li><li><code>loop</code> <code>count</code><ul><li>循环次数</li><li>infinite:无限循环</li></ul></li></ul></li></ul></li></ul><p><img src="/posts/19168/%E9%87%87%E6%A0%B7%E5%99%A8.png" alt="采样器"></p><p><code>uniform random timer</code></p><p><img src="/posts/19168/%E5%AE%9A%E6%97%B6%E5%99%A8.png" alt="定时器"></p><ul><li>采样器 就是发请求出去</li><li>有请求发出去，则自然要有监听器</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 负载测试 压力测试 性能测试</title>
      <link href="/posts/60505.html"/>
      <url>/posts/60505.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景及其分析"><a href="#背景及其分析" class="headerlink" title="背景及其分析"></a>背景及其分析</h1><h2 id="性能调优："><a href="#性能调优：" class="headerlink" title="性能调优："></a>性能调优：</h2><ul><li>指系统性能改善是<ul><li>测试</li><li>调整</li><li>再测试</li><li>再调整</li><li>…<ul><li>一个持续改进的过程</li></ul></li></ul></li><li>需要借助负载测试方法</li></ul><h2 id="负载测试-load-test"><a href="#负载测试-load-test" class="headerlink" title="负载测试 load test"></a>负载测试 load test</h2><ul><li>可看成是 <strong>性能测试</strong> 采用的一种技术</li></ul><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>可看作 <strong>负载测试</strong> 的一种</li><li>即  <strong>高负载</strong> 下的 <strong>负载测试</strong></li></ul><h2 id="容量测试-capacity-test"><a href="#容量测试-capacity-test" class="headerlink" title="容量测试 capacity test"></a>容量测试 capacity test</h2><ul><li>用 <strong>负载测试</strong> 技术来实现</li><li><strong>压力测试</strong> 可附带做 <strong>容量测试</strong></li></ul><h2 id="负载测试与性能测试相似性"><a href="#负载测试与性能测试相似性" class="headerlink" title="负载测试与性能测试相似性"></a>负载测试与性能测试相似性</h2><ul><li>测试方法接近</li><li>都关注系统性能</li><li>多数情况下用相同测试工具</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="负载测试-load-rest"><a href="#负载测试-load-rest" class="headerlink" title="负载测试 load rest"></a>负载测试 load rest</h2><ul><li>通过模拟实际软件系统所承受的<ul><li>负载条件</li><li>改变系统负载大小</li><li>负载方式<ul><li>来发现系统中所存在的问题</li></ul></li></ul></li><li>负载大小可以是<ul><li>并发请求的数量(RPS 每秒请求数)</li><li>并发用户数量</li><li>数据库大小</li><li>收发数据大小</li><li>等等</li></ul></li></ul><h2 id="压力测试-1"><a href="#压力测试-1" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>是在 <strong>强负载</strong> 情况下稳定性进行测试</li><li>查看应用系统在 <strong>峰值</strong>（瞬间使用高峰）使用情况下的行为表现</li><li>更有效地发现系统 <strong>稳定性的隐患</strong> 和系统在负载峰值的条件下 <strong>功能隐患</strong> 等</li><li>确认系统是否具有良好的 <strong>容错</strong> 能力和 <strong>可恢复</strong> 能力</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>是为了 <strong>获取</strong> 或 <strong>验证</strong> 系统性能指标</li><li>或为了发现 <strong>性能瓶颈</strong> 而进行的测试</li></ul><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><h2 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>测试被测系统是否满足 <strong>预期性能目标</strong></li></ul><h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><ul><li>测试被测试系统</li><li>在 <strong>服务器安全范围</strong> 内的 <strong>最大负载值</strong></li></ul><h2 id="压力测试-2"><a href="#压力测试-2" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>测试被测试系统</li><li>在 <strong>超过服务器安全范围</strong> 所能承受的 <strong>最大压力值</strong></li></ul><h2 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h2><ul><li>测试被测系统在 <strong>长时间的压力</strong> 下的 <strong>稳定性</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程基础知识简介</title>
      <link href="/posts/18088.html"/>
      <url>/posts/18088.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h2><ul><li>包括：<ul><li>需求分析</li><li>系统设计</li><li>系统实现</li><li>测试</li><li>发布</li><li>运行和维护</li><li>升级</li><li>淘汰</li></ul></li></ul><h2 id="软件主要的测试工作"><a href="#软件主要的测试工作" class="headerlink" title="软件主要的测试工作"></a>软件主要的测试工作</h2><ul><li>随着 <strong>系统实现阶段</strong> 的展开而开始</li><li>一直持续到 <strong>产品发布</strong> 之后</li></ul><h2 id="软件的质量保证活动QA"><a href="#软件的质量保证活动QA" class="headerlink" title="软件的质量保证活动QA"></a>软件的质量保证活动QA</h2><ul><li>伴随着软件整个生命周期</li><li>原因：<ul><li>为了度量、跟踪、控制软件产品的质量</li></ul></li></ul><h1 id="2-软件开发流程简述"><a href="#2-软件开发流程简述" class="headerlink" title="2 软件开发流程简述"></a>2 软件开发流程简述</h1><h2 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h2><h3 id="需求分析的定义"><a href="#需求分析的定义" class="headerlink" title="需求分析的定义"></a>需求分析的定义</h3><ul><li>是开发人员经过深入细致的调研和分析，准确理解用户和项目的<ul><li>功能</li><li>性能</li><li>可靠性<ul><li>等具体要求</li></ul></li></ul></li><li>将用户 <strong>非形式的需求</strong> 转化为 <strong>完整的需求定义</strong> </li><li>从而确定系统 <strong>必须做什么</strong> 的过程</li></ul><h3 id="需求分析中需明白的几个概念"><a href="#需求分析中需明白的几个概念" class="headerlink" title="需求分析中需明白的几个概念"></a>需求分析中需明白的几个概念</h3><h4 id="业务需求："><a href="#业务需求：" class="headerlink" title="业务需求："></a>业务需求：</h4><ul><li>是由高层领导提出的业务上要满足的需求</li><li>目的：<ul><li>解决业务通电</li></ul></li><li>通常比较宏观</li></ul><h4 id="用户需求："><a href="#用户需求：" class="headerlink" title="用户需求："></a>用户需求：</h4><ul><li>使用户从自身角度出发，自己所认为的需求</li><li>也可以看作将业务需求具体化之后的需求</li></ul><h4 id="产品需求："><a href="#产品需求：" class="headerlink" title="产品需求："></a>产品需求：</h4><ul><li>是通过分析提炼得到的用户的真实需求</li><li>且符合产品定位的解决方案</li><li>一般来说，产品需求等同于系统需求</li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="系统设计的定义："><a href="#系统设计的定义：" class="headerlink" title="系统设计的定义："></a>系统设计的定义：</h3><ul><li>是根据需求分析的结果</li><li>是对软件的技术实现由粗到细进行设计的过程</li></ul><h3 id="系统设计的两个阶段："><a href="#系统设计的两个阶段：" class="headerlink" title="系统设计的两个阶段："></a>系统设计的两个阶段：</h3><ul><li>概要设计</li><li>详细设计</li></ul><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><h4 id="概要设计的任务："><a href="#概要设计的任务：" class="headerlink" title="概要设计的任务："></a>概要设计的任务：</h4><ul><li>根据系统需求分析得到的系统用例转换为软件结构和数据结构</li></ul><h4 id="概要设计的内容："><a href="#概要设计的内容：" class="headerlink" title="概要设计的内容："></a>概要设计的内容：</h4><ul><li>系统技术架构设计</li><li>功能模块划分和功能设计</li><li>数据库设计</li><li>接口设计</li><li>界面设计</li></ul><h3 id="详细设计："><a href="#详细设计：" class="headerlink" title="详细设计："></a>详细设计：</h3><h4 id="详细设计的定义："><a href="#详细设计的定义：" class="headerlink" title="详细设计的定义："></a>详细设计的定义：</h4><ul><li>对概要设计的细化</li></ul><h4 id="详细设计的内容："><a href="#详细设计的内容：" class="headerlink" title="详细设计的内容："></a>详细设计的内容：</h4><ul><li>算法设计</li><li>函数流程设计</li><li>等等</li></ul><h2 id="2-3-系统实现"><a href="#2-3-系统实现" class="headerlink" title="2.3 系统实现"></a>2.3 系统实现</h2><h3 id="系统实现的定义："><a href="#系统实现的定义：" class="headerlink" title="系统实现的定义："></a>系统实现的定义：</h3><ul><li>即编码</li><li>根据系统设计来进行实际的编码工作</li><li>并得到可以运行的软件产品</li></ul><h2 id="2-4-系统测试"><a href="#2-4-系统测试" class="headerlink" title="2.4 系统测试"></a>2.4 系统测试</h2><h3 id="系统测试的定义："><a href="#系统测试的定义：" class="headerlink" title="系统测试的定义："></a>系统测试的定义：</h3><ul><li>对源代码或可以运行的程序进行检查或执行</li><li>判断被测系统事都存在与需求中的预期不一致的地方</li><li>并加以记录的过程</li></ul><h2 id="2-5-产品发布和运维"><a href="#2-5-产品发布和运维" class="headerlink" title="2.5 产品发布和运维"></a>2.5 产品发布和运维</h2><p>原因：</p><ul><li>软件发布后，可能会产生问题：<ul><li>用户对产品不熟悉造成使用问题</li><li>开发测试不彻底遗留缺陷</li></ul></li></ul><p>因此：</p><ul><li>要对产品运行<ul><li>进行维护</li><li>进行用户培训</li><li>修复缺陷</li><li>等等</li></ul></li></ul><h2 id="2-6-产品升级"><a href="#2-6-产品升级" class="headerlink" title="2.6 产品升级"></a>2.6 产品升级</h2><p>原因：</p><ul><li>随着用户使用的深入</li><li>软件产品可能无法继续使用用户要求</li></ul><p>因此需要：</p><ul><li>对产品进行升级</li><li>增加新的功能和特性</li><li>优化产品性能</li><li>等等</li></ul><h2 id="2-7-产品淘汰"><a href="#2-7-产品淘汰" class="headerlink" title="2.7 产品淘汰"></a>2.7 产品淘汰</h2><p>原因：</p><ul><li>随着技术不断发展，软件产品可能无法适应业务发展</li></ul><p>因此：</p><ul><li>不得不将产品彻底报废、淘汰</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 质量保证与测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 认识软件测试管理</title>
      <link href="/posts/40593.html"/>
      <url>/posts/40593.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-软件质量与测试"><a href="#1-1-软件质量与测试" class="headerlink" title="1.1 软件质量与测试"></a>1.1 软件质量与测试</h2><h3 id="软件质量的概念"><a href="#软件质量的概念" class="headerlink" title="软件质量的概念"></a>软件质量的概念</h3><ul><li>软件质量越来越受到重视</li><li>ANSI/IEEE&lt;软件工程术语的IEEE标准术语表&gt;定义软件质量为<ul><li>“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”</li></ul></li></ul><h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><ul><li><p>软件产品各种质量特性的组合称为软件质量模型</p></li><li><p>常见的软件质量模型</p><ul><li>Boehm模型 1976年</li><li>MCCALL模型 1978年</li><li>ISO9126软件质量模型 1993年</li></ul></li></ul><h3 id="Boehm质量模型"><a href="#Boehm质量模型" class="headerlink" title="Boehm质量模型"></a>Boehm质量模型</h3><ul><li>1976年由Boehm等提出的分层方案</li><li>将软件的质量定义为分层的模型</li></ul><h4 id="boehm质量模型内容"><a href="#boehm质量模型内容" class="headerlink" title="boehm质量模型内容"></a>boehm质量模型内容</h4><ul><li><strong>可维护性</strong><ul><li><strong>可修改性</strong><ul><li><strong>可扩充性</strong></li><li><strong>结构化性</strong></li></ul></li><li><strong>可理解性</strong><ul><li><strong>清晰性</strong></li><li><strong>简单性</strong></li><li><strong>结构化性</strong></li><li><strong>自描述性</strong> 不需要其他培训 软件上的说明足以指引完成使用</li></ul></li><li><strong>可测试性</strong><ul><li><strong>结构化性</strong></li><li><strong>自描述性</strong></li><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>可测试性</strong></li></ul></li></ul></li><li><strong>可用性</strong><ul><li><strong>人类工程</strong><ul><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>健壮性</strong></li></ul></li><li><strong>效率</strong><ul><li><strong>可存取性</strong></li><li><strong>设备效率</strong></li><li><strong>可测试性</strong></li></ul></li><li><strong>可靠性</strong><ul><li><strong>一致性</strong></li><li><strong>健壮性</strong></li><li><strong>完备性</strong></li><li><strong>正确性</strong></li><li><strong>自包含性</strong></li></ul></li></ul></li><li><strong>可移植性</strong><ul><li><strong>自包含性</strong></li><li><strong>设备独立性</strong></li></ul></li></ul><h3 id="MCCALL质量模型"><a href="#MCCALL质量模型" class="headerlink" title="MCCALL质量模型"></a>MCCALL质量模型</h3><ul><li>1979年由McCall等人提出的软件质量模型</li><li>将软件质量的概念建立在11个质量特性之上</li><li>这些质量特性分别是面向软件产品的运行、修正和转移的</li></ul><h3 id="ISO9126质量模型"><a href="#ISO9126质量模型" class="headerlink" title="ISO9126质量模型"></a>ISO9126质量模型</h3><ul><li>软件质量模型可以分为：<ul><li>内部质量和外部质量模型、<ul><li>功能性</li><li>可靠性</li><li>易用性</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li>使用质量模型<ul><li>有效性</li><li>生产性</li><li>安全性</li><li>满意度</li></ul></li></ul></li></ul><h3 id="常见的软件质量特性"><a href="#常见的软件质量特性" class="headerlink" title="常见的软件质量特性"></a>常见的软件质量特性</h3><ol><li>性能Performance<ol><li>系统的响应能力</li><li>即 要经过多长时间才能对某个时间做出响应</li><li>或者在某段时间内系统所能处理的事件个数</li></ol></li><li>可用性Availability<ol><li>系统能正常运行的时间比例</li></ol></li><li>可靠性Rvailability<ol><li>系统在应用或错误面前，在意外或者错误使用的情况下维持软件系统功能特性的能力</li></ol></li><li>健壮性Robustness<ol><li>在处理或者环境中系统能够承受的压力或者变更能力</li></ol></li><li>安全性Security<ol><li>系统向合法用户提供服务的同时能够阻止非授权用户使用企图或拒绝服务的能力</li></ol></li></ol><h3 id="软件质量保证的手段"><a href="#软件质量保证的手段" class="headerlink" title="软件质量保证的手段"></a>软件质量保证的手段</h3><ul><li>软件测试</li><li>软件研发过程保证</li><li>软件研发配置管理</li><li>…</li></ul><h3 id="软件测试-vs-软件质量"><a href="#软件测试-vs-软件质量" class="headerlink" title="软件测试 vs 软件质量"></a>软件测试 vs 软件质量</h3><ul><li>软件测试是保证软件质量的重要手段之一</li><li>软件测试是有计划有组织的活动</li><li>软件测试管理确保测试活动的顺利开展</li></ul><h2 id="1-2-软件测试管理概述"><a href="#1-2-软件测试管理概述" class="headerlink" title="1.2 软件测试管理概述"></a>1.2 软件测试管理概述</h2><h3 id="项目与项目管理"><a href="#项目与项目管理" class="headerlink" title="项目与项目管理"></a>项目与项目管理</h3><ul><li>项目：<ul><li>一系列复杂的并相互关联的活动</li><li>有着一个明确的目标</li><li>必须在特定的时间、预算、资源限定内，依据规范完成</li></ul></li><li>项目管理：<ul><li>在项目活动中运用专门的知识、技能、工具或方法</li><li>使项目能够在有限资源限定条件下，实现预定的目标</li></ul></li><li>范畴：<ul><li>范围管理</li><li>时间管理</li><li>费用管理</li><li>质量管理</li><li>人力资源管理</li><li>风险管理</li><li>沟通管理</li><li>采购与合同管理</li></ul></li></ul><h3 id="软件测试管理-vs-软件项目管理"><a href="#软件测试管理-vs-软件项目管理" class="headerlink" title="软件测试管理 vs 软件项目管理"></a>软件测试管理 vs 软件项目管理</h3><ul><li>软件测试管理是忒数的软件项目管理<ul><li>与软件项目管理密切相关，有时从属于软件项目管理的一部分</li><li>可以借用软件项目管理的办法</li><li>因任务特点有自身特殊的知识、流程、方法、工具</li></ul></li></ul><h3 id="软件测试管理的要素"><a href="#软件测试管理的要素" class="headerlink" title="软件测试管理的要素"></a>软件测试管理的要素</h3><ul><li>测试过程与测试资产管理<ul><li>建立并维护测试的过程</li><li>建立并维护测试过程中建立的指南、模板、评审单等</li><li>管理测试工作相关的资产</li></ul></li><li>测试需求管理<ul><li>收集需求</li><li>分析需求</li><li>测试需求跟踪</li></ul></li><li>测试计划管理<ul><li>制定计划</li><li>执行计划</li><li>监控计划</li></ul></li><li>测试缺陷管理<ul><li>报告测试缺陷</li><li>回归测试发现的缺陷</li><li>缺陷分析</li></ul></li><li>测试工具管理<ul><li>选择测试工具</li><li>维护测试工具</li></ul></li><li>测试团队管理<ul><li>建立并维护测试团队</li><li>团队日常管理</li><li>团队绩效管理</li></ul></li></ul><h2 id="1-3-软件测试管理工具"><a href="#1-3-软件测试管理工具" class="headerlink" title="1.3 软件测试管理工具"></a>1.3 软件测试管理工具</h2><h3 id="软件测试工具"><a href="#软件测试工具" class="headerlink" title="软件测试工具"></a>软件测试工具</h3><ul><li>自动化测试工具<ul><li>单元测试工具</li><li>性能测试工具</li><li>功能测试工具</li><li>…</li></ul></li><li>软件测试管理工具<ul><li>ALM</li><li>BUGzilla：<a href="https://www.bugzilla.org/" target="_blank" rel="noopener">https://www.bugzilla.org/</a></li><li>Jira</li><li>禅道：<a href="https://www.zentao.net/" target="_blank" rel="noopener">https://www.zentao.net/</a></li><li>…</li></ul></li></ul><h3 id="软件测试管理工具的分类"><a href="#软件测试管理工具的分类" class="headerlink" title="软件测试管理工具的分类"></a>软件测试管理工具的分类</h3><ul><li>专项测试管理工具<ul><li>只管理软件测试中的某项内容<ul><li>如缺陷管理工具、</li><li>用例管理工具</li></ul></li><li>如BUGzilla是缺陷管理工具</li></ul></li><li>专门测试管理工具<ul><li>对测试的整个流程进行管理</li><li>如IBM Rational Quality Manager</li><li>HP ALM(Application lifecycle Management)等</li></ul></li><li>覆盖开发和测试的项目管理工具<ul><li>覆盖整个研发周期的项目管理工具</li><li>特别适用于研发测试齐全的产品研发团队</li><li>如：禅道项目管理软件</li></ul></li><li>其他<ul><li>借助办公软件和文档管理软件完成测试管理</li><li>办公软件:Office Project\Word\Excel</li><li>文档管理软件：如TortoiseSVN\TortoiseHg</li></ul></li></ul><h3 id="软件测试管理工具的选择"><a href="#软件测试管理工具的选择" class="headerlink" title="软件测试管理工具的选择"></a>软件测试管理工具的选择</h3><ul><li><p>选择测试管理工具应该综合考虑</p><ul><li>项目大小</li><li>团队规模</li><li>团队结构</li><li>成本预算</li></ul></li><li><p>工具是一个载体，</p><ul><li><p>可以提高工作效率，减少错误发生</p></li><li><p>更重要的是，利用知识和规范的流程完成项目，从而灵活运用工具</p></li></ul></li></ul><table><thead><tr><th>团队种类</th><th>建议选择</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td>小规模初创团队（如创业项目、学生项目等）</td><td>专项管理的开源工具或办公软件</td><td>节省成本、简单易用</td><td>Bugzilla      jira免费版 Office、Wps   文档管理软件TortoiseSVN  各种在线缺陷管理工具</td></tr><tr><td>第三方测试团队（专门提供测试服务的机构）</td><td>专门的测试管理工具</td><td>对测试全流程进行管理</td><td>IBM Rational Quality Manager       Hp ALM (Application Lifecycle Management)</td></tr><tr><td>产品研发团队（包括开发和测试人员）</td><td>软件项目管理工具</td><td>对软件开发进行全流程管理</td><td>有非常多的此类商业软件、不再举例，也有很多公司用的是自己研发的产品</td></tr></tbody></table><h3 id="软件测试管理工具的功能"><a href="#软件测试管理工具的功能" class="headerlink" title="软件测试管理工具的功能"></a>软件测试管理工具的功能</h3><ul><li>用户及权限管理</li><li>测试项目的创建</li><li>测试项目需求管理</li><li>测试任务分配和实施</li><li>测试项目缺陷管理</li><li>测试数据收集</li><li>测试项目数据分析统计和报告生成</li><li>测试项目用例管理</li><li>测试执行管理</li><li>测试文档管理</li></ul><h3 id="软件测试管理工具的发展趋势"><a href="#软件测试管理工具的发展趋势" class="headerlink" title="软件测试管理工具的发展趋势"></a>软件测试管理工具的发展趋势</h3><ul><li>与其他软件自动化测试工具集成<ul><li>如可以直接启动各种自动化测试</li></ul></li><li>与软件研发的其他环节集成越来越紧密<ul><li>如代码审查、产品版本管理等</li></ul></li><li>基于云的测试管理工具<ul><li>比如QASymphony开发的QTest是基于云计算的测试管理工具</li></ul></li></ul><h3 id="HP-ALM-测试管理工具简介"><a href="#HP-ALM-测试管理工具简介" class="headerlink" title="HP ALM 测试管理工具简介"></a>HP ALM 测试管理工具简介</h3><h4 id="ALM简介"><a href="#ALM简介" class="headerlink" title="ALM简介"></a>ALM简介</h4><ul><li>HP公司的软件测试管理工具</li><li>HP Application Lifecycle Management（ALM）<ul><li>可提供用于组织和跟踪应用程序版本的系统</li><li>帮助定义并维护需求及测试的库</li></ul></li><li>ALM具有缺陷跟踪系统<ul><li>能够从初始检测开始监控缺陷</li><li>直到问题解决</li></ul></li><li>ALM可以<ul><li>生成演示业务性能各个方面的叫糊涂</li><li>或使用任何截面数据定义报告</li><li>还可以通过在单个视图中并排排列多个图监控多个业务指标</li></ul></li></ul><h4 id="应用ALM优势"><a href="#应用ALM优势" class="headerlink" title="应用ALM优势"></a>应用ALM优势</h4><ul><li>加强开发人员、测试人员和业务分析师之间的协作</li><li>支持构建多级要求、任务、测试、缺陷、源代码和报告</li><li>任务管理有助于提高开发人员和测试人员的工作效率</li><li>同时支持瀑布式和敏捷式方法</li><li>与常见的开放源、商业开发管理解决方案完美集成</li></ul><h4 id="ALM功能"><a href="#ALM功能" class="headerlink" title="ALM功能"></a>ALM功能</h4><ul><li>版本规范</li><li>需求规范</li><li>测试计划</li><li>测试执行</li><li>缺陷跟踪</li></ul><h4 id="ALM服务器站点管理页面"><a href="#ALM服务器站点管理页面" class="headerlink" title="ALM服务器站点管理页面"></a>ALM服务器站点管理页面</h4><p><img src="/posts/40593/%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9.PNG" alt="1"></p><h4 id="ALM客户端登录界面"><a href="#ALM客户端登录界面" class="headerlink" title="ALM客户端登录界面"></a>ALM客户端登录界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.PNG" alt="登录界面"></p><p>登录时除了登录名和密码，还要选择登录的项目</p><p>每次只能登录一个固定的项目</p><h4 id="ALM客户端登陆后的界面"><a href="#ALM客户端登陆后的界面" class="headerlink" title="ALM客户端登陆后的界面"></a>ALM客户端登陆后的界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E5%90%8E%E7%95%8C%E9%9D%A2.PNG" alt="登陆后界面"></p><h4 id="ALM客户端-需求管理"><a href="#ALM客户端-需求管理" class="headerlink" title="ALM客户端-需求管理"></a>ALM客户端-需求管理</h4><p>可以创建需求</p><p>右下角为创建好的需求</p><h4 id="ALM客户端-用例管理"><a href="#ALM客户端-用例管理" class="headerlink" title="ALM客户端-用例管理"></a>ALM客户端-用例管理</h4><p>![用例管理](D:/github blog/ischelsea.github.io/source/_posts/第一章-认识软件测试管理/用例管理.PNG)</p><p>ALM客户端的用例管理称为测试计划</p><p>可以以树的形式来展现，也可以以列表的形式</p><p>可以对应到用例、可以对应到需求</p><p>每个用例有详细信息、设计步骤、参数、测试配置、附件等属性</p><h4 id="ALM客户端-测试实验室（执行管理）"><a href="#ALM客户端-测试实验室（执行管理）" class="headerlink" title="ALM客户端-测试实验室（执行管理）"></a>ALM客户端-测试实验室（执行管理）</h4><p><img src="/posts/40593/%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86.PNG" alt="执行管理"></p><p>实际上就是建立一些测试的集合</p><p>然后去执行这个测试集</p><p>测试集里会包含一群测试用例</p><p>之后可以执行并记录测试用例的执行结果，进行一些分析</p><h4 id="ALM客户端-缺陷管理"><a href="#ALM客户端-缺陷管理" class="headerlink" title="ALM客户端-缺陷管理"></a>ALM客户端-缺陷管理</h4><p><img src="/posts/40593/%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86.PNG" alt="缺陷管理"></p><p>因为缺陷有很多字段</p><p>所以缺陷建立后可以以列表的形式进行查看</p><p>缺陷可以向前关联到相应的测试用例</p><ul><li>缺陷的字段可以自己定义<ul><li>比如说缺陷的功能模块</li><li>每个产品的缺陷功能模块都是不同的</li><li>我们可以在客户端通过项目的自定义来定义缺陷的一些字段</li></ul></li></ul><p>综上</p><p>也就是说，ALM可以实现从需求、到用例、到缺陷的关联</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 软件测试过程管理</title>
      <link href="/posts/5418.html"/>
      <url>/posts/5418.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件研发中的测试"><a href="#2-1-软件研发中的测试" class="headerlink" title="2.1 软件研发中的测试"></a>2.1 软件研发中的测试</h2><h3 id="1-软件研发中的测试活动"><a href="#1-软件研发中的测试活动" class="headerlink" title="1 软件研发中的测试活动"></a>1 软件研发中的测试活动</h3><h4 id="软件测试与软件研发"><a href="#软件测试与软件研发" class="headerlink" title="软件测试与软件研发"></a>软件测试与软件研发</h4><ul><li>软件测试和软件开发一样，都遵循软件工程的原理</li><li>测试是软件研发的一部分，测试和开发时密切相关的</li><li>测试活动是贯穿于软件项目开发的全过程的，和开发活动交互开展</li></ul><h4 id="软件研发生命周期的瀑布模型"><a href="#软件研发生命周期的瀑布模型" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h4><p><img src="/posts/5418/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><h4 id="尽早测试，越晚发现问题成本越高"><a href="#尽早测试，越晚发现问题成本越高" class="headerlink" title="尽早测试，越晚发现问题成本越高"></a>尽早测试，越晚发现问题成本越高</h4><p><img src="/posts/5418/%E5%8F%98%E5%8C%96.png" alt="变化"></p><h4 id="软件研发中的测试环节与测试活动"><a href="#软件研发中的测试环节与测试活动" class="headerlink" title="软件研发中的测试环节与测试活动"></a>软件研发中的测试环节与测试活动</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8.png" alt="测试活动"></p><h4 id="研发中的测试活动：软件需求评审及i系统测试方案制定"><a href="#研发中的测试活动：软件需求评审及i系统测试方案制定" class="headerlink" title="研发中的测试活动：软件需求评审及i系统测试方案制定"></a>研发中的测试活动：软件需求评审及i系统测试方案制定</h4><ol><li><p>软件需求完成后，需要进行需求的评审，此时测试人员可以：</p><ul><li>参与需求的评审</li><li>需求确定后进行系统测试方案及计划的制订</li></ul></li><li><p>软件总体设计完成后，进行总体设计方案评审，此时测试人员可以：</p><ul><li>参与总体设计方案的评审</li><li>开始进行集成测试方案的制定</li></ul></li><li><p>详细设计完成后，测试人员：</p><ul><li>参与详细设计的评审</li><li>开始进行模块测试方案的制定</li></ul></li><li><p>单元测试和编码一般是同步的，由开发人员自己完成的</p></li><li><p>整个模块开发完成后，测试人员开始进行模块测试，在这之前所有的模块测试用例应当已经准备完毕</p></li><li><p>模块测试后是执行集成测试和系统测试</p></li><li><p>软件运行维护期间则要对运行期间发现的问题进行记录和回归测试</p></li></ol><h3 id="2-按照开发阶段对软件测试分类"><a href="#2-按照开发阶段对软件测试分类" class="headerlink" title="2 按照开发阶段对软件测试分类"></a>2 按照开发阶段对软件测试分类</h3><ul><li><p>按照开发阶段划分，软件测试分为：</p><ul><li><p>单元测试</p></li><li><p>集成测试</p></li><li><p>系统测试</p></li><li><p>确认测试</p></li><li><p>验收测试</p></li></ul></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>单元测试又称为模块测试<ul><li>是针对软件设计的最小单位-程序模块进行正确性验证的测试工作</li></ul></li><li>检查程序单元是否满足详细设计说明中的：<ul><li>模块功能</li><li>性能</li><li>接口和设计约束</li><li>发现模块内部错误</li></ul></li><li>白盒和黑盒都会用到</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>集成测试<ul><li>也叫组装测试</li><li>或者联合测试</li></ul></li><li>每个单元正确<ul><li>组装起来不一定能正确工作</li><li>所以要开展集成测试</li></ul></li><li>主要检测单元的接口关系<ul><li>集成为符合概要设计要求的更大的组件</li></ul></li></ul><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><ul><li>检测软件是否满足软件需求说明书中规定的要求</li></ul><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>将同股集成测试的软件<ul><li>作为整个基于计算机系统的一个元素</li><li>与计算机硬件，外设，某些支持软件、数据和人员等其他元素结合在一起</li><li>在实际或模拟环境下进行测试</li></ul></li><li>目的是：<ul><li>通过与系统的需求定义作比较</li><li>发现与系统定义不一致的地方</li></ul></li></ul><h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul><li>按照项目任务书或合同的验收依据对整个系统进行测试与评审</li><li>决定是否接受系统</li></ul><h2 id="2-2-软件测试模型"><a href="#2-2-软件测试模型" class="headerlink" title="2.2 软件测试模型"></a>2.2 软件测试模型</h2><ul><li><h3 id="软件测试模型背景："><a href="#软件测试模型背景：" class="headerlink" title="软件测试模型背景："></a>软件测试模型背景：</h3><ul><li>测试与开发密切相关，通过实践产生了许多测试模型</li><li>这些模型将测试活动进行了抽象<ul><li>明确了测试与开发之间的关系</li><li>是测试管理的重要参考依据</li></ul></li></ul></li></ul><ul><li><h3 id="常见的软件测试模型"><a href="#常见的软件测试模型" class="headerlink" title="常见的软件测试模型"></a>常见的软件测试模型</h3><ul><li>V模型</li><li>W模型</li><li>H模型</li><li>X模型</li><li>前置测试模型</li></ul></li></ul><ul><li><h3 id="软件研发生命周期的瀑布模型-1"><a href="#软件研发生命周期的瀑布模型-1" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h3><ul><li>计划时期：<ul><li>问题定义</li><li>可行性研究</li></ul></li><li>开发时期：<ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>测试</li></ul></li><li>运行时期：<ul><li>运行与维护</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：V模型"><a href="#软件测试模型：V模型" class="headerlink" title="软件测试模型：V模型"></a>软件测试模型：V模型</h3><ul><li>来源：<ul><li>软件开发的瀑布模型</li></ul></li><li>特点：<ul><li>说明了基本的开发过程和测试行为</li><li>明确地标识了测试过程中存在的不同级别以及测试阶段和开发各阶段的关系</li></ul></li><li>局限性：<ul><li>测试对象只有程序代码</li><li>测试作为编码后的活动，未体现“尽早测试”的原则</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：W模型"><a href="#软件测试模型：W模型" class="headerlink" title="软件测试模型：W模型"></a>软件测试模型：W模型</h3><ul><li>演化来源：<ul><li>V模型</li></ul></li><li>与V模型区别：<ul><li>增加了与软件开发阶段同步进行的测试</li></ul></li><li>强调：<ul><li>测试伴随整个软件开发周期</li><li>测试对象不仅是程序，需求、功能和设计同样要测试</li><li>测试与开发同步进行，有利于尽早发现问题</li></ul></li><li>局限性：<ul><li>W与V模型<ul><li>均把软件开发视为需求、设计、编码等一系列串行的活动</li><li>无法支持迭代以及变更调整</li></ul></li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：H模型"><a href="#软件测试模型：H模型" class="headerlink" title="软件测试模型：H模型"></a>软件测试模型：H模型</h3><ul><li>强调：<ul><li>测试活动<ul><li>独立</li><li>贯穿于整个产品周期</li><li>与研发流程并发</li></ul></li><li>循环：<ul><li>测试点准备就绪即可执行测试</li></ul></li><li>测试<ul><li>可尽早进行</li><li>可对被测对象分层次、反复测试</li></ul></li></ul></li><li>某一次测试过程：<ul><li>测试准备</li><li>测试就绪点</li><li>其他流程</li><li>测试执行</li><li>测试流程</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：其他测试模型"><a href="#软件测试模型：其他测试模型" class="headerlink" title="软件测试模型：其他测试模型"></a>软件测试模型：其他测试模型</h3><ul><li>X测试模型:<ul><li>特点：<ul><li>认为”学院派的V模型“不能处理开发的实际时间过程</li><li>比如：<ul><li>频繁重复的集成</li><li>需求文档的缺乏</li></ul></li></ul></li><li>内容：<ul><li>针对单独程序片段所进行的相互分离的编码和测试</li><li>此后进行贫乏明年的交接</li><li>通过集成最终成为可执行的程序</li><li>然后再对这些可执行程序进行测试</li></ul></li></ul></li><li>前置测试模型：<ul><li>测试与开发紧密结合</li><li>对每个交付内容进行测试<ul><li>eg：<ul><li>设计文档</li><li>可行性报告</li></ul></li></ul></li><li>交付内容一旦完成，立即进行测试</li></ul></li></ul></li></ul><ul><li><h3 id="测试模型的使用："><a href="#测试模型的使用：" class="headerlink" title="测试模型的使用："></a>测试模型的使用：</h3><ul><li>模型对工作开展有重要意义<ul><li>但每个模型都不是完美的</li></ul></li><li>灵活运用各个模型的优点<ul><li>还要考虑项目的实际情况</li></ul></li></ul></li></ul><h2 id="2-3-软件测试的流程"><a href="#2-3-软件测试的流程" class="headerlink" title="2.3 软件测试的流程"></a>2.3 软件测试的流程</h2><h3 id="1-软件测试的流程"><a href="#1-软件测试的流程" class="headerlink" title="1.软件测试的流程"></a>1.软件测试的流程</h3><h4 id="测试流程内容："><a href="#测试流程内容：" class="headerlink" title="测试流程内容："></a>测试流程内容：</h4><ul><li>测试过程定义了<ul><li>企业在产品开发过程中在<ul><li>设计</li><li>开发与实现</li><li>维护</li><li>退出</li></ul></li><li>等阶段 与测试相关活动的<ul><li>内容</li><li>流程</li><li>规范</li></ul></li></ul></li><li>测试过程指导：<ul><li>项目如何开展各项测试活动</li><li>以及各项活动的输入输出</li></ul></li><li>测试过程<ul><li>约定活动中所设计的角色与职责</li><li>规范各个活动的内容和章程<ul><li>以及所使用到的统一的<ul><li>模版</li><li>表单</li><li>指导书</li><li>检查单</li></ul></li></ul></li></ul></li></ul><h4 id="测试流程的作用"><a href="#测试流程的作用" class="headerlink" title="测试流程的作用"></a>测试流程的作用</h4><ul><li>给公司在产品开发过程中测试相关的活动<ul><li>提供指导</li><li>确保产品可以真正满足用户要求</li></ul></li></ul><h4 id="测试与开发关系"><a href="#测试与开发关系" class="headerlink" title="测试与开发关系"></a>测试与开发关系</h4><ul><li>软件项目中测试与开发相互配合、同步推进<ul><li>软件项目的复杂性被测对象往往不断变化</li><li>实际项目中测试与开发的关系更加复杂</li></ul></li><li>虽然测试与开发关系复杂，但测试工作的开展有自己的过程要遵循</li><li>对单次测试来说，存在一个一般性的过程</li></ul><h4 id="软件测试一般性过程"><a href="#软件测试一般性过程" class="headerlink" title="软件测试一般性过程"></a>软件测试一般性过程</h4><ol><li>需求分析阶段<ul><li>收集相关资料</li><li>学习业务（测试对象）</li><li>分析测试需求点</li></ul></li><li>测试计划阶段：<ul><li>测试主管<ul><li>组织编写《测试计划》</li><li>该文档指明<ul><li>测试范围</li><li>方法</li><li>资源</li><li>相应测试活动人员时间进度安排</li></ul></li></ul></li><li>测试计划<ul><li>需要进行评审</li><li>测试计划一旦开始执行<ul><li>就要定期监控计划的执行情况</li></ul></li></ul></li></ul></li><li>测试设计与开发<ul><li>测试设计<ul><li>一般由对需求熟悉的资深测试工程师设计</li><li>为每个测试点设计出包括<ul><li>需求点简介</li><li>测试思路</li><li>详细测试方法</li></ul></li><li>三部分的方法</li></ul></li><li>测试开发主要完成：<ul><li>测试用例编写</li><li>测试数据准备</li><li>测试环境准备</li></ul></li><li>测试设计与测试用例完成后需要进行评审</li></ul></li><li>测试执行及报告<ul><li>执行测试用例</li><li>及时提交<ul><li>有质量的bug</li><li>测试阶段报告<ul><li>反馈测试情况</li></ul></li></ul></li></ul></li><li>软件评估报告及批准<ul><li>根据测试结果给出<ul><li>对软件的整体评估</li><li>是否通过测的建议</li></ul></li><li>一般决策部门<ul><li>会根据这份评估报告决定产品是否可以发布vy</li></ul></li></ul></li><li>测试总结及资产归档<ul><li>结项阶段<ul><li>对整个过程进行回顾总结</li><li>将项目相关资源进行整理归档</li></ul></li></ul></li></ol><h3 id="2-软件测试流程的建立和维护"><a href="#2-软件测试流程的建立和维护" class="headerlink" title="2 软件测试流程的建立和维护"></a>2 软件测试流程的建立和维护</h3><h4 id="创建软件测试流程注意事项"><a href="#创建软件测试流程注意事项" class="headerlink" title="创建软件测试流程注意事项"></a>创建软件测试流程注意事项</h4><ul><li>从实际情况出发<ul><li>优化流程</li><li>解决问题u</li></ul></li><li>重点考虑四个问题：<ul><li>哪些测试要做</li><li>谁做</li><li>什么时间做</li><li>如何做</li></ul></li></ul><h4 id="创建测试流程步骤"><a href="#创建测试流程步骤" class="headerlink" title="创建测试流程步骤"></a>创建测试流程步骤</h4><ul><li>对当前存在的问题进行收集、诊断分析</li><li>根据实际情况建立新的流程</li><li>流程发布和试运行</li><li>促进流程的执行、收集问题</li><li>流程更新和发布</li></ul><h4 id="测试执行-VS-测试过程执行"><a href="#测试执行-VS-测试过程执行" class="headerlink" title="测试执行 VS 测试过程执行"></a>测试执行 VS 测试过程执行</h4><ul><li>测试执行<ul><li>按照测试计划去执行测试活动</li></ul></li><li>测试过程执行<ul><li>是严格按照测试的过程去开展测试活动</li></ul></li></ul><h4 id="测试流程不是静止的"><a href="#测试流程不是静止的" class="headerlink" title="测试流程不是静止的"></a>测试流程不是静止的</h4><ul><li>测试过程创建后不是一成不变</li><li>而是根据实际实践情况不断改进和完善</li><li>进行修订后要及时进行过程发布</li></ul><h4 id="促进测试过程的执行"><a href="#促进测试过程的执行" class="headerlink" title="促进测试过程的执行"></a>促进测试过程的执行</h4><ul><li>一般在测试过程执行中<ul><li>要设置一定的机制</li><li>去保证测试人员按照测试过程开展测试活动</li></ul></li><li>促进测试的执行<ul><li>QA人员对项目的监督和指导</li><li>组织级审计</li></ul></li></ul><h4 id="测试流程的改进"><a href="#测试流程的改进" class="headerlink" title="测试流程的改进"></a>测试流程的改进</h4><ul><li>测试流程<ul><li>在每一轮执行完毕后</li><li>根据所执行情况对流程进行更新和完善</li><li>用好的实践去更新完善流程</li></ul></li></ul><h4 id="测试过程中涉及的文档等资产"><a href="#测试过程中涉及的文档等资产" class="headerlink" title="测试过程中涉及的文档等资产"></a>测试过程中涉及的文档等资产</h4><ul><li>测试计划文档</li><li>测试方案文档</li><li>测试用例</li><li>测试报告</li><li>测试缺陷库</li><li>其他<ul><li>新开发或引入的测试工具</li><li>测试工作会议记录<ul><li>测试计划</li><li>测试方案</li><li>测试用例<ul><li>的评审报告</li></ul></li></ul></li><li>测试总结</li><li>测试原始数据以及度量数据</li><li>测试日志<ul><li>每天测试日程记录</li></ul></li><li>周期性测试报告</li><li>任务报告：<ul><li>任务完成情况报告</li></ul></li></ul></li></ul><h4 id="测试方案文档"><a href="#测试方案文档" class="headerlink" title="测试方案文档"></a>测试方案文档</h4><ul><li>描述<ul><li>为完成软件特性的测试而采用的测试方法的细节</li></ul></li><li>主要内容：<ul><li>概述</li><li>被测对象</li><li>应测试的特性</li><li>不被测试的特性</li><li>测试模型</li><li>测试需求</li><li>测试设计</li></ul></li></ul><h4 id="测试用例文档"><a href="#测试用例文档" class="headerlink" title="测试用例文档"></a>测试用例文档</h4><ul><li>测试用例表描述测试用例<ul><li>测试项目</li><li>用例编号</li><li>用例级别：测试用例重要程度</li><li>用例可用性</li><li>输入值</li><li>预期输出</li><li>实测结果</li><li>特殊环境需求（可选）</li><li>特殊测试步骤（可选）</li></ul></li></ul><h4 id="测试报告文档"><a href="#测试报告文档" class="headerlink" title="测试报告文档"></a>测试报告文档</h4><ul><li>描述测试结果的文档</li><li>主要内容：<ul><li>概述</li><li>测试时间、地点、人员</li><li>测试环境</li><li>测试结果统计分析</li><li>测试评估</li><li>测试总结与改进</li><li>测试缺陷列表</li></ul></li></ul><h4 id="测试缺陷："><a href="#测试缺陷：" class="headerlink" title="测试缺陷："></a>测试缺陷：</h4><ul><li>描述测试缺陷</li><li>主要内容：<ul><li>缺陷简述</li><li>缺陷描述</li><li>缺陷级别</li><li>缺陷分析与对策</li></ul></li></ul><h3 id="企业测试流程样例"><a href="#企业测试流程样例" class="headerlink" title="企业测试流程样例"></a>企业测试流程样例</h3><h4 id="某企业测试过程样例-概览"><a href="#某企业测试过程样例-概览" class="headerlink" title="某企业测试过程样例-概览"></a>某企业测试过程样例-概览</h4><p><img src="/posts/5418/%E6%A6%82%E8%A7%88.PNG" alt="概览"></p><h4 id="测试过程描述"><a href="#测试过程描述" class="headerlink" title="测试过程描述"></a>测试过程描述</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0.PNG" alt="测试过程描述"></p><h4 id="活动流程定义"><a href="#活动流程定义" class="headerlink" title="活动流程定义"></a>活动流程定义</h4><p><img src="/posts/5418/%E6%B4%BB%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89.PNG" alt="活动流程定义"></p><h4 id="测试相关的文档模版"><a href="#测试相关的文档模版" class="headerlink" title="测试相关的文档模版"></a>测试相关的文档模版</h4><p><img src="/posts/5418/%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF.PNG" alt="文档模版"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1-非功能性的系统测试需求</title>
      <link href="/posts/14723.html"/>
      <url>/posts/14723.html</url>
      
        <content type="html"><![CDATA[<h2 id="典型的遇到的问题"><a href="#典型的遇到的问题" class="headerlink" title="典型的遇到的问题"></a>典型的遇到的问题</h2><ol><li>系统性能问题</li><li>软件系统安全性受到挑战</li></ol><h2 id="什么是系统非功能性测试？"><a href="#什么是系统非功能性测试？" class="headerlink" title="什么是系统非功能性测试？"></a>什么是系统非功能性测试？</h2><ul><li><p>用户的需求</p><ul><li>分类：<ul><li>功能性需求</li><li>非功能性需求</li></ul></li></ul></li><li><p>非功能性需求：</p><ul><li>被归纳为：<ul><li>软件产品的各种质量特性</li><li>eg：<ul><li>安全性</li><li>兼容性</li><li>可靠性</li></ul></li></ul></li></ul></li><li><p>系统非功能性测试：</p><ul><li>针对于以上非功能特性展开</li><li>验证软件产品符合这些质量特性的要求<ul><li>从而满足用户和软件企业自身的非功能性需求</li></ul></li></ul></li><li><p>系统测试</p><ul><li>分类：<ul><li>负载测试</li><li>性能测试</li><li>容量测试</li><li>安全性测试</li><li>兼容性测试</li><li>可靠性测试</li></ul></li></ul></li></ul><h2 id="系统非功能特性"><a href="#系统非功能特性" class="headerlink" title="系统非功能特性"></a>系统非功能特性</h2><ul><li><p><strong>性能</strong></p><ul><li>指按用户负载条件对<ul><li>响应时间</li><li>吞吐量<ul><li>所做的度量<ul><li>（度量指的是一些指标进行计算后的统计结果）</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>可用性</strong>：</p><ul><li>指对<ul><li>系统资源</li><li>服务<ul><li>可供最终用户使用的程度度量</li></ul></li></ul></li><li>通常以系统的正常运行时间来表示</li></ul></li><li><p><strong>可伸缩性</strong>：</p><ul><li>指随时间推移为部署系统增加容量和用户的能力</li><li>通常涉及向系统添加资源</li><li>但不应要求对部署体系结构进行更改</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>指对系统及用户的完整性进行说明的复杂因素组合</li><li>包括<ul><li>用户的验证和授权</li><li>数据的安全</li><li>对已部署系统的安全访问</li></ul></li></ul></li><li><p><strong>潜在容量</strong>：</p><ul><li>指在不增加资源的情况下，系统处理异常峰值负载的能力</li><li>潜在容量是<ul><li>可用性</li><li>性能</li><li>可伸缩性<ul><li>特性中的一个因素</li></ul></li></ul></li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>指对已部署系统进行维护的难易度</li><li>其中包括：<ul><li>监视系统</li><li>修复出现的故障</li><li>升级硬件和软件组件</li></ul></li></ul></li></ul><h2 id="系统非功能性测试的内容"><a href="#系统非功能性测试的内容" class="headerlink" title="系统非功能性测试的内容"></a>系统非功能性测试的内容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter录制脚本</title>
      <link href="/posts/3679.html"/>
      <url>/posts/3679.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>file</code>目录中选择 templates..</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC1.png" alt="1"></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC2.png" alt="2"></p><p><code>select</code> <code>template</code>   中选择  <code>recording</code>  （在要做接口测试时）</p><p>如果要做性能测试，可以选择<code>recording with think time</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC3.png" alt="3"></p><p>选完后，<code>create</code> 确认</p><p>更改 <code>hostToRecord</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC4.png" alt="4"></p><p>因为是要测试自己的网站，而这个网站是部署在自己电脑上的，所以此处<code>hostToRecord</code>更改为<code>127.00.1</code></p><p><code>https</code> 改为 <code>http</code></p><p>再次选择 <code>create</code> 创建</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC5.png" alt="5"></p><ul><li><p>知识点：LogicController：</p><ul><li>用来控制TestPlan的执行，如循环、分支等，或者更简单一点，就是为了分组</li></ul></li><li><p>Thread Group下的Recording controller即是用于分组</p></li><li><p>view resultsTree：看执行结果</p></li><li><p>HTTP(S) Test Script Recorder:</p><ul><li>用于代理（浏览器请求需要通过这个代理再到网站，网站返回的相应也要通过这个代理，所以他要把这个请求给记下来）</li></ul></li></ul><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC6.png" alt="6"></p><p><code>port</code> 端口为8888，因为电脑上没有与这个冲突的，所以不用改</p><p>下面的 <code>Target Controller</code> 是指的存放所录制脚本的地方</p><p> <code>grouping</code>：一秒钟以内的请求</p><p>点击上面的 <code>start</code></p><p>再打开浏览器，打开设置栏，选择管理证书</p><p><img src="/posts/3679/7.png" alt="7"></p><p>选择证书颁发机构，选择导入</p><p><img src="/posts/3679/8.png" alt="8"></p><p>打开jmeter下的bin目录的apachejmetertemporaryrootca</p><p>后面一直点下一步、确定之类的即可</p><p>直到导入成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo s</code></p><p>图片引用：<img src="/posts/16107/%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="你想输入的替代文字"></p><p>emoji-》     ：smile：（冒号两边无空格）</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
