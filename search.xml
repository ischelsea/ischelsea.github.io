<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>““NG”</title>
      <link href="/posts/46541.html"/>
      <url>/posts/46541.html</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="before-after-class"><a href="#before-after-class" class="headerlink" title="before after class"></a>before after class</h3><pre><code>@BeforeClasspublic void startFirefox() {    //打开火狐浏览器    System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");    driver=new FirefoxDriver();}@AfterClasspublic void closeFirefox() {    //关闭网页    driver.quit();}</code></pre><h2 id="分开写业务"><a href="#分开写业务" class="headerlink" title="分开写业务"></a>分开写业务</h2><p>把四个业务分别用test写出来</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter</title>
      <link href="/posts/24657.html"/>
      <url>/posts/24657.html</url>
      
        <content type="html"><![CDATA[<h2 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h2><p>参数化应当在发送数据之前</p><p>eg：注册20个账号，客户名使用用户名</p><ul><li>在提交注册数据之前，应当先参数化</li></ul><img src="/posts/24657/csv位置.png" style="zoom:50%;"><ul><li>查看文本的属性<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625165940110.png" alt="image-20200625165940110" style="zoom:50%;"></li><li>复制位置<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625170103161.png" alt="image-20200625170103161" style="zoom:50%;"></li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625170254778.png" alt="image-20200625170254778" style="zoom:50%;">- 其他信息也填一下</li><li>再点击发送信息的那一个请求<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625183124032.png" alt="image-20200625183124032" style="zoom:50%;"></li><li>把需要参数化的数据改成${}的格式</li><li>另外，涉及到相关数据的断言也要更改为参数化<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625183433306.png" alt="image-20200625183433306" style="zoom:50%;"></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="负载-压力测试"><a href="#负载-压力测试" class="headerlink" title="负载/压力测试"></a>负载/压力测试</h3><ul><li>单击“Thread Group”，设置“线程数”为并发人数<ul><li>一个线程对应一个模拟用户</li></ul></li><li>Ramp-Up Period(in second)<ul><li>县城启动开始运行的时间间隔，单位是秒，即所有线程在多长时间内开始运行</li><li>如设置线程数为200，数据为75秒，相当于15s加载40个用户</li></ul></li><li>具体操作：<ul><li>比如要实现75秒跑200个进程</li><li>点击thread group，填写线程数为200，ramp-up period为75</li><li>再点击查看结果树，clear，并把原文件夹文件删掉，再在查看结果树里点击运行</li></ul></li></ul><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><ul><li><p>后置处理器-&gt;正则表达式提取器</p><ul><li>引用名称<ul><li>根据制定规则找到的字符串存放到此名表示的参数中</li></ul></li><li>正则表达式<ul><li>一个用()表示一个模式;left(?)right: ?表示遇到的第一个right作为右边界，然后不断向后寻找</li><li>eg：(?)&lt; /td&gt;….   就只会在第一个处停住</li></ul></li><li>模版<ul><li>$1$指第一个模版（模式），$2$第二个，此项必填<ul><li>$1$是第一个括号里的东西，$2$是第二个括号里的东西</li></ul></li><li>允许$1$2$的写法</li></ul></li><li>匹配数字<ul><li>找到的第某项，1为第一项，-1为所有项，0是随机<ul><li>参数名_matchNr(区分大小写)中存着找到几项，必写-1</li><li>参数名_gi表示找到的第i项，i从1开始，g0表示包含左右边界在内的整个字符串<ul><li>g是关键字</li></ul></li><li>有多个模版时，参数名<em>i</em>gj表示找到的第i行第j列数据</li></ul></li></ul></li></ul></li><li><p>实例：</p><ul><li><p>新建一个html文件，包括</p><ul><li><pre><code>&lt;table&gt; &lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;td&gt;zhsan&lt;/td&gt;&lt;td&gt;123&lt;/td&gt; &lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;td&gt;lisi&lt;/td&gt;&lt;td&gt;5326&lt;/td&gt; &lt;/table&gt; </code></pre></li></ul></li><li><p>jmeter新建一个测试计划</p><ul><li>右击测试计划-添加-threads-线程组</li><li>右击线程组-添加-sampler-http请求</li></ul></li><li><p>编辑http请求的ip、端口和路径</p><ul><li><img src="/posts/24657/C:%5CUsers%5Ccoolchelsea%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200625190434590.png" alt="image-20200625190434590"></li></ul></li><li><p>右键线程组-添加-监听器-查看结果树</p></li><li><p>在http请求之后，添加一个后置处理器-正则表达式提取器</p><ul><li>在其中填写正则表达式<ul><li>hello(.*)(.*) </li></ul></li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625192316322.png" alt="image-20200625192316322" style="zoom:50%;"></li><li>线程组-添加-sampler-Debug Sampler</li><li>即可在查看结果树中查看<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625204105735.png" alt="image-20200625204105735" style="zoom:50%;"></li></ul></li></ul></li></ul></li></ul><h3 id="BeanShellSampler案例"><a href="#BeanShellSampler案例" class="headerlink" title="BeanShellSampler案例"></a>BeanShellSampler案例</h3><ul><li>右键线程组-sampler-BeanShellSampler</li></ul><h2 id="录制订票脚本并验证业务正确性"><a href="#录制订票脚本并验证业务正确性" class="headerlink" title="录制订票脚本并验证业务正确性"></a>录制订票脚本并验证业务正确性</h2><ul><li><p>打开badboy</p></li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625205027569.png" alt="image-20200625205027569" style="zoom:50%;"></li><li><p>执行一次订票操作，最后sighoff，然后点结束录制（黑方框）</p><ul><li>然后跑一遍这个脚本看有没有错误<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625205304797.png" alt="image-20200625205304797" style="zoom:50%;"></li></ul></li><li>导出jmeter脚本<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625205407636.png" alt="image-20200625205407636" style="zoom:50%;"></li></ul></li></ul></li><li><p>用jmeter打开那个badboy里的脚本</p></li><li><p>右击step1-添加-监听器-查看结果树，然后点击启动，跑一遍结果树</p></li></ul><h3 id="查找会话值的方法"><a href="#查找会话值的方法" class="headerlink" title="查找会话值的方法"></a>查找会话值的方法</h3><ul><li>由于第6个页面出现了问题，所以要返回去，找session<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625213737426.png" alt="image-20200625213737426" style="zoom:50%;"></li><li>复制之后，回到结果树，从5开始从后往前找，用text格式寻找里面有没有含有userSession<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625213923624.png" alt="image-20200625213923624" style="zoom:50%;"></li><li>最终在第四个里找到<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625214009301.png" alt="image-20200625214009301" style="zoom:50%;"></li><li>把这句话复制：<input type="hidden" name="userSession" value="129047.547347104zzDHiiDpcVzzzzzHDQicHpcQQD"><ul><li>并把这句话改为：<input type="hidden" name="userSession" value="(.*?)">,并且复制一下</li></ul></li><li>再在左边打开第四个http<ul><li>添加-后置处理器-正则表达式处理器</li><li>把上面那串字符放在正则表达式处<ul><li>因为这串字符只有一对&lt;,所以下面模版写$1$,匹配字符为1，引用名称为session</li></ul></li></ul></li><li>右键step1<ul><li>添加sampler-debugsampler<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625214711672.png" alt="image-20200625214711672" style="zoom:50%;"></li><li>并把这个sampler放在正则表达式后面</li><li><img src="/posts/24657/C:%5CUsers%5Ccoolchelsea%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200625214818233.png" alt="image-20200625214818233"><ul><li>​    查看结果树<ul><li>会发现debug sampler里的session每次都不一样</li></ul></li></ul></li></ul></li><li>现在将session用正则表达式表达之后，就应该从6开始往后找，把其他值改为表达式进行替换<ul><li>例如6中：usersession的值改为${session}<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625215433827.png" alt="image-20200625215433827" style="zoom:50%;"></li></ul></li></ul></li><li>依次向后寻找，后几个http都没有</li><li>以上，实现关联</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="参数化始发地和目的地"><a href="#参数化始发地和目的地" class="headerlink" title="参数化始发地和目的地"></a>参数化始发地和目的地</h3><ul><li>现在的任务是一个人买三张票<ul><li>所以要找到发送数据的始发地和目的地</li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625235447234.png" alt="image-20200625235447234" style="zoom:50%;"></li><li>找到始发地，london</li><li>后面都依次查看看是否有，没有的话就结束，所以只有12有</li></ul></li><li>右键12的上一个11，添加-配置元件-csv data set config<ul><li>因为会保存在11内部，所以把它拖出来放到12前面</li><li><img src="/posts/24657/C:%5CUsers%5Ccoolchelsea%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200625235720971.png" alt="image-20200625235720971"></li><li>改这个的名字为:<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625235823718.png" alt="image-20200625235823718" style="zoom:50%;"></li></ul></li><li>新建一个文本，内容为<img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200625235953653.png" alt="image-20200625235953653" style="zoom:50%;"><ul><li>tab间隔</li><li>查看属性，找到文本位置，然后将路径复制到jmeter<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626000101614.png" alt="image-20200626000101614" style="zoom:50%;"></li><li>进一步设置，变量设置为两个，命名为cong,dao   分隔符改为\t</li><li>sharing mode：current thread</li></ul></li></ul></li><li>完成这些后回到12，把london改为${cong}，paris改为${dao}<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626000433656.png" alt="image-20200626000433656" style="zoom:50%;"></li></ul></li></ul></li></ul><h3 id="为订票脚本添加事务"><a href="#为订票脚本添加事务" class="headerlink" title="为订票脚本添加事务"></a>为订票脚本添加事务</h3><ul><li><p>右键step1-添加-逻辑控制器-事务控制器</p><ul><li>更改食物控制器名字为 打开网站事务</li><li>把1-5http放进这里面</li></ul></li><li><p>同理，继续添加事务控制器，命名</p><ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626003250900.png" alt="image-20200626003250900" style="zoom:50%;"></li></ul></li></ul><h3 id="为订票脚本添加断言"><a href="#为订票脚本添加断言" class="headerlink" title="为订票脚本添加断言"></a>为订票脚本添加断言</h3><ul><li>之前的跑一下脚本<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626003446779.png" alt="image-20200626003446779" style="zoom:50%;"></li><li>可以看到第一个事务前是5 所以倒着往前推，打开5<ul><li>查看其text的相应数据<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626003550207.png" alt="image-20200626003550207" style="zoom:50%;"></li><li>找到这句话并复制<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626003631957.png" alt="image-20200626003631957" style="zoom:50%;"></li></ul></li></ul></li><li>接着点开第五个http<ul><li>右键第五个，添加断言-响应断言，里面记得选包括</li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626003831616.png" alt="image-20200626003831616" style="zoom:50%;"></li><li>点击添加，粘贴刚复制的文字</li><li>改名为 打开网站响应断言</li></ul></li></ul></li><li>接下来看第二个事务：登录事务<ul><li>点开登录事务上面一个</li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626004016090.png" alt="image-20200626004016090" style="zoom:50%;"></li><li>找到text信息并复制<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626004131870.png" alt="image-20200626004131870" style="zoom:50%;"></li></ul></li><li>和上面步骤同理，添加登录响应断言</li></ul></li><li>第三个是第一次搜票事务，同理</li><li>第四个是订票断言，这里不是第15里找，而是14里<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626004619912.png" alt="image-20200626004619912" style="zoom:50%;"></li><li>回到左边，选中14，添加断言</li></ul></li><li>第五个，退出事务，在第18里找，同理添加 退出断言</li></ul></li><li>最后，回顾写完的五个断言，因为订票断言中有London<ul><li>这是刚刚参数过cong，dao的</li><li>所以要进行更改</li></ul></li><li>最后，在结果树里重新跑一下，没有错即可</li></ul><h3 id="为订票脚本添加循环控制器"><a href="#为订票脚本添加循环控制器" class="headerlink" title="为订票脚本添加循环控制器"></a>为订票脚本添加循环控制器</h3><ul><li>添加循环，让脚本反复买票</li><li>右击订票事务，添加逻辑控制器-循环控制器<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626005923746.png" alt="image-20200626005923746" style="zoom:50%;"></li><li>更改这个循环控制器名字为 反复订票，把12，13，14，15几个http都放在这里面</li><li>更改循环控制器次数为3</li></ul></li><li>完成这些后，查看结果树，跑一下脚本<ul><li>看是否报错</li><li>并查看后台数据</li></ul></li><li>右击线程组-添加-sampler-beanshell sampler<ul><li>放到反复订票里面</li><li>更改名字：显示参数值</li></ul></li><li>把“csv数据”移到循环控制器里面<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626011037016.png" alt="image-20200626011037016" style="zoom:50%;"></li></ul></li></ul><h3 id="为订票脚本增加计数器"><a href="#为订票脚本增加计数器" class="headerlink" title="为订票脚本增加计数器"></a>为订票脚本增加计数器</h3><ul><li>想知道是第几次的参数</li><li>所以在循环里面添加一个计数器:<ul><li>右键反复订票-添加-配置元件-计数器</li><li>更改里面的信息<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626013615030.png" alt="image-20200626013615030" style="zoom:50%;"></li></ul></li></ul></li><li>接着在beanshell..即显示参数值里更改<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626013711500.png" alt="image-20200626013711500" style="zoom:50%;"></li></ul></li><li>回到结果树重新跑一遍，可以看到已成功加上了次数<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626013832733.png" alt="image-20200626013832733" style="zoom:50%;"></li></ul></li></ul><h2 id="场景设计与运行"><a href="#场景设计与运行" class="headerlink" title="场景设计与运行"></a>场景设计与运行</h2><h3 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h3><ul><li>通过定时器完成。 </li><li>SynchronizingTimer（同步定时器） <ul><li> 用来保证我们的取样器在同一时刻向服务器发起负载。</li><li> NumberofSimulatedUserstoGroupby <ul><li>设置同步的线程数量。 </li></ul></li><li> Timeoutinmilliseconds <ul><li>超时时间，单位为毫秒。 </li></ul></li></ul></li><li> <strong>【例】参数化登录，为登录设置集合点，运行负载测试（取消每人订 3 张票）</strong>。<ul><li>使用桌面的users.txt<ul><li>登录事务右键添加一个csv data set config<ul><li>放在6之前<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626014723566.png" alt="image-20200626014723566" style="zoom:50%;"></li></ul></li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626014913932.png" alt="image-20200626014913932" style="zoom:50%;"></li><li>回到6，把这里面两个数据改为参数化<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626015044887.png" alt="image-20200626015044887" style="zoom:50%;"></li></ul></li><li>因为登录断言里面也有zhsan1，所以这里也更改为参数<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626015145241.png" alt="image-20200626015145241" style="zoom:50%;"></li><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626015216074.png" alt="image-20200626015216074" style="zoom:50%;"></li></ul></li><li>接着到14，把1改成${mm}<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626015312725.png" alt="image-20200626015312725" style="zoom:50%;"></li></ul></li></ul></li></ul></li></ul></li><li>然后在登录前添加一个集合点<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626015458553.png" alt="image-20200626015458553" style="zoom:50%;"></li><li>添加Synchro…<ul><li>放在登录的外面（前面）</li><li><img src="/posts/24657/C:%5CUsers%5Ccoolchelsea%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200626015604995.png" alt="image-20200626015604995"></li></ul></li><li>改名为集合点</li><li>设置为30个人并发，等待30秒<ul><li><img src="/posts/24657/C:%5CUsers%5Ccoolchelsea%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200626015713427.png" alt="image-20200626015713427"></li><li>3000是3秒</li></ul></li><li>点击线程组。确定多少人使用这个软件<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626015845288.png" alt="image-20200626015845288" style="zoom:50%;"></li><li>即：200人，共90秒</li></ul></li><li>查看结果树，200个人里3个人同时登录，测它的性能</li></ul></li></ul><h2 id="场景监控与运行"><a href="#场景监控与运行" class="headerlink" title="场景监控与运行"></a>场景监控与运行</h2><h3 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h3><ul><li><p>右击线程组-添加-监听器-图形结果</p></li><li><p>右击线程组-添加-监听器-用表格查看结果</p></li><li><p>右击线程组-添加-监听器-聚合报告</p></li><li><p>然后启动，即可看到这些结果</p></li></ul><h3 id="监控硬件资源"><a href="#监控硬件资源" class="headerlink" title="监控硬件资源"></a>监控硬件资源</h3><p>解压 ServerAgent-2.2.1.zip 到被监控计算机中 </p><p>​     Windows 服务器运行 startAgent.bat 文件 </p><p>​     Linux 服务器运行 startAgent.sh 文件 </p><p> 将 JMeterPlugins-Standard.jar 包复制到 jmeter 安装目录下的\lib\ext 下</p><p>  重启 jmeter</p><p>  选择监听器 jp@gc-PerfMonMetricsCollector</p><p>​      单击 AddRow，添加服务器的 ip，选择要监控的 CPU、内存、硬盘、网络等资源</p><ul><li>点开server agent里面的<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626022529896.png" alt="image-20200626022529896" style="zoom:50%;"></li><li>重启jmeter<ul><li>添加<ul><li><img src="/posts/24657/Users\coolchelsea\AppData\Roaming\Typora\typora-user-images\image-20200626022849341.png" alt="image-20200626022849341" style="zoom:50%;"></li></ul></li><li>这个监听器 改名为硬件资源监控<ul><li><img src="/posts/24657/C:%5CUsers%5Ccoolchelsea%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200626023027224.png" alt="image-20200626023027224"></li><li>add row进行添加，cpu、内存、磁盘</li></ul></li></ul></li></ul></li></ul><h3 id="取样器和聚合报告结果分析"><a href="#取样器和聚合报告结果分析" class="headerlink" title="取样器和聚合报告结果分析"></a>取样器和聚合报告结果分析</h3><ul><li>察看结果树-取样器结果 <ul><li>ThreadName<ul><li>线程组名称 </li></ul></li><li>SampleStart <ul><li>启动开始时间 </li></ul></li><li>Loadtime <ul><li>加载时长 </li></ul></li><li>Connecttime <ul><li>连接时长 </li></ul></li><li>Latency <ul><li>等待时长  </li></ul></li><li>Sizeinbytes <ul><li>发送的数据总大小  </li></ul></li><li>Headerssizeinbytes <ul><li>发送数据的头部部分大小  </li></ul></li><li>Bodysizeinbytes <ul><li>发送数据的正文部分大小  </li></ul></li><li>SampleCount <ul><li>发送统计  </li></ul></li><li>ErrorCount <ul><li>错误统计  </li></ul></li><li>Responsecode <ul><li>状态码  </li></ul></li><li>Responsemessage <ul><li>响应信息  </li></ul></li><li>Responseheaders <ul><li>响应的头部信息  </li></ul></li></ul></li><li>聚合报告  <ul><li>Label 线程组中的步骤名  </li><li>#Samples 表示一共发出的请求数  </li><li>Average 平均响应时间，默认情况下是单个 </li><li>Request 的平均响应时间（ms）  </li><li>Median 中间值，有一半的服务器响应时间低于该值而另一半高于该值。  </li><li>90%line 90%请求的响应时间。  </li><li>Min 服务器响应的最短时间。  </li><li>Max 服务器响应的最长时间。  </li><li>Error% 测试出现的错误请求数量百分比。 确认是否允许错误的发生或者错误率允许在多大的范围内。 若出现错误就要看服务端的日志，配合开发查找定位原因。<br> </li><li>Throughput 简称 tps，吞吐量 默认情况下表示每秒处理的请求数，也就是指服务器处理能力，tps 越高说明 服务器处理能力越好。 吞吐量默认以 requests/second 来衡量，即每秒多少个请求。  Kb/sec 以 KB/seond 来衡量的吞吐量。  用表格查看结果  </li><li>Sample# 每个请求的序号  </li><li>StartTime 每个请求开始时间  </li><li>ThreadName 每个线程的名称（代表一个虚拟用户）  </li><li>Label <ul><li>Http 请求名称  </li></ul></li><li>SampleTime 每个请求所花时间，单位毫秒  </li><li>Status 请求状态，如果为勾则表示成功，如果为叉表示失败。  </li><li>Bytes 请求的字节数  </li><li>Latency 等待时长  </li><li>Connecttime 连接时长  样本数目 也就是请求个数，成功的情况下等于你设定的并发数目乘以循环次数  最新样本 表示服务器响应最后一个请求的时间  平均 每个线程请求的平均时间  偏离 服务器响应时间变化、离散程度测量值的大小</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sel</title>
      <link href="/posts/42714.html"/>
      <url>/posts/42714.html</url>
      
        <content type="html"><![CDATA[<h3 id="识别与操作文本框"><a href="#识别与操作文本框" class="headerlink" title="识别与操作文本框"></a>识别与操作文本框</h3><pre><code>package sel;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.util.concurrent.TimeUnit;import org.openqa.selenium.By;import org.openqa.selenium.WebDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.support.ui.Select;public class SelTest {    public static void main(String[] args) throws Exception{        System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";        //隐式等待3s        driver.get(url);        Thread.sleep(8000);        driver.quit();    }}</code></pre><p>上述实现打开网页  </p><ul><li><p>打开后怎么找到文本框并进行操作？</p><ul><li>eg：前面为寻找name为yhm的文本框，后面sendkeys为输数据<pre><code>    ``driver.findElement(By.name("yhm")).sendKeys("zhsan");`</code></pre></li></ul></li><li><p>成功实现打开页面并在name为yhm的文本框输入zhsan</p><ul><li><pre><code>package sel;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.util.concurrent.TimeUnit;import org.openqa.selenium.By;import org.openqa.selenium.WebDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.support.ui.Select;public class SelTest {    public static void main(String[] args) throws Exception{        System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        //System.setProperty("webdriver.firefox.bin", "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";</code></pre></li></ul></li></ul><pre><code>        //隐式等待3s        driver.get(url);        Thread.sleep(8000);        //前面为寻找name为yhm的文本框，后面sendkeys为输数据        driver.findElement(By.name("yhm")).sendKeys("zhsan");        //完成操作后再等待3秒钟方便观察        Thread.sleep(3000);        driver.quit();    }}```</code></pre><h3 id="清除文本框内容，获取文本框数据"><a href="#清除文本框内容，获取文本框数据" class="headerlink" title="清除文本框内容，获取文本框数据"></a>清除文本框内容，获取文本框数据</h3><ul><li><p>上述例子中</p><ul><li><pre><code>//前面为寻找name为yhm的文本框，后面sendkeys为输数据        driver.findElement(By.name("yhm")).sendKeys("zhsan");        //完成操作后再等待3秒钟方便观察        Thread.sleep(3000);        //如果在输完张三之后，再加上输入李四的指令        driver.findElement(By.name("yhm")).sendKeys("lisi");        Thread.sleep(3000);        driver.quit();</code></pre><ul><li><p>按上述代码，本想实现测试完张三到文本框后，输入李四</p><ul><li>实际运行结果下，会自动在张三后增加李四，导致输入zhsanlisi </li><li>这样是不合理的，因此编写代码时应在输入完zhsan后增加清空的代码.clear()<ul><li>eg:<strong>driver.findElement(By.name(“yhm”)).clear();</strong></li></ul></li></ul></li><li><p>完整代码如下即可实现操作</p><ul><li><pre><code>package sel;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.util.concurrent.TimeUnit;import org.openqa.selenium.By;import org.openqa.selenium.WebDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.support.ui.Select;public class SelTest {    public static void main(String[] args) throws Exception{        System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        //System.setProperty("webdriver.firefox.bin", "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";</code></pre></li></ul></li></ul></li></ul></li></ul><pre><code>            //隐式等待3s            driver.get(url);            //前面为寻找name为yhm的文本框，后面sendkeys为输数据            driver.findElement(By.name("yhm")).sendKeys("zhsan");            //完成操作后再等待3秒钟方便观察            Thread.sleep(3000);            driver.findElement(By.name("yhm")).clear();            //如果在输完张三之后，再加上输入李四的指令            driver.findElement(By.name("yhm")).sendKeys("lisi");            Thread.sleep(3000);            driver.quit();        }    }    ```</code></pre><p><strong>获取文本框数据内容</strong></p><ul><li><pre><code>        System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");          //System.setProperty("webdriver.firefox.bin", "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe");          WebDriver driver=new FirefoxDriver();          String url="http://localhost:1080/webtours/test/login.html";          //隐式等待3s          driver.get(url);          //前面为寻找name为yhm的文本框，后面sendkeys为输数据          driver.findElement(By.name("yhm")).sendKeys("zhsan");          //完成操作后再等待3秒钟方便观察          Thread.sleep(3000);          driver.findElement(By.name("yhm")).clear();          //如果在输完张三之后，再加上输入李四的指令          //获取文本框数据          System.out.print(driver.findElement(By.name("yhm")).getText());</code></pre><ul><li><p>但是用getText有时候能获取数据，有时候不能，所以改用getAttribute()</p><ul><li><p>如下：</p></li><li><pre><code>System.out.print(driver.findElement(By.name("yhm")).getAttribute("value"));</code></pre><ul><li>即可获得值lisi</li></ul></li></ul></li></ul></li></ul><h3 id="识别并操作单选按钮"><a href="#识别并操作单选按钮" class="headerlink" title="识别并操作单选按钮"></a>识别并操作单选按钮</h3><ul><li>click()<ul><li>单击</li></ul></li><li>isSelected()<ul><li>是否选中</li></ul></li></ul><p><strong>实例</strong> 比如要检测是否选中性别中的男 这个单选框，现在页面上查看源代码，看这个框的name是什么</p><ul><li><img src="/posts/42714/单选框.png" alt="单选框" style="zoom:50%;"></li><li><p>如图，确定了name为xb,男value为1，女为0</p></li><li><pre><code>driver.findElement(By.name("xb")).click();    System.out.print(driver.findElement(By.name("xb")).getAttribute("value");            Thread.sleep(3000);        driver.quit();</code></pre><p>即可实现单击单选框并输出单选框的文字</p><ul><li>但是注意，这里的根据name为xb的框来进行单击的方式，只能取到”男”</li><li>因为name为xb实际上有两个框，分别为男女，click执行时会默认直接执行第一个</li></ul></li><li><p><strong>判断单选框是否选中</strong></p><ul><li><pre><code>//执行click前判断是否选中System.out.println(driver.findElement(By.name("xb")).isSelected());        driver.findElement(By.name("xb")).click();        //执行click后判断是否选中        System.out.println(driver.findElement(By.name("xb")).isSelected());        Thread.sleep(3000);        driver.quit();</code></pre><ul><li>运行后，eclipse分别输出false和true，达成预期结果</li></ul></li></ul></li></ul><h3 id="处理属性值相同的元素，识别并操作复选框"><a href="#处理属性值相同的元素，识别并操作复选框" class="headerlink" title="处理属性值相同的元素，识别并操作复选框"></a>处理属性值相同的元素，识别并操作复选框</h3><ul><li><p>在遇到name相同的多个框的时候，可以用</p><ul><li>driver.findElements(By.属性).get(下标)</li><li>查询符合属性要求的所有对象</li><li>适用于单选按钮、复选框、链接等</li><li>使用get(下标)可以选择某个，从0开始</li></ul></li><li><p>实例：</p><ul><li><pre><code>System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";        driver.get(url);        driver.findElements(By.name("xb")).get(1).click();        Thread.sleep(3000);        driver.quit();</code></pre><ul><li>即可实现选中同样名字都为xb的两个框中的第二个，即选中“女”单选框<ul><li>driver.findElements(By.name(“xb”)).<strong>get(1)</strong>.click();</li><li>注意从0开始，0为第一个，1为第二个</li></ul></li></ul></li></ul></li></ul><h4 id="如果要同时选中好几个复选框"><a href="#如果要同时选中好几个复选框" class="headerlink" title="如果要同时选中好几个复选框"></a>如果要同时选中好几个复选框</h4><ul><li><p>方法：</p><ul><li>driver.findElements(By.name(“xsah”)).get(0).click();<br>driver.findElements(By.name(“xsah”)).get(1).click();<br>driver.findElements(By.name(“xsah”)).get(2).click();</li><li>即按顺序0,1,2的下标把每一项都写出来进行选中</li></ul></li><li><p>如果要单击后再取消选中</p><ul><li>就写两次即可</li><li>driver.findElements(By.name(“xsah”)).get(0).click();<br>driver.findElements(By.name(“xsah”)).get(1).click();<br>driver.findElements(By.name(“xsah”)).get(0).click();</li></ul></li></ul><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><ul><li>new Select(driver.findElement(By.name(“select控件名”)))</li><li>selectByIndex(下标)<ul><li>根据下标选择某项，从0开始</li></ul></li><li>selectByVisibleText(“数据”)<ul><li>根据列表框中显示的文本选择某项</li></ul></li><li>selectByValue(“值”)<ul><li>根据值选中某项</li><li>此处的value是源代码中的value</li></ul></li></ul><p><strong>实例</strong>：选中下拉列表中的第二项：天津</p><ul><li><pre><code>System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";        driver.get(url);        new Select(driver.findElement(By.name("jg"))).selectByIndex(1);;        Thread.sleep(3000);        driver.quit();</code></pre><ul><li>重点：<strong>new Select(driver.findElement(By.name(“jg”))).selectByIndex(1);;</strong></li></ul></li><li><p>根据value来选择</p><ul><li>new Select(driver.findElement(By.name(“jg”))).selectBy<strong>Value</strong>(“<strong>sh</strong>“);</li><li>选中值为sh的下拉列表中的单选框</li></ul></li><li><p>根据数据来选择</p><ul><li>new Select(driver.findElement(By.name(“jg”))).selectByVisibleText(“上海”);</li><li>选中值为上海的项</li></ul></li></ul><h3 id="链接和命令按钮"><a href="#链接和命令按钮" class="headerlink" title="链接和命令按钮"></a>链接和命令按钮</h3><ul><li>click()<ul><li>单击</li></ul></li></ul><p><strong>怎样识别链接？</strong></p><ul><li><p>具体过程：</p><ul><li><pre><code>System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";        driver.get(url);        driver.findElement(By.linkText("top")).click();        Thread.sleep(3000);        driver.quit();</code></pre></li></ul></li><li><p>加上这段命令：</p><ul><li>driver.findElement(By.linkText(“top”)).click();</li><li>即可实现跳转<ul><li>从登陆页跳转到top页面</li></ul></li></ul></li><li><p><strong>当不知道完整的名字时，还可以使用partial</strong></p><ul><li>driver.findElement(By.partialLinkText(“<strong>lef</strong>“)).click();</li><li>尽管没有写完整left，但是依然可以跳转到left页面</li></ul></li><li><p>另一个实例：</p><ul><li>login.html中的登录按钮，源代码为<ul><li><input name="dl" type.....=""></li><li>即此按钮name为dl，因此可以采用以下方式进行操作：<ul><li>driver.findElement(By.name(“dl”)).click();</li><li>即可实现单击“登录”按钮</li></ul></li></ul></li></ul></li></ul><h3 id="通过tagname和xpath识别控件"><a href="#通过tagname和xpath识别控件" class="headerlink" title="通过tagname和xpath识别控件"></a>通过tagname和xpath识别控件</h3><h4 id="driver-findElement-By-属性"><a href="#driver-findElement-By-属性" class="headerlink" title="driver.findElement(By.属性)"></a>driver.findElement(By.属性)</h4><ul><li>查询符合属性要求的第一个对象</li><li>适用于文本框、密码框、命令按钮、单选按钮</li><li>属性：<ul><li>name(“值”)</li><li>tagName(“标签名”)<ul><li>标签即  内关键字</li></ul></li><li>xpath(“//标记名[@属性名=’属性值’]”)</li><li>id</li><li>className<ul><li>CSS class属性的值</li></ul></li><li>linkText<ul><li><a href="">和 &lt;/ a&gt;之间的内容</a></li></ul></li><li>partialLinkText<ul><li><a href=""> 和 &lt;/ a&gt;之间的部分文本值</a></li></ul></li></ul></li></ul><h4 id="标签名tagname"><a href="#标签名tagname" class="headerlink" title="标签名tagname"></a>标签名tagname</h4><ul><li><p>eg:</p><ul><li>input、body、a等等都是标签名</li></ul></li><li><p>使用实例：</p><ul><li><pre><code>WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test/login.html";        driver.get(url);        driver.findElement(By.tagName("input")).sendKeys("wang5");        Thread.sleep(3000);        driver.quit();</code></pre><ul><li>其中：driver.findElement(By.<strong>tagName(“input”)</strong>).<strong>sendKeys(“wang5”</strong>);</li><li>是为了寻找标签名为input的第一个框，并对此发送wang5（即在键盘上输入wang5）</li></ul></li><li><p>如果想指定第几个input,就改为Elements,并在后面指明第几个</p><ul><li>​        driver.findElement<strong>s</strong>(By.tagName(“input”)).<strong>get(1)</strong>.sendKeys(“wang5”);</li><li>即可改为在第二个input发送wang5</li></ul></li></ul></li></ul><p><strong>利用tagname获取body内所有文字</strong></p><ul><li>System.out.println(driver.findElement(By.tagName(“body”)).getText());</li><li>即可在eclipse中输出body中所有的文字</li></ul><h4 id="通过xpath识别"><a href="#通过xpath识别" class="headerlink" title="通过xpath识别"></a>通过xpath识别</h4><ul><li>格式：xpath(“//标记名[@属性名=’属性值’]”)</li><li>实例：<ul><li>​        driver.findElement(By.xpath(“//input[@value=1]”)).click();</li><li>即可选中input标签下value为1的单选框</li></ul></li></ul><h2 id="通过id和className识别控件"><a href="#通过id和className识别控件" class="headerlink" title="通过id和className识别控件"></a>通过id和className识别控件</h2><ul><li><p>id</p><ul><li>当标签后面有id这个属性即可使用</li></ul></li><li><p>className：</p><ul><li>是CSS class属性的值</li></ul></li><li><p>通过id的实例：</p><ul><li>eg：原网页代码中出现了id=uname,要对此进行操作可以采用：</li><li>​        driver.findElement(By.<strong>id(“uname”</strong>)).sendKeys(“john”);</li><li>即可识别id为uname的文本框并对其发送john</li></ul></li><li><p>通过className的实例：</p><ul><li>eg：原网页代码中有class=text,要对符合此要求的第二个部件进行操作：</li><li>​        driver.findElement<strong>s</strong>(By.<strong>className</strong>(“<strong>text</strong>“)).<strong>get(1)</strong>.click();</li><li>即可找到class名为text的第二个部件，并点击</li></ul></li></ul><h2 id="识别使用了框架的页面元素"><a href="#识别使用了框架的页面元素" class="headerlink" title="识别使用了框架的页面元素"></a>识别使用了框架的页面元素</h2><ul><li><p>如果网页中有框架frame，怎样识别元素？</p><ul><li><p>不可用原本的直接driver.findElements….</p></li><li><p>因为这是frame框架，等于被锁在框架外面了，所以不能这样进行识别</p></li><li><p>因此：</p><ul><li>driver.switchTo().defaultContent();<ul><li>切回主文档</li><li>每次打开一个新网页的时候，应使用此句</li></ul></li><li>driver.switchTo().frame(1或”body”);<ul><li>表示进入第2个frame或名为body的frame</li></ul></li></ul></li><li><p>eg：</p><ul><li><p>当原网页代码中含有frame，需要找到name为yhm的文本框并发送“zhsan”</p><ul><li>方法：先切换到frame,此时原网页代码为<ul><li>​        driver.switchTo().frame(“showFrame”);</li><li>再找到name为yhm的文本框发送信息</li><li>​        driver.findElement(By.name(“yhm”)).sendKeys(“zhsan”);</li></ul></li></ul></li><li><p>完整代码：</p><ul><li><pre><code>WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours/test";        driver.get(url);        driver.switchTo().frame("showFrame");        driver.findElement(By.name("yhm")).sendKeys("zhsan");        Thread.sleep(3000);        driver.quit();</code></pre></li></ul></li></ul></li></ul></li></ul><h2 id="webtours举例"><a href="#webtours举例" class="headerlink" title="webtours举例"></a>webtours举例</h2><h3 id="嵌套的框架"><a href="#嵌套的框架" class="headerlink" title="嵌套的框架"></a>嵌套的框架</h3><ul><li><p>比如要往登录框填写登录名</p><ul><li><pre><code>WebDriver driver=new FirefoxDriver();        //打开网站        String url="http://localhost:1080/webtours";        driver.get(url);        //因为嵌套在两个frame里面，所以要切换两次        //切换第一个frame：name为body        driver.switchTo().frame("body");        //切换第二个frame,name为navbar        driver.switchTo().frame("navbar");        driver.findElement(By.name("username")).sendKeys("chelsea");        Thread.sleep(3000);        //关闭网页        //driver.quit();</code></pre></li></ul></li><li><p>输入登录名、密码并点击登录按钮，完成登录操作</p><ul><li><pre><code>WebDriver driver=new FirefoxDriver();        //打开网站        String url="http://localhost:1080/webtours";        driver.get(url);        //因为嵌套在两个frame里面，所以要切换两次        //切换第一个frame：name为body        driver.switchTo().frame("body");        //切换第二个frame,name为navbar        driver.switchTo().frame("navbar");        driver.findElement(By.name("username")).sendKeys("chelsea");        driver.findElement(By.name("password")).sendKeys("123456");        driver.findElement(By.name("login")).click();        Thread.sleep(3000);</code></pre></li></ul></li><li><p>接下来点击Flight,但由于此处没有input没有name没有id，所以要使用xpath</p><ul><li><pre><code>WebDriver driver=new FirefoxDriver();        //打开网站        String url="http://localhost:1080/webtours";        driver.get(url);        //因为嵌套在两个frame里面，所以要切换两次        //切换第一个frame：name为body        driver.switchTo().frame("body");        //切换第二个frame,name为navbar        driver.switchTo().frame("navbar");        driver.findElement(By.name("username")).sendKeys("chelsea");        driver.findElement(By.name("password")).sendKeys("123456");        driver.findElement(By.name("login")).click();</code></pre></li></ul></li></ul><pre><code>        Thread.sleep(3000);        //因为此时已经进入了另一个网页所以要切换一次框架        //先清空重置等于说回到网页框架最外        driver.switchTo().defaultContent();        //切换第一个frame：name为body        driver.switchTo().frame("body");        //切换第二个frame,name为navbar        driver.switchTo().frame("navbar");        driver.findElement(By.xpath("//img[@alt=\"Search Flights Button\"]")).click();        //关闭网页        //driver.quit();```- 此处重点就是xpath的使用以及进行两次框架的切换</code></pre><ul><li><p>进入flight页面后，需要进行下拉列表的自动选择</p><ul><li>即<strong>识别下拉列表和按钮元素</strong></li><li>首先观察框架的嵌套关系<ul><li>我们要进行操作的文本框在frame的name为body下，再进入frame的name为info处</li><li>下拉列表页面源代码为select name=”depart”</li></ul></li></ul></li></ul><h3 id="多个元素选择一个："><a href="#多个元素选择一个：" class="headerlink" title="多个元素选择一个："></a>多个元素选择一个：</h3><ul><li>​        driver.findElements(By.name(“outboundFlight”)).get(1).click();</li><li>即选中第二个</li></ul><h3 id="webtour-buyflights一直向下选择的脚本"><a href="#webtour-buyflights一直向下选择的脚本" class="headerlink" title="webtour buyflights一直向下选择的脚本"></a>webtour buyflights一直向下选择的脚本</h3><ul><li><pre><code>System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours";        driver.get(url);        ///        driver.switchTo().frame("body");        driver.switchTo().frame("info");        Boolean openResult=driver.findElement(By.tagName("body")).getText().contains("Welcome to the Web Tours site");        System.out.println("����վ��"+openResult);        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("navbar");        driver.findElement(By.name("username")).sendKeys("chelsea");        driver.findElement(By.name("password")).sendKeys("123456");        driver.findElement(By.name("login")).click();        Thread.sleep(3000);        ///        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        Boolean loginResult=driver.findElement(By.tagName("body")).getText().contains("Welcome, zhsan1");        System.out.println("��¼��"+loginResult);        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("navbar");        driver.findElement(By.xpath("//img[@alt=\"Search Flights Button\"]")).click();        Thread.sleep(5000);        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        new Select(driver.findElement(By.name("depart"))).selectByVisibleText("London");        new Select(driver.findElement(By.name("arrive"))).selectByVisibleText("Paris");        driver.findElement(By.name("findFlights")).click();        Thread.sleep(3000);        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        driver.findElements(By.name("outboundFlight")).get(1).click();        driver.findElement(By.name("reserveFlights")).click();        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        driver.findElement(By.name("buyFlights")).click();        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        driver.findElement(By.name("Book Another")).click();        Thread.sleep(3000);        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("navbar");        driver.findElement(By.xpath("//img[@alt=\"SignOff Button\"]")).click();        driver.quit();</code></pre></li></ul><h2 id="添加断言"><a href="#添加断言" class="headerlink" title="添加断言"></a>添加断言</h2><ul><li><p>Boolean res=driver.findElement(By.tagName(“body”)).getText().contains(“Welcome”)</p><ul><li>断言不通过（找不到数据时），Selenium会停止测试</li><li>结合try，if可以解决</li><li>返回true或false</li><li>检查时判断的是前台文本</li></ul></li><li><p>实例：</p><ul><li><p>因为那段文字在body里面，文字包括welcome to the web tours site</p></li><li><p>所以断言：</p><ul><li><pre><code>driver.switchTo().frame("body");driver.switchTo().frame("info");Boolean openResult=driver.findElement(By.tagName("body")).getText().contains("Welcome to the Web Tours site");        System.out.println("打开网站"+openResult);</code></pre><ul><li>前面两行是切换框架，后面两行是断言，判断是否含有文字welcome…，如果含有则输出true</li></ul></li></ul></li><li><p>对登录点的检查断言：</p><ul><li><pre><code>driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        Boolean loginResult=driver.findElement(By.tagName("body")).getText().contains("Welcome, chelsea");        System.out.println("登录:"+loginResult);</code></pre></li></ul></li></ul></li></ul><h2 id="2-参数化"><a href="#2-参数化" class="headerlink" title="2 参数化"></a>2 参数化</h2><h3 id="2-1-java读文件"><a href="#2-1-java读文件" class="headerlink" title="2.1 java读文件"></a>2.1 java读文件</h3><p>File file=new File(“C:/…/flights.txt”);</p><p>FileReader reader=new FileReader(file);</p><p>BufferedReader buffer=new BufferedReader(reader);</p><p>String row=null;</p><p>while(row=buffer.readLine()!=null){</p><p>​    String columns[]=row.split(“\t”);</p><p>​    for(String x:columns)</p><p>​        System.out.println(x);</p><p>}</p><p>reader.close();</p><ul><li><p>具体步骤：</p><ul><li><p>先在项目中新建一个class,取名为FileRead</p></li><li><p>D盘新建一个txt文件，命名为flights.txt</p><ul><li>在txt文件中写入数据，比如：<ul><li>London    Paris<br>Denver    London<br>Paris    Denver</li><li>用Tab键进行间隔，输入完后保存</li></ul></li></ul></li><li><p>在eclipse中读取此文件中的信息</p><ul><li><pre><code>package sel;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;public class FileRead {    public static void main(String[] args) throws Exception {        //写明文件地址        File file=new File("D:\\flights.txt");        //以byte字节读取文件        FileReader bytes=new FileReader(file);        //把byte读成字符        BufferedReader chars=new BufferedReader(bytes);        //读之前row为0        String row=null;        //一行一行循环去读        while((row=chars.readLine())!=null)                System.out.println(row);    }}</code></pre><ul><li><p>或者将输出的文字分开来写：如果有两列就一分为二</p><ul><li><pre><code>package sel;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;public class FileRead {    public static void main(String[] args) throws Exception {        //写明文件地址        File file=new File("D:\\flights.txt");        //以byte字节读取文件        FileReader bytes=new FileReader(file);        //把byte读成字符        BufferedReader chars=new BufferedReader(bytes);        //读之前row为0        String row=null;        //一行一行循环去读        while((row=chars.readLine())!=null) {            String cols[]=row.split("\t");            for(String x:cols)                System.out.println(x+"-----");            System.out.println();        }    }}</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="2-2-参数化数据"><a href="#2-2-参数化数据" class="headerlink" title="2.2 参数化数据"></a>2.2 参数化数据</h3><ul><li><p>代码：</p><ul><li><pre><code>//        System.setProperty("webdriver.gecko.driver","C:\\Users\\coolchelsea\\Desktop\\sel-pack\\geckodriver.exe");        WebDriver driver=new FirefoxDriver();        String url="http://localhost:1080/webtours";        driver.get(url);        ///        driver.switchTo().frame("body");        driver.switchTo().frame("info");        Boolean openResult=driver.findElement(By.tagName("body")).getText().contains("Welcome to the Web Tours site");        System.out.println("打开网站:"+openResult);        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("navbar");        driver.findElement(By.name("username")).sendKeys("chelsea");        driver.findElement(By.name("password")).sendKeys("123456");        driver.findElement(By.name("login")).click();        Thread.sleep(3000);        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("info");        Boolean loginResult=driver.findElement(By.tagName("body")).getText().contains("Welcome, chelsea");        System.out.println("登录:"+loginResult);        //        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("navbar");        driver.findElement(By.xpath("//img[@alt=\"Search Flights Button\"]")).click();        Thread.sleep(5000);        //参数化        //写明文件地址                File file=new File("D:\\flights.txt");                //以byte字节读取文件                FileReader bytes=new FileReader(file);                //把byte读成字符                BufferedReader chars=new BufferedReader(bytes);                //读之前row为0                String row=null;                //一行一行循环去读                while((row=chars.readLine())!=null) {                    String cols[]=row.split("\t");                    //选票                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    new Select(driver.findElement(By.name("depart"))).selectByVisibleText("cols[0]");                    new Select(driver.findElement(By.name("arrive"))).selectByVisibleText("cols[1]");                    driver.findElement(By.name("findFlights")).click();                    Thread.sleep(3000);                    //                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    driver.findElements(By.name("outboundFlight")).get(1).click();                    driver.findElement(By.name("reserveFlights")).click();                    //                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    driver.findElement(By.name("buyFlights")).click();                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    driver.findElement(By.name("Book Another")).click();                }                bytes.close();        Thread.sleep(3000);        driver.switchTo().defaultContent();        driver.switchTo().frame("body");        driver.switchTo().frame("navbar");        driver.findElement(By.xpath("//img[@alt=\"SignOff Button\"]")).click();        driver.quit();    }</code></pre></li></ul></li></ul><ul><li><p>主要过程：</p><ul><li><pre><code>//参数化        //写明文件地址                File file=new File("D:\\flights.txt");                //以byte字节读取文件                FileReader bytes=new FileReader(file);                //把byte读成字符                BufferedReader chars=new BufferedReader(bytes);                //读之前row为0                String row=null;                //一行一行循环去读                while((row=chars.readLine())!=null) {                    String cols[]=row.split("\t");                    //选票                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    new Select(driver.findElement(By.name("depart"))).selectByVisibleText("cols[0]");                    new Select(driver.findElement(By.name("arrive"))).selectByVisibleText("cols[1]");                    driver.findElement(By.name("findFlights")).click();                    Thread.sleep(3000);                    //                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    driver.findElements(By.name("outboundFlight")).get(1).click();                    driver.findElement(By.name("reserveFlights")).click();                    //                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    driver.findElement(By.name("buyFlights")).click();                    driver.switchTo().defaultContent();                    driver.switchTo().frame("body");                    driver.switchTo().frame("info");                    driver.findElement(By.name("Book Another")).click();                }                bytes.close();        Thread.sleep(3000);</code></pre></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于MIPS32指令集的CPU微架构设计</title>
      <link href="/posts/33736.html"/>
      <url>/posts/33736.html</url>
      
        <content type="html"><![CDATA[<h3 id="3-5-1-MIPS32的指令"><a href="#3-5-1-MIPS32的指令" class="headerlink" title="3.5.1 MIPS32的指令"></a>3.5.1 MIPS32的指令</h3><h5 id="mips32是一种精简指令集"><a href="#mips32是一种精简指令集" class="headerlink" title="mips32是一种精简指令集"></a>mips32是一种精简指令集</h5><ul><li>mips32指令集是一种精简指令集<ul><li>指令的数量非常少</li><li>指令也非常规整</li></ul></li><li>在运用MIPS32指令架构指令的时候<ul><li>要求存储器按字节编址<ul><li>这也意味着每一条MIPS2指令都需要存储占用四个字节</li></ul></li></ul></li><li>在mips32架构的指令中，可以使用到的寄存器数量为32个，宽度也为32位</li><li>总体上说，mips32指令集是一种精简架构，即RISC架构</li></ul><h5 id="结合高级语言编程，考虑处理器应该有哪些类型的指令"><a href="#结合高级语言编程，考虑处理器应该有哪些类型的指令" class="headerlink" title="结合高级语言编程，考虑处理器应该有哪些类型的指令"></a>结合高级语言编程，考虑处理器应该有哪些类型的指令</h5><ul><li>运算指令    eg：算术运算，逻辑运算</li><li>访存指令    eg：把一个数从寄存器中写入存储器，或者把数据从存储器中读出来，写回到寄存器</li><li>转移指令    eg：无条件转移、条件的转移</li></ul><h5 id="MIPS32中可提供的寄存器列表"><a href="#MIPS32中可提供的寄存器列表" class="headerlink" title="MIPS32中可提供的寄存器列表"></a>MIPS32中可提供的寄存器列表</h5><p><img src="/posts/33736/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt=""></p><ul><li>每一个寄存器的宽度也都是32位</li><li>eg：<ul><li>第0号寄存器是用来保存固定的常数</li><li>1号寄存器是汇编器专用的</li></ul></li></ul><h4 id="3-5-1-1-MIPS32指令的指令格式与指令集"><a href="#3-5-1-1-MIPS32指令的指令格式与指令集" class="headerlink" title="3.5.1.1 MIPS32指令的指令格式与指令集"></a>3.5.1.1 MIPS32指令的指令格式与指令集</h4><p>指令字长固定为32位</p><p>如果采用寄存器型寻址，指令中还需要给出寄存器号</p><ul><li><p>指令类型有三种：R型，I型，J型</p><ul><li><p>R型指令：</p><ul><li>高六位是操作码</li><li>后面紧跟着三个寄存器的编号，每个编号都是五位</li><li>再后面是5位的shamt字段<ul><li>这个字段是用于R型的移位指令</li></ul></li><li>最后面是6位的功能说明字段func</li></ul></li><li><p>I型指令</p><ul><li>高六位也是操作码OP</li><li>后面紧跟两个寄存器编号，RS,RT，每个寄存器的编号也都是5位</li><li>后面还跟了一个16位立即数</li></ul></li><li><p>J型指令</p><ul><li>结构更简单</li><li>只有一个操作码占6位和立即数占26位</li></ul><p><img src="/posts/33736/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt=""></p></li></ul></li></ul><h5 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h5><ul><li><p>register</p></li><li><p>Rs(5)</p><p><img src="/posts/33736/R%E5%9E%8B%E6%8C%87%E4%BB%A4.png" alt=""></p></li></ul><h5 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h5><ul><li><p>也称为立即数型 Immediate</p></li><li><p>长度仍然是32位</p><ul><li>OP操作码占6位，两个寄存器编号分别占5位，后面还有一个16位的立即数</li></ul></li><li><p>操作数中涉及立即数</p><ul><li>所以取这个立即数的时候，采用立即寻址方式</li><li>运算后的结果保存到寄存器</li></ul></li><li><p>op：</p><ul><li>是一个操作码</li><li>用于标识指令的操作功能</li></ul></li><li><p>rs：</p><ul><li>是第一个源操作数，寄存器对应的编号</li><li>是寄存器操作数</li></ul></li><li><p>rt：</p><ul><li>是目的寄存器的编号</li><li>用来保存运算后的·结果</li></ul></li><li><p>imm：</p><ul><li><p>是第二个源操作数</p></li><li><p>是一个立即数</p><p><img src="/posts/33736/I%E5%9E%8B%E6%8C%87%E4%BB%A4.png" alt=""></p></li></ul></li></ul><h5 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h5><ul><li>称为跳转型指令 jump</li><li>J型指令用于实现无条件转移<ul><li>op：<ul><li>是一个操作码，长度为6位</li><li>用于确定指令的功能，表示具体是哪一种类型的转移</li></ul></li><li>address:<ul><li>是一个转移目标地址的偏移量字段</li><li>长度为26</li></ul></li><li><img src="/posts/33736/J%E5%9E%8B%E6%8C%87%E4%BB%A4.png" alt=""></li></ul></li></ul><h4 id="3-5-1-2-MIPS32寻址方式"><a href="#3-5-1-2-MIPS32寻址方式" class="headerlink" title="3.5.1.2 MIPS32寻址方式"></a>3.5.1.2 MIPS32寻址方式</h4><ul><li>mips32架构的指令集是一种精简指令集<ul><li>所以它的指令集数量很少<ul><li>所以寻址方式也较少</li></ul></li></ul></li><li>在MIPS32指令集中<ul><li>不会单设 寻址方式说明字段</li><li>而是 通过OP字段和func字段（针对R型指令）隐含说明当前的指令采取什么寻址方式</li></ul></li><li>R型指令：<ul><li>由op和func字段共同隐含说明当前的寻址方式</li></ul></li><li>I型和J型：<ul><li>只需要操作吗OP字段即可隐含说明当前指令说明的寻址方式</li></ul></li></ul><h5 id="寻址方式："><a href="#寻址方式：" class="headerlink" title="寻址方式："></a>寻址方式：</h5><ul><li><p><strong>立即数寻址</strong></p><ul><li>Immediate addressing</li><li>此时，操作数是包含在指令中的立即数字段</li><li>指令格式：<ul><li><img src="/posts/33736/%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80.png" alt=""></li><li>比如相应的一条具体指令 addi s1,s2,  10<ul><li>这里的常数10是保存在指令当中的一个立即数<ul><li>因此在取指令的时候，把指令当中的最低的16位代码截取出来，就能够给到我们要的操作数10</li><li>这就是一种立即数寻址方式<ul><li>直接从指令中截取得到立即数</li></ul></li></ul></li><li>注意此处C1对应rt寄存器，s2对应rs寄存器<ul><li>指令完成的功能就是<ul><li>把s2中保存的内容跟立即数进行扩展以后的结果进行相加</li><li>再把相加的结果放回s1寄存器</li></ul></li></ul></li></ul></li><li>注意：<ul><li>在汇编格式当中<ul><li>是把目的地址放在前面</li><li>源地址放在后面</li></ul></li><li>但在指令的编排顺序中<ul><li>源地址之后才是目的地址</li><li>然后再是立即数</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>寄存器直接寻址</strong></p><ul><li>Register Addressing</li><li>这时所需要的操作数直接在寄存器中</li><li>指令格式：<ul><li><img src="/posts/33736/%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt=""></li><li>从格式上看，这是一种典型的R型指令<ul><li>除了操作码外，还包括三个寄存器的编号，另外还有一个功能说明字段</li><li>6位的操作码，相应的代码全为0</li></ul></li><li>如果采用寄存器直接寻址<ul><li>相应的操作数直接在寄存器中</li><li>比如我们可以根据指令当中的寄存器编号：rs<ul><li>然后根据此编号去定位到寄存器rs</li></ul></li><li>这样可以从寄存器中读取出数据值<ul><li>这是一种典型的寄存器直接寻址方式<ul><li>直接根据指令中给出的寄存器编号去定位寄存器</li><li>从而读取到数据值</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><strong>基址寻址</strong></p><ul><li>Basic Addressing</li><li>在基址寻址方式运用时，操作数由寄存器和立即数字段联合产生</li><li>指令格式：<ul><li><img src="/posts/33736/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt=""></li><li>从格式上看，这是一种典型的I型指令<ul><li>包括操作码字段OP,还有两个寄存器编号，最后是16位的立即数</li></ul></li><li>我们所需要的操作数是保存在存储器当中的<ul><li>而且16位立即数也是16位的带符号常数，使用补码来表示的</li></ul></li><li>采用基址寻址方式时<ul><li>直接根据指令当中给出的寄存器编号</li><li>根据这个寄存器编号去定位到寄存器</li><li>然后从寄存器中读取一个基准地址码<ul><li>然后把16位立即数 带符号 扩展为32位</li><li>扩展完后跟基准地址码相加</li><li>从而得到目标地址</li></ul></li><li>然后根据目标地址去寻址存储器<ul><li>定位到存储单元后</li><li>就可以从存储单元中读取到数据字</li></ul></li><li>这就是基址寻址方式<ul><li>根据指令当中给出的寄存器编号，读取一个寄存器，给到基准地址，然后把指令当中给出的立即数进行带符号扩展，扩展后跟基准地址相加，形成目标地址，然后读取存储单元，从而读取到数据值</li></ul></li><li>注意：这种带符号的扩展，指令当中的16位立即数是一个带符号的常数，而且是用补码表示的<ul><li>所以，带符号扩展时，正数在高位补上16个0</li><li>负数，在高位补上16个1</li></ul></li></ul></li></ul></li></ul></li><li><p>PC<strong>相对寻址</strong></p><ul><li><p>PC-relative Addressing</p></li><li><p>是相对于PC寄存器的一种寻址方式</p></li><li><p>此时，操作数由寄存器和立即数字段联合产生</p><ul><li><p>比如有这样一个格式：</p><ul><li><img src="/posts/33736/PC相对寻址.png" style="zoom:50%;"></li><li><p>从格式看，是一个典型的I型立即数指令</p><ul><li>低位的立即数imm是一个16位的带符号的常数，而且使用补码表示的</li></ul></li><li><p>采用PC相对寻址方式时，</p><ul><li>我们需要的目标存储单元是在主存当中的</li><li>因为他是相对于PC寄存器进行寻址<ul><li>所以，他就去读取PC寄存器</li><li>从PC寄存器中读取到当前地址码</li></ul></li><li>然后再把指令的立即数带符号扩展成32位并左移2位</li><li>再把扩展以后的结果跟PC的当前值相加<ul><li>形成目标地址</li><li>有了目标地址后，就根据目标地址去定位存储单元，从存储单元中读取到数据值</li></ul></li></ul></li><li><p>它实际上是一种特殊的基址寻址方式</p><ul><li>如果把pc寄存器看成是一个基准地址的寄存器</li><li>那么这种pc相对寻址方式就是一种典型的基址寻址方式</li><li>只不过这里使用的基地址寄存器是pc寄存器，比较特殊而已</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>伪直接寻址</strong></p><ul><li>Pseudo-direct Addressing</li><li>也叫页面寻址，由PC高四位与指令中的地址段组合产生有效地址</li><li>从格式上看，是一种典型的J型指令<ul><li>只有一个操作码op以及26位的地址码Address</li></ul></li><li>如果采用伪直接寻址方式<ul><li>目标单元在存储器中</li><li>这时需要读取PC寄存器<ul><li>读取到PC寄存器的高四位</li><li>然后把这个高四位与26位的地址码左移两位之后的结果拼接</li><li>拼接后的结果才是目标地址</li></ul></li><li>之后根据目标地址去读取存储器<ul><li>这样就可以读取到指令字</li><li>也就是下一条指令</li></ul></li></ul></li><li>在这种寻址方式之中，为什么也要把26位的地址码左移两位后，再跟pc当前值高四位进行拼接呢？<ul><li>是因为每一条MIPS32架构的指令</li><li>他的指令字长是32位</li><li>占用4个存储单元</li><li>所以必须把26位的地址码左移两位后，确保最低两位为0，这样才能跟指令集的存储边界对齐</li></ul></li><li><img src="/posts/33736/%E4%BC%AA%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt=""></li></ul></li></ul><h4 id="3-5-1-3-MIPS32指令的编码与功能"><a href="#3-5-1-3-MIPS32指令的编码与功能" class="headerlink" title="3.5.1.3 MIPS32指令的编码与功能"></a>3.5.1.3 MIPS32指令的编码与功能</h4><ul><li>总体上，MIPS32架构的指令集包含三种类型的指令：I型，J型，R型<ul><li>这些类型的指令有什么功能？</li><li>他们的代码编排情况如何？</li></ul></li></ul><h5 id="R型指令-1"><a href="#R型指令-1" class="headerlink" title="R型指令"></a>R型指令</h5><ul><li><p><img src="/posts/33736/R%E5%9E%8B.png" alt=""></p></li><li><p>有加法有减法，有逻辑与逻辑或移位等等</p></li><li><p>指令的编码中</p><ul><li>最高6位全部为零<ul><li>他就是表示操作码</li></ul></li><li>最低的6位是一个功能说明字段<ul><li>sa：移位说明字段</li></ul></li><li>另外还包括RS,RT,RD这样一些寄存器的编号</li></ul></li><li><p>需要根据操作码OP配合功能说明字段才能确定R型指令具体执行什么操作</p><ul><li>因为它的操作码全为0</li></ul></li><li><p>R型指令存在三种不同类型：</p><ul><li>3寄存器R型指令<ul><li><img src="/posts/33736/3%E5%AF%84%E5%AD%98%E5%99%A8r%E5%9E%8B.png" alt=""></li><li>这些指令的操作码，最高的六位全为0,<ul><li>每一条指令都使用了3个寄存器：rs,rt,rd</li><li>都没有使用移位说明字段sa</li><li>但是每一条指令都会使用6位的功能说明字段<ul><li>功能说明字段的最高3位全部为100</li><li>后三位彼此不相同</li></ul></li></ul></li><li>这种使用三个寄存器的R型指令的功能：<ul><li>是把rs寄存器、rt寄存器当中的数据取出来</li><li>两者做一个运算</li><li>运算后的结果写回到第三个寄存器rd当中</li></ul></li></ul></li><li>2寄存器R型指令<ul><li>逻辑左移，逻辑右移，算数左移</li><li><img src="/posts/33736/2%E5%AF%84%E5%AD%98%E5%99%A8r%E5%9E%8B.png" alt=""></li><li>这些指令的操作码op的6位都全部为0<ul><li>没有使用rs这个寄存器字段</li><li>但是使用了rt、rd这样的字段</li><li>以及使用了一个移位说明字段sa</li><li>还是用了6位的功能说明字段<ul><li>功能说明字段的最高三位全为0</li><li>最低的三位彼此不同</li></ul></li></ul></li><li>这些只使用了两个寄存器的R型指令的功能是：<ul><li>从RT寄存器中读取出操作数</li><li>然后把操作数进行移位</li><li>移多少位主要有sa字段确定</li><li>移位的结果再写回rd寄存器中</li></ul></li></ul></li><li>1寄存器R型指令<ul><li>即只使用了一个寄存器的R型指令</li><li>这种类型的指令非常少<ul><li><img src="/posts/33736/1%E5%AF%84%E5%AD%98%E5%99%A8R%E5%9E%8B.png" alt=""></li></ul></li><li>这是一种寄存器型的跳转指令<ul><li>她的操作码6位都全部为0</li><li>使用一个rs寄存器<ul><li>没使用rt,rd，sa字段</li></ul></li><li>最后使用了一个6位的功能说明字段<ul><li>这个功能说明字段最高三位是001</li><li>最后三位是000</li></ul></li></ul></li><li>这种寄存器型的跳转指令的功能是：<ul><li>把rs寄存器中保存的地址码作为目标地址</li><li>打入到PC寄存器</li><li>这样就能实现寄存器的跳转</li><li>以寄存器中保存的地址码来进行跳转</li></ul></li></ul></li></ul></li></ul><h5 id="I型指令-1"><a href="#I型指令-1" class="headerlink" title="I型指令"></a>I型指令</h5><ul><li>包含：<ul><li><img src="/posts/33736/I%E5%9E%8B.png" alt=""></li><li>它们的操作码都不相同</li><li>每一条指令都包括rs,rt两个寄存器<ul><li>另外还是用了一个16位的立即数</li></ul></li></ul></li><li>I型指令，存在4种不同类型：<ul><li>面向运算的I型指令<ul><li>主要包括这些指令：<ul><li><img src="/posts/33736/%E9%9D%A2%E5%90%91%E8%BF%90%E7%AE%97.png" alt=""></li><li>这种指令操作码高三位全部为001<ul><li>低三位相互不同</li><li>使用rs,rt这两个寄存器<ul><li>在指令中它们以编号的方式出现</li></ul></li><li>最低的16位都是一个立即数imm</li></ul></li><li>这种运算指令完成的功能：<ul><li>首先从rs寄存器中读取出一个数</li><li>然后再把16位的立即数进行扩展<ul><li>可能是符号扩展或者逻辑扩展</li></ul></li><li>扩展后，跟读取出的寄存器数进行相加<ul><li>把相加后的结果保存到第二个寄存器rt当中</li></ul></li></ul></li><li>这里的imm一般是数值型的数据<ul><li>所以它一般需要“带符号扩展”</li><li>如果是逻辑型数据<ul><li>他就需要逻辑型扩展，也就是“无符号扩展”</li></ul></li></ul></li></ul></li></ul></li><li>面向访存的I型指令<ul><li>包括以下指令：<ul><li><img src="/posts/33736/%E9%9D%A2%E5%90%91%E8%AE%BF%E5%AD%98.png" alt=""></li><li>一种是取数指令，另一种是存数指令<ul><li>这两条指令的高三位不同<ul><li>但是最低三位都是011</li></ul></li><li>也使用了两个寄存器，rs,rt</li><li>还使用了一个16位的立即数</li></ul></li><li>这两条指令实际上也是mips32架构指令集中唯一两条能够访问存储器的指令</li><li>图中lw rt…指令的功能：<ul><li>实际上是取数</li><li>怎样去取？<ul><li>首先就是要把rs当成一个基址寄存器</li><li>然后从基址寄存器中读取一个基准地址</li><li>再把16位的立即数进行扩展</li><li>扩展后的结果与基准地址相加</li><li>形成主存的目标地址，去读取主存</li><li>读取到的数据写入rt这个寄存器中</li></ul></li></ul></li><li>图中存数指令sw rt,imm(rs)。。。。完成的功能刚好相反<ul><li>他把rt当中的数读出来之后</li><li>存入存储器中</li><li>存储器的目标单元地址如何形成？<ul><li>跟取数指令一样</li><li>这里也是通过寄存器基址寻址方式产生主存的目标地址</li><li>把基址寄存器rs当中的数据读出来<ul><li>再把16位的立即数进行扩展</li><li>扩展到32位后</li><li>两者相加，相加后的结果就是目标地址</li></ul></li><li>然后根据目标地址定位到主存单元<ul><li>把rt寄存器当中的数据写入到这个主存单元</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>面向数位设置的I型指令<ul><li><img src="/posts/33736/%E9%9D%A2%E5%90%91%E6%95%B0%E4%BD%8D.png" alt=""></li><li>它的<ul><li>操作码高两位都为0</li><li>低四位都为1</li><li>未使用rs寄存器，但使用rt寄存器</li><li>还使用16位立即数</li></ul></li><li>这条指令完成的功能：<ul><li>设置寄存器的高16位</li></ul></li><li>具体操作：<ul><li>lui ru,imm…..</li><li>把16位的立即数左移16位之后<ul><li>把左移后的结果写回入rt寄存器</li><li>在左移16位时，需要空位补0<ul><li>这样就能确保16位的立即数全部移动到寄存器的高位</li></ul></li></ul></li></ul></li></ul></li><li>面向条件转移（分支）的I型指令<ul><li><img src="/posts/33736/%E9%9D%A2%E5%90%91%E6%9D%A1%E4%BB%B6.png" alt=""></li><li>这两条指令操作码的高四位全部为0001<ul><li>低两位是01和00</li><li>都使用了两个寄存器rs,rt</li><li>还使用了一个16位立即数<ul><li>imm</li></ul></li></ul></li><li>这两条指令完成的功能:<ul><li>首先是beq rs,rt,imm<ul><li>当rs和rt这两个寄存器相等的时候<ul><li>那么就把16位的立即数进行扩展</li><li>扩展成32位然后左移两位</li><li>再跟PC寄存器中保存的地址码相加<ul><li>相加后形成目标地址，把目标地址打入PC寄存器</li></ul></li></ul></li><li>这种方式实际是一种pc相对寻址方式</li><li>如果寄存器rs,rt中保存的信息不相等<ul><li>那么就不进行分支</li><li>直接把pc加4打入到pc寄存器</li></ul></li></ul></li><li>然后是bne rs,rt,imm<ul><li>这条指令的含义是不相等的时候进行分支</li><li>所以他完成的操作就是<ul><li>判断rs和rt两个寄存器当中保存的信息是否相等</li><li>如果不相等，那么就按照pc相对寻址方式来形成目标地址</li><li>然后再把目标地址打入到pc</li><li>如果两者相等，那么就不进行分支，直接把pc加4打入到pc寄存器</li></ul></li></ul></li><li>因为这两条指令采用的是pc相对寻址方式<ul><li>所以在对16位立即数进行扩展的时候</li><li>也都是符号扩展</li><li>所以也就需要把imm带符号扩展为32位，再左移2位<ul><li>确保形成的地址码跟指令字存储的边界相对齐</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="J型指令-1"><a href="#J型指令-1" class="headerlink" title="J型指令"></a>J型指令</h5><ul><li>列出两条：<ul><li><img src="/posts/33736/J%E5%9E%8B.png" alt=""></li><li>这两条指令的高6位都是操作码<ul><li>而且高两位都为0</li><li>最低四位是不同的<ul><li>前者为0010，后者为1100</li></ul></li><li>除了操作码以外，还剩下一个26位的地址码字段<ul><li>前者完成的是一个无条件跳转</li><li>后者完成的是调用和联接</li></ul></li></ul></li><li>对于指令 j address:<ul><li>他完成的指令操作就是<ul><li>把26位的地址码address左移两位形成28位的地址码</li><li>然后再跟pc当前值的高四位相拼接<ul><li>形成目标地址</li></ul></li><li>最后再把目标地址打入到pc寄存器中</li><li>这样就能实现无条件的跳转</li></ul></li><li>这条指令当中涉及到的寻址方式是<ul><li>标准的伪直接寻址方式</li></ul></li></ul></li><li>第二条指令： jal address<ul><li>这条指令完成的操作跟第一条指令相比，多一个保存返回地址的操作<ul><li>为了确保指令调用函数以后能够正常返回</li><li>所以它需要把返回地址pc加4写入到第31号寄存器ra当中</li><li>再采用伪直接寻址方式来形成目标地址<ul><li>并且把目标地址打入到pc寄存器</li><li>这样就能实现跳转</li><li>跳转完成后还能实现返回<ul><li>返回地址是从ra寄存器中读取</li></ul></li></ul></li></ul></li><li>他的确是一种标准的页面寻址方式<ul><li>也就是伪直接寻址方式</li></ul></li></ul></li></ul></li></ul><h3 id="3-5-2-MIPS32架构CPU设计-基础部件分析"><a href="#3-5-2-MIPS32架构CPU设计-基础部件分析" class="headerlink" title="3.5.2 MIPS32架构CPU设计-基础部件分析"></a>3.5.2 MIPS32架构CPU设计-基础部件分析</h3><h4 id="3-5-2-1-基础部件-存储与运算部件"><a href="#3-5-2-1-基础部件-存储与运算部件" class="headerlink" title="3.5.2.1 基础部件-存储与运算部件"></a>3.5.2.1 基础部件-存储与运算部件</h4><ul><li>cpu的内部包括很多功能部件<ul><li>这些功能部件之间通过数据通路和控制通路把它们连接在一起</li><li>形成cpu的整体</li></ul></li><li>因此在设计mips32架构的单周期cpu之前<ul><li>我们首先要了解一下<ul><li><strong>可能使用到的一些功能部件</strong></li><li>第一种功能部件就是，与存储相关的部件<ul><li>包括存储器、寄存器等等</li></ul></li><li>2.数据预处理部件<ul><li>eg：把数据左移两位，把数据从16位扩展到32位</li></ul></li><li>3.运算部件<ul><li>包括pc+4的一些加法器</li><li>或做逻辑运算的alu等等</li></ul></li><li>4.数据通路选择部件<ul><li>主要是一些多路选择器</li><li>可能会使用到二选一的多路选择器或者三选一的多路选择器</li></ul></li><li>最核心的：  控制单元（控制器）</li></ul></li></ul></li></ul><h5 id="1-存储相关的部件"><a href="#1-存储相关的部件" class="headerlink" title="1.存储相关的部件"></a>1.存储相关的部件</h5><h6 id="1-寄存器堆（组）"><a href="#1-寄存器堆（组）" class="headerlink" title="1.寄存器堆（组）"></a>1.寄存器堆（组）</h6><ul><li><p>什么时候可能会使用到寄存器堆？</p><ul><li>主要是在读数据和写数据时<ul><li>读数据：（根据指令中的rs或rt）</li><li>写数据：（根据指令中的rt或rd）</li></ul></li><li>读数据：实际上是根据指令当中提供的寄存器编号<ul><li>从寄存器中读取数据</li></ul></li><li>写数据的时候也是根据指令当中的目的地址，把数据写入目标寄存器中</li><li>所以读数据写数据时都可能使用到一些寄存器</li></ul></li><li><p>因为在mips32架构的·cpu当中</p><ul><li>总共可以使用的寄存器数量只有32个</li><li>而且每一个寄存器的宽度也都是32位<ul><li>为了集成度更高，通常使用多端口的小存储器来构成寄存器堆</li><li>在这个寄存器堆中包含了32个寄存器<ul><li>因此，这就要求小型存储器至少要包括32个独立的存储单元</li><li>存储器的数据宽度也都是32位</li></ul></li></ul></li></ul></li><li><p>这是一个多端口的寄存器堆：</p><ul><li><img src="/posts/33736/%E5%A4%9A%E7%AB%AF%E5%8F%A3%E5%AF%84%E5%AD%98%E5%99%A8%E5%A0%86.png" alt=""></li></ul></li><li><p>这个寄存器堆的参数是32 x 32</p><ul><li>就表明它是用一个小型存储器来构成的</li><li>而且在这个小型存储器内部，包括了32个独立的存储单元，每一个存储单元的数据宽度也都是32位</li></ul></li><li><p>为了更加清楚的说明寄存器堆的输入输出特性，这里我们让一个R型指令来进行配合说明</p><ul><li>寄存器中有两个地址端口：Ra，Rb<ul><li>她们实际上就是接收从指令当中来自两个寄存器编号<ul><li>这两个寄存器编号rs，rt也都是5位</li></ul></li></ul></li><li>输入两个目标地址以后，就可以直接从寄存器当中读出两个数据<ul><li>这两个数据分别从A端口和B端口输出</li><li>输出的数据也都是32位</li><li>而且A端口输出的数据和B端口输出的数据分别跟地址端口ra，rb相对应</li></ul></li><li>另外寄存器堆还有一个32位的数据输入端口<ul><li>把它标记为data</li><li>数据要写入到寄存器堆的时候<ul><li>需要在Rw这个写地址端口输入一个5位的地址码</li><li>Rw就是写入数据时候的一个目标地址</li></ul></li></ul></li><li>另外寄存器堆还有一个协时控制信号<ul><li>把它标记为Wn</li><li>Wn为1为高电平的时候，就能把寄存器堆设置为写模式</li><li>如果Wn为0为低电平，那么寄存器堆就处于读模式</li></ul></li><li>通常寄存器堆也可以设计为一个时序部件<ul><li>特别是把数据写入到寄存器堆的时候</li><li>通常需要一个时钟信号的边沿来进行驱动</li><li>所以寄存器堆就会接受一个clock信号</li></ul></li><li>从寄存器堆的输入输出关系我们可以看到，data端输入的数据只有在Wn=1，也就是寄存器堆处于写模式的时候，当时钟边沿信号到来，在时钟信号的驱动之下才能把数据data写入到寄存器堆的某一个寄存器<ul><li>目标寄存器主要是由rw地址端口输入的目标地址码来确定的</li></ul></li></ul></li></ul><h6 id="2-存储器"><a href="#2-存储器" class="headerlink" title="2.存储器"></a>2.存储器</h6><ul><li><p>指令是包括在指令存储器当中的，数据一般是包括在数据存储器当中的</p><ul><li>所以在读出指令的时候，需要使用到指令存储器</li><li>读写操作数保存结果的时候，会使用到数据存储器</li><li>因此就会涉及到两种不同类型的存储器<ul><li>即：指令存储器、数据存储器</li></ul></li></ul></li><li><p>指令存储器:</p><ul><li>它有一个32位的地址输入端口，这个地址输入端口输入的地址码通常是来自PC寄存器</li><li>另外指令存储器还有一个32位的指令代码输出端口，标记为Inst_code</li><li>指令存储器通常是一个时序部件，因此它也需要接收一个时钟信号clock</li><li>结构：<ul><li><img src="/posts/33736/%E6%8C%87%E4%BB%A4%E5%AD%98%E5%82%A8%E5%99%A8.png" alt=""></li></ul></li></ul></li><li><p>数据存储器：</p><ul><li><p>它有一个输入地址，输入地址是32位</p></li><li><p>还有一个输入数据的端口</p><ul><li>这个数据端口输入的数据也是32位</li></ul></li><li><p>也有两个控制信号</p><ul><li>第一个控制信号是把数据存储器设置为写模式的控制信号<ul><li>标记为Mem_write</li></ul></li><li>数据存储器根据输入的32位地址码还能够产生一个32位的数据输出<ul><li>因此他还有一个数据的输出端口：Mem_out</li></ul></li></ul></li><li><p>另外她还有一个端口是用来控制把存储器设置成读模式：Mem_write</p></li><li><p>总体上看，数据存储器有两个输入端口，一个输出端口</p><ul><li><p>既可以输入地址</p></li><li><p>还可以输入数据</p></li><li><p>同时还可以从存储器中输出数据</p></li><li><p>另外它也有两个读写模式的控制信号write和read</p></li><li><p>除此之外，数据存储器中的读写要用时钟信号进行驱动，因此数据存储器也会接受一个clock信号</p></li><li><p>下面的表格清晰地展示了当write和read信号它们在不同高低电平时，数据存储器处于的不同的模式</p><ul><li><p>write为1，read为0，数据存储器处于写模式</p></li><li><p>。。。</p></li><li><img src="/posts/33736/数据存储器.png" style="zoom:50%;"></li></ul></li></ul></li></ul></li></ul><h6 id="3-特殊功能寄存器"><a href="#3-特殊功能寄存器" class="headerlink" title="3.特殊功能寄存器"></a>3.特殊功能寄存器</h6><ul><li><img src="/posts/33736/特殊功能寄存器.png" style="zoom:67%;"></li><li>比如PC程序计数器，IR指令寄存器，FR标志寄存器（相似于程序状态字寄存器，其中的标志位是与运算器相关的，根据运算器输出的结果自动地设计这些标志位）</li><li>以下是一个寄存器的示意图<ul><li>这个寄存器有可能往里面写入数据，也有可能往外面输出数据</li><li>因此它也会有一个写使能信号Enable</li><li>寄存器也通常会被设计为一个时序部件<ul><li>因此，它也需要接收一个时钟信号clock<ul><li>当Enable=0，为低电平的时候，如果时钟的边沿信号到来，在时钟信号的驱动之下，就可以从寄存器中读出数据，输出的数据也是32位的</li><li>当Enable为1，为高电平时，在时钟边沿信号的驱动之下，数据才可能从外面写入到寄存器当中，这是寄存器的一个输入输出控制关系模式</li></ul></li></ul></li></ul></li><li>PC程序寄存器和IR指令寄存器在数据通路中的作用：<ul><li><img src="/posts/33736/pc作用.png" style="zoom:50%;"></li><li>起着非常重要的作用</li><li>pc寄存器中保存着指令地址码<ul><li>那么就在寻址的时候，根据指令的地址码去对指令存储器进行寻址</li><li>寻址到目标指令的存储单元</li><li>然后在时钟信号的驱动之下，从指令存储器中输出指令代码，输出的代码又写入到指令寄存器当中，后续的操作就是在指令寄存器当中保存的32位的指令代码进行解析的基础之上进行</li></ul></li></ul></li></ul><h5 id="2-运算部件"><a href="#2-运算部件" class="headerlink" title="2.运算部件"></a>2.运算部件</h5><ul><li>指令在执行的时候有可能会涉及到加法减法等等<ul><li>这时候就需要一个算术逻辑运算单元ALU</li></ul></li><li>另外取址以后，pc当中保存的地址码会自动加4<ul><li>这时候会涉及到一个固定加4的简单运算器，即pc自增单元</li></ul></li></ul><h6 id="1-32位加法器-Adder"><a href="#1-32位加法器-Adder" class="headerlink" title="1.32位加法器-Adder"></a>1.32位加法器-Adder</h6><ul><li>这是一个加法器，只能执行简单的加法功能，没办法执行其他更加复杂的运算</li><li>这个加法器有两个输入：A和B<ul><li>两个输入都是32位的数据</li></ul></li><li>还有一个输出<ul><li>输出也是一个32位的运算结果</li></ul></li><li>加法器的输入端口A，可以输入一个固定的常数4<ul><li>所以在执行pc加4的时候，在B端口就输入的是PC寄存器中保存的地址码，然后在A端口输入一个常数4，输出端口就能输出一个固定的运算结果：pc+4</li><li><img src="/posts/33736/加法器.png" style="zoom:50%;"></li></ul></li></ul><h6 id="2-32位运算器-ALU"><a href="#2-32位运算器-ALU" class="headerlink" title="2.32位运算器-ALU"></a>2.32位运算器-ALU</h6><ul><li>ALU能做加法运算、减法运算、逻辑运算等等</li><li>她也有两个输入端口，A和B<ul><li>两个输入端口输入的数据也都是32位</li></ul></li><li>还有一个功能选择控制信号<ul><li>这个功能选择控制信号是n位的控制码operation</li><li>在不同的功能选择控制信号下，ALU根据A端口和B端口输入的数据做不同的运算</li><li>控制码的位数是n位<ul><li>因此在n位的代码，它们总共的排列组合方式只有2的n次方</li><li>所以它只能控制，不能超过2的n次方种不同的功能运算</li><li>所以，n与ALU的运算功能数m有关<ul><li><img src="/posts/33736/alu.png" style="zoom:50%;"></li><li>这样才能使N位的控制代码控制m种不同的运算</li><li>运算后输出的结果也是一个32位的数据，标记为SUM</li></ul></li></ul></li><li>另外它还会输出一些标志位<ul><li>比如0标志位，异数标志位，非负的标志位等等</li><li>这些标志位实际上是保存在标志寄存器之中，保存在程序状态字寄存器之中<ul><li>如果运算的结果为0，那么它的0标志位Z就会被自动设置为1<ul><li>这个0标志位特别是在进行分支指令的时候，通常就需要作一个控制单元的输入信号，控制单元就根据它来判断当前是否要执行分支</li></ul></li><li>如果运算结果有进位，那么它的C标志位就会自动地设置为1,</li><li>其他标志位也都是根据运算结果来自动设置的</li></ul></li></ul></li></ul></li><li>前面已经提到，在进行PC加4这种简单加法的时候，需要在简单加法器的输入端口A输入固定的常数4，但是对于ALU它的功能就更加复杂一些<ul><li>它在不同的operation4位操作码控制之下，ALU就执行不同的功能<ul><li>比如在0000的时候，ALU就能执行AND运算</li><li>在0001的时候，它又能够执行OR运算</li><li>。。。</li><li><img src="/posts/33736/ALU运算.png" style="zoom:50%;">- ALU要执行不同的运算操作，就需要在ALU的控制端输入不同的控制代码</li></ul></li></ul></li></ul><h5 id="3-数据预处理部件"><a href="#3-数据预处理部件" class="headerlink" title="3.数据预处理部件"></a>3.数据预处理部件</h5><ul><li>cpu设计过程当中，会使用到的第三种部件就是数据预处理部件</li><li>什么时候使用预处理部件？<ul><li>比如带符号的扩展，以及不带符号扩展（0扩展）</li><li>此时就需要预处理部件把16位扩展到32位</li><li>除此之外也涉及到左移两位的情况<ul><li>特别是在pc相对寻址方式的时候，需要把立即数扩展成32位而且还要左移两位</li><li>所以这时候也需要使用数据预处理部件</li></ul></li><li>另外还有一种情况<ul><li>就是在伪直接寻址方式的时候</li><li>她需要把pc寄存器当中保存的地址码的高四位，然后再跟16位的地址码左移2位以后形成的28位地址码进行拼接，这时候也需要使用到基于数据拼接的数据预处理部件</li></ul></li></ul></li></ul><h6 id="1-双模扩展器-Extender"><a href="#1-双模扩展器-Extender" class="headerlink" title="1.双模扩展器-Extender"></a>1.双模扩展器-Extender</h6><ul><li><img src="/posts/33736/双模扩展器.png" style="zoom:50%;"></li><li>它主要的功能就是把数据从16位扩展到32位</li><li>其中我们用一个E来表示<ul><li>输入部分是一个16位的立即数</li><li>输出部分是一个32位的输出数据</li><li>这就是一个扩展，把数据从16扩展到32位</li></ul></li><li>因为它涉及到带符号扩展和无符号扩展<ul><li>所以在扩展器的控制端还需要有个扩展的控制信号E</li><li>在控制信号的控制作用之下</li><li>这个扩展器可以执行符号扩展</li><li>也可以执行0扩展<ul><li>当控制信号E=1时，表明当前扩展器工作在符号扩展模式下，他就会把补码表示的数值型数据扩展成32位的带符号数据<ul><li>比如000A<ul><li>这是一个带符号的补码数据，是一个正数</li><li>所以进行符号扩展的时候，他就会自动地在前面补上16个0</li></ul></li><li>另外一个数据800A<ul><li>这是一个带符号的补码数，</li><li>还是一个负数</li><li>所以在进行带符号扩展的时候就直接在前面补上16个1</li></ul></li><li>在进行扩展的时候，正数高位全部补0，负数高位全部补1</li></ul></li><li>当控制信号E=0时，扩展器工作在逻辑扩展模式下，也称为零扩展<ul><li>这时候因为数据是一个逻辑型的变量，或者说一个无符号数</li><li>因此在扩展的时候只需要在高位全部补0<ul><li>比如002A<ul><li>这是一个逻辑量或无符号数</li><li>从16位扩展到32位的时候，就从高位补上16个0</li></ul></li><li>另一个数F12C<ul><li>这是一个逻辑型数据，或者说无符号数</li><li>因此在进行16位到32位扩展的时候，统统在高位补16个0</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h6 id="2-左移2位扩展器"><a href="#2-左移2位扩展器" class="headerlink" title="2.左移2位扩展器"></a>2.左移2位扩展器</h6><img src="/posts/33736/左移两位扩展器.png" style="zoom:50%;"><ul><li>它有一个输入<ul><li>输入有可能是一个32位的数据也有可能是26位的数据<ul><li>pc相对寻址下输入的是一个32位的数据</li><li>若采用伪直接寻址方式下他就是把指令下的26位立即数来进行左移2位的扩展<ul><li>扩展后输出的结果：<ul><li>如果输入是32位，那么它的输出也是32位，左移两位之后的空位全部补0</li><li>输入的数据为26位时，左移两位后形成28位，也是在最低两位补零<ul><li>比如上面的例子：例子上的数据全部表示为x<ul><li>在进行左移两位的时候，依次向左边移动两位</li><li>这样会在最低位空出两个位置</li><li>这两个位置上全部补0</li></ul></li><li>左移两位后自动补0，如果当前的数字是数值型，这也就等价于在原数据的基础之上乘4</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h6 id="3-2路拼接器"><a href="#3-2路拼接器" class="headerlink" title="3.2路拼接器"></a>3.2路拼接器</h6><img src="/posts/33736/2路拼接器.png" style="zoom:50%;"><ul><li>这里用U来表示是一个两路拼接器</li><li>它也有两个输入<ul><li>第一个输入是pc保存的地址码的高四位<ul><li>也就是pc的第28位到第31位</li></ul></li><li>另外还有一个立即数字段address<ul><li>此字段实际上就是从指令当中的16位左移两位后形成的18位的地址码</li></ul></li></ul></li><li>然后把pc的高四位和28位的地址码做一个简单拼接，输出一个32位的地址码</li><li>上述例子：<ul><li>假设pc寄存器中保存的当前地址码是A0000000</li><li>左移两位后形成的28位地址码是FFFFBB4</li><li>这两个数据通过拼接器就会把pc的当前值的高四位跟28位的地址码进行拼接，拼接后结果为AFFFFBB4</li><li>这个拼接器输出的目标地址实际上就是把pc的高四位跟28位的地址码直接拼凑在一起形成</li></ul></li></ul><h5 id="4-数据通路选择部件"><a href="#4-数据通路选择部件" class="headerlink" title="4.数据通路选择部件"></a>4.数据通路选择部件</h5><ul><li><img src="/posts/33736/mux.png" style="zoom:50%;"></li><li>也称为多路选择器，把他标记为MUX<ul><li>32位的多路选择器-MUX</li><li>这个MUX可以有多个数据源的途径，比如I1~In  <ul><li>一共有n的数据源的输入，每个数据源也都是32位</li></ul></li></ul></li><li>具体执行的时候，这个MUX也是靠输入的m位选通信号这样一个控制信号来控制它当前选中哪一个数据<ul><li>在m位选通信号的控制作用之下，它产生一个32位的输出</li><li>因为m位的选通控制信号最多有2的m次方这么多种排列组合方式<ul><li>他要对应到n种数据的输入源</li><li>所以就要求2的m次方一定要大于等于n</li><li>这样才能使每一种选通控制信号能够正确选中一个数据源作为输入，同D端口进行输出</li></ul></li></ul></li><li>这里有一个具体的实例：<ul><li><img src="/posts/33736/mux实例.png" style="zoom:50%;"></li><li>这是一个2选1的多路选择器</li><li>上面标记为1下面标记为0，为两个输入，一个为A，一个为B<ul><li>输入和输出也都是32位的</li></ul></li><li>假设当前的选通控制信号是1<ul><li>这个情况下他就会把A端口的输入作为C端口的输出</li><li>两者连接在一起</li></ul></li><li>另外一种情况：假设当前的输入控制信号是0<ul><li>他就会把B端口的输入当作C断口的输出</li><li>也就是把B和C连接在一起</li></ul></li><li>即通过不同的输入控制信号来让多路选择器选中不同的数据源<ul><li>这就是多路选择器的功能特性</li></ul></li></ul></li></ul><h3 id="3-5-3-mips32架构-单周期处理器设计-控制单元设计"><a href="#3-5-3-mips32架构-单周期处理器设计-控制单元设计" class="headerlink" title="3.5.3 mips32架构-单周期处理器设计-控制单元设计"></a>3.5.3 mips32架构-单周期处理器设计-控制单元设计</h3><h5 id="cpu的目标指令集"><a href="#cpu的目标指令集" class="headerlink" title="cpu的目标指令集"></a>cpu的目标指令集</h5><ul><li>根据指令执行所需要的时钟周期数的不同，有两种类型的cpu<ul><li>第一种是单周期的cpu<ul><li>单周期的cpu指令固定在一个时钟周期内完成<ul><li>这一类型的cpu特点：<ul><li>时间效率低，时钟宽度由单指令最长时间决定<ul><li>因为有的指令需要时间较长，有的指令时间较短，这时候时钟周期宽度只能有单指令最长时间来确定，执行时间较短的指令就会有很大的时间浪费</li></ul></li><li>在指令周期内，功能部件不能共享，冗余度大<ul><li>这是因为在指令的执行过程中，只有一个时钟驱动信号，所以相关的时序部件就不能共享，结果就导致硬件的冗余度非常大</li></ul></li></ul></li></ul></li></ul></li><li>第二种是多周期CPU<ul><li>多周期的cpu指令分散在多个时钟周期内完成<ul><li>这种类型cpu特点：<ul><li>时间利用效率高，因为此时时钟的宽度由单步最长时间来决定<ul><li>一条指令包括若干个时钟周期，就可以把时钟周期的宽度<ul><li>这样对于执行时间比较短的指令，它的浪费也相对比较小一些，时间效率高</li></ul></li></ul></li><li>而且不同的时钟周期之间，部件可以共享，冗余降低</li></ul></li></ul></li></ul></li></ul></li></ul><p>在设计cpu之前，<strong>首先要确定它的目标指令集</strong></p><h5 id="目标指令集："><a href="#目标指令集：" class="headerlink" title="目标指令集："></a>目标指令集：</h5><p>（共计11条，包括三种类型：R型，I型，J型）</p><img src="/posts/33736/目标指令集.png" style="zoom:50%;"><ul><li><p>第一种就是R型的运算指令</p><ul><li>这里只包括四条</li><li>有R型的加法，减法，与运算，或运算</li><li>R型运算指令完成的功能就是<ul><li>把rs和rt这两个寄存器中保存的数据进行运算</li></ul></li><li>运算的结果保存到rd寄存器<ul><li>所以这四条r型运算指令当中他使用的寻址方式就是r型直接寻址，所有的操作数以及保存结果都是根据直接读取寄存器得到的</li></ul></li></ul></li><li><p>第二种类型就是三条的I型运算指令</p><ul><li>包括立即数加，立即数与，立即数或<ul><li>I型运算指令完成的功能就是首先把16位立即数从指令当中取出来进行扩展</li></ul></li><li>扩展成32位的操作数</li><li>然后再跟寄存器rs当中保存的数据相运算<ul><li>运算以后的结果保存到第二个寄存器rt当中</li><li>所以在这三条运算指令当中，它涉及到的寻址方式就主要是两种<ul><li>一种是立即数寻址</li><li>一种是寄存器直接寻址</li></ul></li><li>从指令当中截取出16位操作数，这是立即数寻址，读取rs寄存器当中的数据来进行运算，这是寄存器直接寻址方式</li></ul></li></ul></li><li><p>第三种类型就是两条i型的访存指令</p><ul><li>包括取数指令和存数指令</li><li>取数指令完成的功能就是把16位立即数进行扩展<ul><li>扩展成32位</li><li>然后再跟寄存器rs中保存的数据相加</li><li>相加以后作为目标地址，根据目标地址去访问存储器，读取到一个操作数<ul><li>把这个操作数保存到第二个存储器rt当中</li></ul></li></ul></li><li>存数指令完成的功能同样是把16位立即数进行扩展<ul><li>扩展到32位以后再跟rs寄存器中保存的数据相加</li><li>相加以后作为目标地址</li><li>然后再把rt寄存器中读取到的数据存入主存当中的目标存储单元</li></ul></li><li>所以I型的这两条访存指令，她们使用到的寻址方式主要就有两种<ul><li>第一种就是从指令当中截取出16位立即数来<ul><li>这种立即数寻址方式</li></ul></li><li>另一种就是寄存器基址寻址方式<ul><li>通过寄存器基址寻址方式来产生主存的目标地址</li></ul></li></ul></li></ul></li><li><p>第四个类型就是i型的分支指令</p><ul><li>beq也就是分支指令，<ul><li>这条指令完成的操作就是根据rs，rt两个寄存器中保存的数据来进行判断</li><li>如果两者相等<ul><li>那么就把立即数扩展成32位以后再左移两位</li><li>然后跟pc的当前值相加</li><li>相加以后作为目标地址把目标地址打入到pc寄存器</li></ul></li><li>如果两者不相等<ul><li>那么就直接把pc加4打入到目标寄存器</li></ul></li></ul></li><li>所以i型的分支指令beq它的寻址方式也主要有两种<ul><li>第一种就是从指令当中截取出16位立即数的寻址方式<ul><li>立即数寻址</li></ul></li><li>如果要进行分支，那么就是按照pc相对寻址方式来产生分支的目标地址</li></ul></li></ul></li><li><p>最后是一条J型的跳转指令j address</p><ul><li>这条指令把pc的当前值，也就是pc加4以后的地址码<ul><li>这个地址码的高四位拿出来跟address26位的立即数左移两位后的结果进行拼接</li><li>形成32位的目标地址码</li><li>把目标地址码打入到pc寄存器</li></ul></li><li>j型的指令跳转方式主要也有两种：<ul><li>第一种：从指令当中直接截取最低26位的立即数<ul><li>这种立即数寻址方式</li></ul></li><li>第二种：<ul><li>伪直接寻址方式</li><li>也称为页面寻址方式<ul><li>通过伪直接寻址方式来产生跳转的目标地址</li></ul></li></ul></li></ul></li></ul></li><li><p>所以在我们设计的单周期cpu当中，我们要求cpu能够支持这三种类型，总共11条指令</p><ul><li>cpu的设计过程，也都是基于这11条指令来进行的</li></ul></li></ul><h4 id="数据通路设计"><a href="#数据通路设计" class="headerlink" title="数据通路设计"></a>数据通路设计</h4><p>确定好cpu的目标指令之后，下一步就是设计指令的基本数据通路</p><h5 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h5><ul><li><p>面向指令功能，逐步扩展，融合，最后得到cpu的完整的结构</p><ul><li>首先要考虑她的取址，然后考虑r型，i型，j型，最后再把他们融合起来</li></ul></li><li><p>所以首先就需要分析三类指令的格式和功能</p><ul><li>包括r型，i型，j型</li><li>他们的指令格式以及他们完成的具体操作</li></ul></li><li><p>再选择功能部件，</p><ul><li>根据指令格式和功能，<ul><li>如果要用到加法，那么至少要用到加法器</li><li>如果要使用到左移两位，那么就需要用到左移两位器来进行确定</li></ul></li><li>确定这些功能以后，还要进一步根据指令在指令过程中涉及到的信息传输<ul><li>来确定部件之间的连接通路</li></ul></li></ul></li><li><p>最后整合冗余的部件连线</p><ul><li>这样就能得到最终的cpu硬件结构</li></ul></li></ul><img src="/posts/33736/完整数据通路.png" style="zoom:50%;"><p>由上图，单周期cpu需要执行11条目标指令，所以首先就是取指令，这里涉及到一个数据通路，然后还要进一步扩展r型指令和i型指令，还要去扩展出j型指令的数据通路</p><ul><li><p>在取指令的基础之上，我们首先是把r型和i型的数据通路进行整合</p><ul><li>在整合的基础之上，再进一步扩展出j型的跳转指令</li><li>最后再进行数据通路的整合</li><li>然后再和取指令的数据通路整合在一起<ul><li>这样就能够形成完整的cpu数据通路<ul><li>这是我们采用的一个基本的思路</li></ul></li></ul></li></ul></li><li><p>经过多次扩展融合以后，得到最终数据通路</p></li></ul><h5 id="数据通路："><a href="#数据通路：" class="headerlink" title="数据通路："></a>数据通路：</h5><h6 id="1-取值功能的数据通路（公共）"><a href="#1-取值功能的数据通路（公共）" class="headerlink" title="1.取值功能的数据通路（公共）"></a>1.取值功能的数据通路（公共）</h6><ul><li>这个取指功能是公共的，跟指令执行什么样的操作是没有关系的</li><li>如果进一步考虑取指的基本操作，他就是根据pc的当前值去读取存储器<ul><li>这里的存储器有可能是指令存储器，也有可能是普通的数据存储器</li></ul></li><li>在我们的设计过程中，我们把指令保存在单独的指令存储器之中<ul><li>所以根据pc的当前值去读取指令存储器，读取出来后把指令放到指令寄存器中，取指完成以后还要自动执行pc加4的操作<ul><li>目的就是 使pc保存的当前值能够指向下一条指令</li></ul></li><li>根据取指令完成的功能，我们可以看到在取指令的过程中会使用到pc寄存器<ul><li>因此数据通路当中应该有一个pc寄存器<ul><li>再读取指令的时候还需要使用到指令存储器，执行pc加4的时候需要使用到一个加法器，所以我们至少需要以下三个部件</li><li><img src="/posts/33736/取指数据通路.png" style="zoom:50%;"></li></ul></li></ul></li><li>首先pc寄存器输出的一个32位地址码，要作为指令存储器的一个地址码输入<ul><li>这是指令存储器的输入输出</li></ul></li><li>如果要考虑pc加4，那么还需要从pc的输出端邻接到加法器的一个输入端<ul><li>因为是加4</li><li>所以加法器的另一个输入端输入一个常数4</li><li>加法器运算后的结果就会形成PC+4</li><li>这里的pc加4刚好能指向下一条指令的存储单元，add输出的就是一个pc+4，pc+4在一定条件下它会去用来更新pc<ul><li>所以pc+4还会跟pc寄存器的输入端有一个邻接</li></ul></li></ul></li><li>上图就是取指之后所对应的数据通路，这个数据通路实际上也是根据取指功能来一步步确定的<ul><li>根据功能我们确定要使用哪些部件，再根据它的具体操作来确定部件和部件之间的联系</li></ul></li></ul></li></ul><h6 id="2-R型运算指令"><a href="#2-R型运算指令" class="headerlink" title="2.R型运算指令"></a>2.R型运算指令</h6><p>设计好取指操作的数据通路之后，下一步就是要面向11条目标指令来设计数据通路，先看第一种：R型运算指令</p><ul><li><p>R型运算指令操作码op全部为0，这时候需要根据功能说明字段func，两者联合一起来确定操作类型</p></li><li><p>R型运算指令有三个寄存器：rs，rt，和rd会参与运算</p><ul><li>eg：add rd,rs,rt<ul><li>我们通过这一条指令的数据通路来反推所有R型运算指令的数据通路</li><li>这条指令完成的基本操作就是把rs，rt这两个寄存器当中的数据读取出来以后做加法运算，运算结果写入到rd寄存器</li></ul></li></ul></li><li><p>怎么根据她的功能操作来设计数据通路？</p><ul><li><p>为了直观一点，我们把指令格式写出来：</p><ul><li><img src="/posts/33736/R1.png" style="zoom:50%;"></li><li>因为指令在执行过程当中需要读取rs和rt这两个寄存器当中的数据，这两个寄存器集成在寄存器堆中，所以从功能部件方面它需要使用到一个寄存器堆</li><li>这两个数据还要做加法运算，因此还需要使用一个ALU，在ALU当中做加法运算</li><li>指令的执行还少不了控制单元</li></ul></li><li><p>即部件即以上三个：寄存器堆，ALU，控制单元</p><ul><li>部件之间的连接线路应该怎么设计？<ul><li>指令的执行需要由控制单元产生控制信号</li><li>控制信号的产生依据主要就是操作码以及功能说明字段，这两个作为输入，输入到控制单元，控制单元才能够产生相应的控制信号</li><li>在读取寄存器堆的时候需要有两个寄存器的编号rs和rt，所以rs和rt就分别连接到寄存器堆的两个输入地址端口ra和rb<ul><li>根据哪个地址就可以从寄存器中读出数据</li><li>这两个数据要送入到ALU当中做加法运算<ul><li>因此寄存器的输出端口和ALU的两个输入端口之间有一个连接线</li><li>ALU做运算的时候会输出一个运算结果，同时还会输出一个标志位，这个标志位在R型运算指令中使用不到</li><li>运算的结果要写回寄存器堆，因此，ALU的输出端和寄存器的数据输入端口之间由一个数据线路的连接</li></ul></li><li>ALU要运算还需要由控制单元产生一个控制信号<ul><li>所以，控制单元输出一个控制信号，需要连接到ALU的控制端口，这样一来就可以从寄存器中读取出操作数，而且还可以做运算，运算以后的结果还可以输入到寄存器堆的数据端口</li><li>指令在执行的时候就有rs和rt这两个寄存器编号输入到Ra和Rb这两个地址端口，然后再从寄存器中读出两个数据，在ALU中做运算，运算的结果要写回到寄存器堆，所以它输入到寄存器堆的Data端口</li><li>另外还需要有一个目标地址，这个目标地址是来自于指令当中的第三个寄存器编号rd。所以rd跟寄存器堆的写入地址端口rw之间有一个连接线路。寄存器编号rd就作为目标地址输入到寄存器的rw端口。</li><li>要想把数据写入到寄存器堆，还需要由控制单元产生一个高电位的协时类信号，这个协时类信号是应该输入到wn端口，写模式控制端口，然后在时钟信号的驱动下，数据才能够真正地写入寄存器堆</li><li>这就是R型运算指令当中的add指令相应的数据通路，这个数据通路能够执行add运算，也能执行and运算<ul><li>and运算实际上也是需要读取rs，rt这两个寄存器当中的数据，然后在ALU当中做运算，运算结果写回到rd寄存器</li><li>所以add指令的数据通路可以支持and运算也可以支持或运算等四类R型运算指令，但是设计的这种数据通路不支持移位运算指令，因为移位运算指令当中还会使用到sa字段，这里的数据通路中没有sa字段的数据通路，所以不支持移位运算指令</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><pre><code>- &lt;img src="基于MIPS32指令集的CPU微架构设计/R.png" style="zoom:50%;" /&gt;</code></pre><h6 id="3-在R型上扩展I型运算指令"><a href="#3-在R型上扩展I型运算指令" class="headerlink" title="3.在R型上扩展I型运算指令"></a>3.在R型上扩展I型运算指令</h6><p>例子1：addi rt,rs,imm</p><ul><li><p>这条i型指令完成的操作</p><ul><li>首先就是要把16位的立即数imm进行扩展，扩展成32位</li><li>然后再跟rs寄存器当中的数据相加</li><li>相加以后的结果写入到rd寄存器</li><li>这就是它的基本操作</li></ul></li><li><p>为了直观一点，我们把他的指令格式写出来</p><ul><li><p><img src="/posts/33736/I.png" alt=""></p></li><li><p>总共有四个字段</p></li><li><p>数据通路图如下：</p><ul><li><p><img src="/posts/33736/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF1.jpg" alt=""></p></li><li><p>上面这个数据通路图是R型运算指令的数据通路图，我们就要分析怎么在这个数据通路上面扩展得到i型的运算指令的数据通路</p><ul><li>i型的运算指令涉及到一个把16位立即数进行扩展，扩展成32位的操作，上图的数据通路还不具备这个部件，因此，我们需要增加一个数据扩展的部件，把16位扩展到32位。</li><li>有了这个扩展部件之后，16位立即数可以通过这个扩展器扩展成32位，扩展后的结果还需要在ALU当中作一个运算，因此扩展器输出会连接到ALU的一个B端口</li><li>有了这样一个数据通路以后，指令当中的16位立即数就通过这个数据通路在扩展器中进行扩展，扩展成32位，然后再输入到ALU的B端口</li><li>指令当中的rs字段作为一个地址码输入到寄存器的ra当中，从寄存器当中读取出rs寄存器的数据也是输入到ALU当中，两者作一个运算，运算后的结果再作为数据输入到寄存器的data端口，数据在写入到寄存器堆的时候，目标地址是rt，所以还需要把指令当中输出的rt作为目标地址输入到rw，因此，rt这个数据通路上面跟rw之间还有一个连接，rt才能够作为目标地址输入到寄存器堆。<ul><li>目标地址确定以后，数据运算的结果也准备好，那么在wn为高电位的时候，在时钟信号的驱动之下，数据就能够真正地写入rt</li><li>这就是i型运算指令的数据通路<ul><li>这个数据通路是面向addi指令的，但它特同样能支持运行andi指令<ul><li>andi rt,rs,imm?</li><li>andi指令完成的功能同样是把16位立即数扩展，扩展成32位以后，再跟rs寄存器当中的数据相加，目前的数据通路已经能够支持这种操作，相加以后的结果仍然是要写回rt寄存器，现在的数据通路仍然接受这种把数据写回到rt寄存器的操作，所以这个数据通路能够支持andi指令，同样也能够支持ori指令和xori指令</li><li>这样我们就扩展得到了i型运算指令的数据通路，如下图：</li></ul></li></ul></li></ul></li></ul></li><li><img src="/posts/33736/i通路.png" style="zoom:50%;"></li></ul></li></ul></li></ul><h6 id="4-继续扩展i型访存指令"><a href="#4-继续扩展i型访存指令" class="headerlink" title="4.继续扩展i型访存指令"></a>4.继续扩展i型访存指令</h6><p>例：lw rt，imm（rs）</p><ul><li><p>lw指令，即取数指令</p></li><li><p>这条指令完成的操作是把16位立即数扩展成32位，再跟rs寄存器当中的数据相加，作为目标地址去访问存储器，从存储器中读取出一个数据，并且把这个数据写回rt寄存器当中</p><ul><li>这是取数指令的指令格式：</li><li><img src="/posts/33736/lw.png" alt=""></li><li>数据通路如下，使我们扩展后给到的一个数据通路</li><li><img src="/posts/33736/i%E5%9E%8B%E6%89%A9%E5%B1%95.png" alt=""></li><li>怎么样在这个数据通路知上扩展出i型的访存指令lw？<ul><li>同样是根据lw指令完成的功能操作才能够进一步进行扩展，指令在执行的时候需要把16位的立即数imm扩展成32位，目前的数据通路已经能够支持这种扩展操作，另外它还会涉及到一个读取rs寄存器数据的操作，目前的数据通路也已经能够支持这种读取rs寄存器的操作。根据目标地址访问存储器，读取存储器的这样一个操作，目前的数据通路当中还不具备这样的存储器部件，所以就需要增加一个数据存储器，这个数据存储器有两个控制信号，一个是写模式的控制信号，一个是读模式的控制信号，指令在执行过程当中根据指令当中的rs寄存器编号读取寄存器堆，读取出来的数据输入到ALU当中，另外再把16位的立即数进行扩展，扩展成32位，扩展以后的结果仍然是要输入到ALU当中，在ALU当中做一个加法，ALU当中相加的一个结果是一个目标地址，需要根据目标地址去访问数据存储器，所以ALU的输出需要跟数据存储器的地址端口有一个连接，alu输出的结果就作为目标地址输入到数据存储器的地址端口，数据存储器的输出端口rd当中输出一个存储数据，输出的这个数据是要写回到rt寄存器，因此它还需要连接到寄存器堆的data端口，所以RD和data端口有一个连接线路，把它们连接起来，然后数据从rd端口输出以后输入到寄存器的数据端口data。目标操作数要写入到寄存器堆，还需要一个目的地址，这个目的地址是由指令当中的rt来提供的，所以rt作为目标地址输入到寄存器堆的rw端口。当然寄存器堆的wn为高电平的时候，在时钟信号的驱动下，从数据存储器中读取到的数据就能够写入到寄存器堆当中的rt寄存器。</li><li>已经能够支持lw指令，但是它不支持存数指令sw，存数指令需要从rt寄存器当中读取出数据，读数据这个操作目前的数据通路已经能够支持，读取出数据以后这个数据要写入到数据存储器，这就要求寄存器堆的B端口和数据存储器的wd端口有一个连接线路，这个连接线路在目前的数据通路中还不具备，所以这个数据通路不支持存数指令sw</li><li>因此还需要进一步进行扩展</li></ul></li></ul></li></ul><p>例子2：sw rt,imm(rs)</p><ul><li>第二条指令：存储指令</li><li>这条指令完成的操作是把寄存器rt当中的数据读出来以后，写入到数据存储器，数据存储器当中的目标单元的地址码是通过寄存器基址寻址方式来产生，也就是把rs寄存器当中的地址码读出来以后，再把指令当中的16位立即数进行扩展，两者相加形成目标地址。</li><li>这是sw指令的指令格式：<ul><li><img src="/posts/33736/sw.png" alt=""></li><li>这个数据通路是扩展了lw指令后的数据通路，目前的数据通路已经能够支持R型的运算指令，i型的运算指令还有i型的取数指令。因此，就需要在这个数据通路基础之上，扩展得到sw的数据通路，存储指令在执行的时候，首先是把imm，也就是指令当中的16位立即数取出来以后进行扩展，扩展成32位以后输入到alu的B端口，然后再读取rs寄存器，这个数据是从A端口输出。这两个数据在alu当中做一个加法运算，产生目标地址，然后还需要根据指令当中的rt寄存器编号来读取寄存器堆，这个数据是从B端口输出，输出的这个数据需要写入到数据存储器，所以B端口和数据存储器的数据输入端口wd之间应该有一个连接线路，这里我们把它连接起来，读出来的数据才能够通过这个连接线路输入到数据存储器的wd端口。通过这种扩展，扩展得到的数据通路才能够支持sw指令</li></ul></li></ul><h6 id="5-扩展I型分支指令"><a href="#5-扩展I型分支指令" class="headerlink" title="5.扩展I型分支指令"></a>5.扩展I型分支指令</h6><p>i型的分支指令在目标指令当中有一条beq指令。即：beq，rs,rt,offset</p><ul><li><img src="/posts/33736/扩展i.png" style="zoom:50%;"></li><li><p>这条指令完成的操作主要就是根据rs和rt这两个寄存器当中的数据来进行判断，如果两者相等，那么就按照pc相对寻址方式来产生分支以后的目标地址，并且用目标地址去更新pc寄存器，如果两者不相等，那么就直接根据pc当前值，也就是pc+4，去更新pc寄存器，这时beq指令的格式：beq,rs,rt,offset总共四个字段</p></li><li><p>目前我们已经扩展得到这样一个数据通路，这个数据通路已经能够支持I型运算指令，R型运算指令以及I型访存指令，怎么样在这个数据通路之上扩展出能够支持i型分支指令的数据通路？</p><ul><li>我们同样是要分析它的功能操作。i型分支指令在决定是否分支的时候，是根据rs，rt这两个寄存器中保存的数据来进行判断的，这两个数据在alu当中做一个减法，如果相减的结果为0，那么就符合分支条件，如果相减的结果不为0，就不符合分支条件，相减的结果是否为0，主要就取决于ALU当中的标志位：zero,因此这个标志位就需要输入到控制单元，作为控制单元产生控制信号的一个依据，所以ALU输出的0标志位和控制单元之间应该增加一个数据通路，把他们两者之间连接起来。如果两个寄存器当中的数据相等，这时候还需要pc的相对寻址方式来产生分支的目标地址，在产生分支的目标地址过程当中，涉及到一个加法运算，数据通路中的ALU能够支持这种加法运算。也涉及到16位立即数扩展到32位的操作，数据通路中的扩展器也已经能够支持这种扩展操作，但是它还涉及到一个左移两位的操作，这个操作在目前的数据通路当中还不支持。因为在单周期cpu当中，alu不能够被共享，因此他还需要增加一个左移两位器和加法器，16位立即数进行扩展以后扩展成32位，再左移两位，所以扩展器的输出和左移两位器的输入之间应该有一个数据通路把两者连接起来，左移两位器的输出是要做加法运算产生分支的目标地址的，所以它还会输入到加法器，另外pc的当前值，也就是pc+4，是作为加法器的另一个输入，加法器输出的结果刚好是分支的目标地址，这个分支的目标地址是要去更新pc存储器，因此它跟pc寄存器的输入端应该有一个数据通路的连接，把他们连接起来。在以前的数据通路之上增加一个左移两位器，增加一个加法器，再把相关的部件连接起来，这样就能够支持i型的分支指令，这里可以进一步进行验证。首先是根据beq指令的rs和rt这两个寄存器编号字段，读取出两个操作数，这两个操作数在ALU当中做一个减法运算，产生一个运算结果。这个运算结果是没有用的，同时还会产生一个零标志位，零标志位作为控制单元的一个输入信号，如果零标志位为1，表明两个寄存器中的数据是相等的，这时候就需要进行分支，那么就需要通过pc相对寻址方式产生分支地址，所以指令当中的立即数字段进行扩展，扩展成32位以后再左移两位，输入到加法器，在加法器之中把左移两位的结果跟pc的当前值相加，就能够输出分支的目标地址，用这个分支的目标地址就可以更新pc寄存器。如果rs和rt两个寄存器当中的数据不相等，就不符合分支转移条件，因此就直接用pc+4来更新pc寄存器，这一步操作在取指令的数据通路中已经能够支持，所以在这里就没有必要再单独进行设计。</li></ul></li></ul><h6 id="6-最后扩展j型j指令"><a href="#6-最后扩展j型j指令" class="headerlink" title="6.最后扩展j型j指令"></a>6.最后扩展j型j指令</h6><ul><li>最后还需要扩展j型j指令</li><li>例子：j,address<ul><li>这一条指令完成的操作就是把指令当中的26位地址码左移两位后形成28位，再跟pc当前值的高四位进行拼接形成目标地址</li><li>这是j指令的一个指令格式：<ul><li><img src="/posts/33736/%E6%9C%80%E5%90%8Ej1.png" alt=""></li><li>只有两个字段：操作码和26位的地址码</li><li>目前我们已经扩展得到了这样一个数据通路：<ul><li><img src="/posts/33736/最后j2.png" style="zoom:50%;"></li><li>目前这个数据通路中能够支持r型、i型的运算指令，支持i型的访存和i型的分支指令，但是它还不支持j型的j指令。因为j型的j指令涉及到一个把26位的立即数左移两位的操作，目前的数据通路还不支持。另外还涉及到一个4位地址码和28位地址码拼接的操作，这个数据通路中也没有这样的功能部件，所以我们需要增加一个左移两位器，同时还需要增加一个拼接器，然后再把指令当中的26位地址码输入到这样一个左移两位器，左移两位以后就形成一个28位的地址码，这个28位的地址码是跟pc的当前值，也就是pc+4的一个高四位相拼接，拼接输出的结果就是转移指令的目标地址，这个目标地址也是要用来更新pc寄存器的，所以pc寄存器的输出要跟pc寄存器的输入端有一个数据通路的连接，把它们连接起来。经过这样扩展，这个数据通路就能够支持j型的j指令，这里我们也可以进行进一步的验证，首先是通过立即寻址方式，从指令当中截取最低26位的地址码，把这个地址码输入到左移两位器，进行左移两位操作。左移两位后就得到一个28位的地址码，再跟pc当前值的高四位相拼接，形成目标地址，用这个目标地址去更新pc寄存器，所以我们扩展到这一步，它已经能够支持j型的j指令。</li></ul></li></ul></li></ul></li></ul><p><strong>经过一步一步地扩展，我们得到的这个数据通路它就已经能够在硬件的 结构上支持11条目标指令</strong>。</p><ul><li>如果进一步对数据通路进行整合化简，就可以得到最终的单周期cpu：</li></ul><h5 id="数据通路重新布局："><a href="#数据通路重新布局：" class="headerlink" title="数据通路重新布局："></a>数据通路重新布局：</h5><p>这是重新布局以后的结果：</p><p><img src="/posts/33736/%E9%87%8D%E6%96%B0%E5%B8%83%E5%B1%80.png" alt=""></p><ul><li>第一部分就是取指令的数据通路，这个数据通路当中取出来的指令是一个32位的指令代码，加法器输出的结果是一个pc+4，在顺序执行的时候这个pc+4还要用来更新pc寄存器，所以它跟pc寄存器之间有一个数据通路的连接。第二部分就是R型和i型的运算指令和访存指令的数据通路，这里我们把他们连接起来。第三部分就是i型的分支指令beq，分支指令的数据通路中加法器产生的结果是要作为目标地址去更新pc寄存器，因此这里会有一个连接。第四部分就是j型的j指令，它通过拼接器产生跳转以后的目标地址，所以拼接器的输出也会连接到pc寄存器的输入端。在这个数据通路中，rs和rt都是指令当中的5位寄存器编号，rd也是另外一个5位的寄存器编号，imm是一个16位的立即数，address是一个26位的地址码，这个address只有在j指令当中会出现。</li><li>重新对数据通路进行布局之后我们可以看到，pc寄存器的输入端有三种途径，第一种途径就是来自于pc+4，第二种途径就是来自执行j指令的时候，来自于拼接器的输出。第三种情况就是在执行分支指令的时候，加法器的输出。另外寄存器堆的写入地址端口rw它的输入也有两种情况。第一种是来自于指令当中的rt，另外一种是来自于指令当中的rd。在执行不同的指令的时候，来源是不一样的。第三个地方就是alu的B端口的输入，她也有两个数据的输入来源。第一种情况是来自于寄存器的B端口。另外一种情况是来自于扩展器的输出。寄存器堆的数据输入端口wd它的数据来源也有两种情况：第一种情况是来自于alu运算后的结果输出，另外一种情况来自于数据存储器的输出端口rd。指令在执行的时候只能有一个唯一的确定的数据通路，所以我们还需要对这部分的数据通路进行一个整合和化简，才能够得到最终的数据通路。</li></ul><h5 id="数据通路整合"><a href="#数据通路整合" class="headerlink" title="数据通路整合"></a>数据通路整合</h5><ul><li>在设计单周期cpu的时候，通常不能够为各种指令设置单独的通路，原因有很多，比如r型、i型的运算指令都会使用到ALU，也都会涉及到与alu相关的数据通路，如果每一种指令都设置单独的数据通路，设计的结果：数据通路中就会有个ALU,以及多个ALU相关的数据通路。结果就会导致数据通路太繁杂，而且硬件的冗余度也会很大。这种方式显然不行，</li><li>所以就必须将各型指令的数据通路进行综合、化简<ul><li>通过综合、化简，才能够提高处理器的集成度。最重要的是，他还可以提高处理器的可靠性，数据通路进行优化以后，部件与部件之间的连接方式更加科学合理。因此，还能够方便控制器对它们进行控制。在对数据通路进行综合、进行化简的时候，目标就是要把各种指令的数据通路进行合并和优化，我们涉及到的数据通路有4种。第一种就是取指令。取指令的数据通路是所有指令共享的，它跟指令的具体操作是没有关系的，另外就是R型的运算指令相关的数据通路，还有就是i型运算指令、i型访存指令和分支指令的数据通路，还剩下就是j型j指令的数据通路。主要就有这四个部分的数据通路<ul><li><img src="/posts/33736/数据路径合并.png" style="zoom:50%;"></li><li>在进行综合化简的时候，我们采用的基本思路就是用一个多路选择器来整合冗余的数据通路。以下是一个多路选择器的示意图<ul><li><img src="/posts/33736/多路选择.png" style="zoom:50%;"></li><li>他有两个输入，一个输出，在控制器的控制信号作用之下，选择器就能够选中一路输入作为输出，而且输入不同的控制信号，还能够非常方便地在输入通路和输出之间进行切换。</li></ul></li></ul></li><li>如果我们继续对这样一个初始的数据通路进行整合，这样一个数据通路是经过一个一个整合得到的，他能够支持R型的运算指令，支持I型的运算、访存、分支指令，还能够支持j型的j指令。这个数据通路当中的pc寄存器它的输入端有3种数据来源。所以我们需要通过一个三选一的多路选择器对它们进行一个整合。这个多路选择器上面施加不同的控制信号，它就可以选中pc+4这一个通路，或者选中拼接器的输出，或者选中加法器的输出。对于寄存器堆rw写地址端口的输入，她也有两种。所以我们也可以通过这样一个二选一的多路选择器来对它们进行一个整合。在不同的控制信号作用之下，它就可以选中rt，也可以选中rd来作为寄存器堆的写入地址。对于ALU的B端口，它的输入途径有两种来源，第一种就是来自于寄存器堆的B端口，另外一个来源就是来自于扩展器的输出，所以我们也需要用一个二选一的多路选择器来整合这里的输入，在不同的控制信号作用之下，让它选中寄存器堆的B端口，或者选中扩展器的输出来作为alu的B端口的输入。对于寄存器堆的数据输入端口wd，她也有两种输入数据来源，第一种就是来自于alu的输出，另外一种就是来自于数据存储器的输出。所以这里也需要用一个二选一的多路选择器，来对他们进行一个整合。在不同的控制信号作用之下，就可以让多路选择器去选中alu的输出，或者选中数据存储器的输出，作为寄存器中的输入。所以初始的数据通路经过四个多路选择器的整合以后，我们就可以得到一个整合之后的完整的数据通路。这个数据通路就能够支持11条目标指令，包括R型的运算指令，I型的运算指令、访存指令、分支指令，以及J型的无条件跳转指令。</li><li><img src="/posts/33736/继续整合通路.png" style="zoom:50%;"></li></ul></li></ul><h3 id="3-5-3-控制系统设计"><a href="#3-5-3-控制系统设计" class="headerlink" title="3.5.3 控制系统设计"></a>3.5.3 控制系统设计</h3><h4 id="1-组合逻辑与微程序控制"><a href="#1-组合逻辑与微程序控制" class="headerlink" title="1.组合逻辑与微程序控制"></a>1.组合逻辑与微程序控制</h4><p>单周期微架构：</p><p><img src="/posts/33736/%E5%8D%95%E5%91%A8%E6%9C%9F1.jpg" alt=""></p><p>上图的数据通路是我们根据多次扩展得到的数据通路，这个数据通路从硬件的结构上已经能够支持r型的运算指令，I型的运算指令、访存指令、分支指令，j型的无条件跳转j指令，这个数据通路还不能支持R型的移位，数据通路当中也没有包括控制信号的通路。这个数据通路是一个静态的数据通路，他自己不能执行指令，必须要有相关的控制信号，在控制信号的控制之下，数据通路才能够执行完成指令。整个数据通路当中 有非常多的功能部件需要接收控制信号来控制它们，比如像pc寄存器，它的输入端有这样一个多路选择器，这个多路选择器在控制信号的作用之下，既可以选择pc+4，又可以拼接器的输出，还可以选择加法器的输出作为输入，去更新pc寄存器。往下面看，在寄存器堆的rw端口，输入地址也需要有一个控制信号，这里是一个二选一的多路选择器，在这个控制信号的作用之下，它既可以选择rt作为地址输入，也可以选中rd作为地址输入。关于寄存器堆，他也有一个控制信号，写模式写使能控制信号，这个控制信号为高电平为1的时候，寄存器堆才可以成为写模式，数据才可能写入寄存器堆。alu上面也需要有一个控制信号，在这个控制信号的作用之下，alu执行不同的运算操作，比如加法、减法、逻辑与、逻辑或等等。往下面，在alu的B端口，她也有一个二选一的多路选择器，这个多路选择器上面的控制信号能够控制多路选择器让我们选中寄存器堆的B端口，要么选中扩展器的输出作为输入数据输入到ALU的B端口。另外的数据存储器她也有两个控制信号，写模式的控制信号和读模式的控制信号。这两个控制信号分别控制数据存储器处于写模式、读模式等等。下面这个数据位扩展器也有一个控制信号，这个控制信号为1的时候，就能够使扩展器执行符号扩展，如果为0，就能够使扩展器执行零扩展。下面也有一个控制信号，这个控制信号也是控制一个二选一的多路选择器，在控制信号的作用之下，这个多路选择器可以选中alu，也可以选中数据存储器的输出端来作为寄存器堆的数据输入端口的数据。那么这些控制信号怎么样去控制？或者这些控制信号由谁产生？就必须要设置一个专门的控制器，控制器在恰当的时间产生正确的控制信号来控制这些部件，让这些部件协同配合一致，完成一条指令的执行。</p><h6 id="控制信号（微命令）产生部件"><a href="#控制信号（微命令）产生部件" class="headerlink" title="控制信号（微命令）产生部件"></a>控制信号（微命令）产生部件</h6><p>控制信号的产生部件，我们这里有一个示意图：</p><img src="/posts/33736/控制信号产生部件.png" style="zoom:50%;"><ul><li>这是一个控制单元的示意图，一个控制器，在我们mips32架构的单周期cpu当中，控制器会接收指令当中的高6位op字段，和最低的6位func功能说明字段，这两个作为输入。另外还需要接收时钟信号，如果是I型的分支指令，还需要接收从数据通路当中返回的零标志位，接收到这些控制信息以后，控制单元产生控制信号，比如产生RegWrite去控制寄存器堆的写模式，产生operation去控制ALU的运算操作等等。一个控制单元的输入和输出就是这样一个基本的逻辑情况。所以我们的目的就是要设计这样一个控制单元，让这个控制单元在接收到指令的操作码，接受到功能说明字段，接收到零标志位，而且在时钟信号的驱动之下，能够产生正确的控制信号。</li></ul><h6 id="怎样恰当地产生这些控制信号？"><a href="#怎样恰当地产生这些控制信号？" class="headerlink" title="怎样恰当地产生这些控制信号？"></a>怎样恰当地产生这些控制信号？</h6><ul><li>主要有两种方式</li><li>第一种产生控制信号的方式就是硬连线（hardwired）方式.这种方式是基于组合逻辑，因此相应的控制器也就可以被称为硬连线控制器或者组合逻辑控制器。另外一种方式是，微程序（micro-programmed）,这种控制方式是基于存储的。因此相应的控制器成为微程序控制器。这两种方式都能够产生控制信号，但是产生控制信号的基本原理和基本过程是完全不一样的。</li><li>第一种是组合逻辑控制的基本原理。它的核心还是一个组合逻辑电路，接收指令信息，指令信息经过译码以后，输入到组合逻辑电路，另外它还会接收时序信号，比如时钟编译信号的驱动、指令周期信号等等。还会接收内部的状态信号，比如在执行I型分支指令的时候，他就会去接收alu输出的一个零标志位。还会接受外部的控制状态信号，比如外部设备的中断请求等等。组合逻辑电路接收的这五部分的输入信息以后，就能够产生相应的微命令序列，也就是控制信号。这些微命令序列的产生完全基于一个组合逻辑电路，这就是组合逻辑控制方式。<ul><li><img src="/posts/33736/组合逻辑电路.png" style="zoom:50%;"></li></ul></li><li>第二种是微程序控制方式<ul><li>它的核心就是这样一个控制存储器，这个控制存储器当中保存了微程序，一条指令就对应到一道微程序，而一道微程序又是有若干条微指令构成的。所以在执行的时候，他就从控制存储器当中取出微指令，把微指令放入到微指令寄存器。微指令包括微操作控制字段和后续地址生成字段，所以他就会把微操作字段进行译码，译码以后就直接产生了微命令序列，产生了控制信号。因为它还会涉及到下一条微指令的取指执行，所以他还会根据微指令当中的顺序控制字段进一步去产生下一条指令的微地址，这是通过微地址形成电路来产生的。微地址形成电路也是一个组合逻辑电路，它接受到当前指令的顺序控制字段，而且还要接收到指令的信息，一些时序的信号。根据这些来产生下一条微指令的地址，并且把微指令的地址打入到微指令的pc寄存器，同时微指令的pc寄存器当中保存的下一条指令地址还会作为反馈输入到微地址形成电路，作为产生下一条微地址的一个基本的依据。这就是微程序控制的一个基本原理。它的核心还是这样一个控制存储器。控制存储器当中就保存了与指令相对应的一段微程序，这段微程序有若干个微指令构成，就是把指令执行过程中所需要的微命令通过编码的方式编码成微程序。在执行指令的时候，根据指令的操作类型找到这段微程序，把微指令的代码取出来，直接经过译码器翻译以后得到一个微命令序列。所以这种方式就跟组合逻辑控制方式是完全不一样的。微程序控制方式是依靠预先存储的微程序翻译为指令以后得到的微命令序列。</li><li><img src="/posts/33736/%E5%BE%AE%E7%A8%8B%E5%BA%8F.png" alt=""></li></ul></li></ul><h6 id="组合逻辑方式的特点："><a href="#组合逻辑方式的特点：" class="headerlink" title="组合逻辑方式的特点："></a>组合逻辑方式的特点：</h6><ul><li>控制信号的产生速度比微程序快。微程序控制方式需要去读取控制存储器，要对伪代码进行翻译，所以他的速度要相对慢一些。</li><li>第二个特点就是组合逻辑方式控制器的设计不规整。里面会涉及到若干个非常不规整的基本的门电路，电路结构也比较复杂</li><li>第三是不容易修改或者扩展。一旦要增加指令或者修改指令的时候，那么就需要去修改整个逻辑电路，牵一发而动全身，所以非常不容易修改。</li></ul><h6 id="微程序控制方式的特点："><a href="#微程序控制方式的特点：" class="headerlink" title="微程序控制方式的特点："></a>微程序控制方式的特点：</h6><ul><li>第一个特点是他用存储逻辑去代替了硬件逻辑，结构规整</li><li>第二个特点就是容易修改和扩展，灵活性很强，通用性也很强。因为一条指令对应到微程序，而且这段微程序是保存在控制存储器当中的，当要扩展指令、修改指令的时候，实际上也就只需要去修改控制存储器当中保存的微程序，这样就能够比较方便地去扩展指令、修改指令，外围电路基本可以保持不变。</li><li>第三个特点就是它的可靠性非常高，非常易于诊断和维护，因为它的核心是这一段微程序，所以我们可以通过软件的方式来测试来定于来诊断这段微程序，维护微程序的时候也是非常方便。</li><li>第四个特点是控制信号的产生比组合逻辑慢。因为它的控制信号产生是需要涉及到去读取数据存储器，读取存储器本身是一个比较慢的过程，读取存储器读取到微指令的时候还需要进一步地去翻译微指令，这些过程都比较慢。</li></ul><h5 id="2-控制信号整理与编码"><a href="#2-控制信号整理与编码" class="headerlink" title="2.控制信号整理与编码"></a>2.控制信号整理与编码</h5><h6 id="单周期微架构"><a href="#单周期微架构" class="headerlink" title="单周期微架构"></a>单周期微架构</h6><img src="/posts/33736/单周期微架构.png" style="zoom:50%;"><ul><li><p>这个数据通路是我们设计完成的mips32单周期cpu微架构</p><ul><li>在这个微架构当中，她有许多功能部件需要控制，比如四个多路选择器，alu的运算操作以及数据存储器的读写控制等等。她们都需要用控制器产生控制信号去控制他们，所以在设计控制信号之前，就必须要先分析所有的这些受控部件相关的控制信号，还要完成对他们的编码。这样才能进一步去设计控制器的逻辑。首先看多路选择器的编码，多路选择器有四个，对于pc输入端的3选1的多路选择器，因为他是三选一，所以它的控制信号的编码至少应该是两位。所以我们就可以分别用01,10,00来对这三位输入来进行编码，不同的控制信号就能够选中不同的通路，输入到pc寄存器。寄存器堆的写地址端口rw也有一个二选一的多路选择器，因为它是二选一的，所以他的控制编码就只需要一位，因此我们就可以用1，0来分别对应到rt和rd，不同的控制信号就能够让多路选择器选中rt，或者选中rd，alu的B端口也有一个二选一的多路选择器，所以对这个多路选择器的信号进行编码的时候，它也只需要一位。因此我们就把上面编码为0，下面编码为1，让0对应到寄存器堆的B端口，让1对应到扩展器的输出。寄存器堆的输入数据端口也有一个二选一的多路选择器。所以他的控制信号编码的时候，也只需要一位，用0来对应alu的输出，用1来对应数据存储器·的输出。通过这种简单的方式就完成对四个多路选择器的编码，编码完成以后，还需要对每一个控制信号进行命名。我们把pc寄存器输入端的三选一的多路选择器控制信号命名为PCSrc，当PCSrc为01的时候，他就选中加法器的输出，当其为10的时候，就选中拼接器的输出，当其为00的时候，就直接选中pc+4来作为pc寄存器的一个输入。寄存器堆的写地址端口rw对应的二选一的多路选择器的控制信号的命名为Regdst.当其为1的时候，他就选中rt来作为写地址，当其为0的时候，就选中rd来作为写地址。寄存器堆的写模式信号命名为Regwrite，当其为1的时候，寄存器堆就设置为写模式，当其为0的时候，寄存器堆处于读模式。ALU的B端口的二选一多路选择器的控制信号命名为aluSrc,当其为0的时候，就选中寄存器的B端口，当其为1的时候，就选中扩展器的输出来作为ALU的B端口的输入。ALU上面的控制信号，我们把它命名为operation，这个控制信号是一个四位的控制信号，不同的控制编码都能够控制alu作不同的运算，比如当控制编码为0010的时候，alu就能够做加法运算，数据存储器的两个读写控制信号我们分别命名为R和W，当R为1，W为0，数据存储器处于读模式，当R为0，W为1的时候，数据存储器就被设置为写模式。当R和W两者都为0的时候，数据存储器就处于禁用模式，不能够读也不能够写。扩展器的控制信号，我们把它命名为extend，当其为0的时候，表示扩展器执行零扩展，当其为1的时候，表示扩展器执行符号扩展。寄存器堆的输入数据端口wd对应的二选一的多路选择器，上面的控制信号我们命名为mem2reg,当其为0的时候，它就能够选择alu的输出，当其为1的时候，他就能够选中数据存储器的输出来作为寄存器堆的一个输入数据。通过这种方式我们就完成对数据通路当中所有的控制信号的编码和它的命名。命名以后，就可以根据这些控制信号的编码来设计控制器，在执行指令的时候，他一共需要9个控制信号，包括4个多路选择器和数据存储器的读写信号，包括alu的运算操作控制信号，还包括寄存器堆的一个写模式控制信号以及扩展器的扩展控制信号。总共有9个控制信号。所以我们在设计控制器的时候，就需要让控制器能够产生9个这样正确的控制信号，才能够控制指令的执行。</li></ul></li></ul><h6 id="各控制信号的定义"><a href="#各控制信号的定义" class="headerlink" title="各控制信号的定义"></a>各控制信号的定义</h6><p>这里，我们需要对所有的控制信号他们的编码和含义进行一个整理：</p><p>总共有9个控制信号，控制器需要输出9种这样不同的控制信号。</p><p><img src="/posts/33736/%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7.png" alt=""></p><ul><li>对于第一种控制信号：RegDst，它的含义就是当它为零的时候，选通rd端口，为1的时候，选通rt端口。</li><li>第二个控制信号RegWrite，当它为零的时候，就把寄存器堆设置为读模式，当他为1的时候，就把寄存器堆设置为写模式。</li><li>对于AluSrc,当这个控制信号为0的时候，就选通寄存器堆的输出端B，为1的时候就选通扩展器的输出</li><li>第四个控制信号PCSrc，这个控制信号是一个两位的控制信号，当这两位代码位00的时候，表明他是选中pc+4，为01的时候就选择分支地址，为10的时候就选择跳转地址。</li><li>数据存储器的两个控制信号：MemRead和MemWrite,当两者都为0的时候，存储器是禁用的，不能够输出也不能够读写。当MemRead为1的时候，就能够设置存储器处于读模式，当MemWrite为1的时候，数据存储器就被设置为写模式</li><li>下面一种控制信号：Mem2Reg，当这个控制信号为0的时候，就表示选通ALU的输出，当这个信号为1的时候，就选通存储器的输出。</li><li>下面一个控制信号：extend，当这个控制信号为0的时候，表明扩展器就执行零扩展，当extend为1的时候，就是执行符号扩展。</li><li>最后一个控制信号operation，这个控制信号是用来控制ALU的，他是一个4位的代码，不同的编码可以控制ALU做不同的运算。<ul><li>以上九种控制信号中，7个是一位的控制信号，2个是多位的控制信号，即PCSrc和operation。</li></ul></li></ul><p><strong>完成对所有控制信号的整理以后，下面就可以去设计控制器，让控制器在执行指令的时候能够在正确的时间输出正确的控制信号，来控制指令的执行。</strong></p><h4 id="3-两级控制模式总体方案"><a href="#3-两级控制模式总体方案" class="headerlink" title="3.两级控制模式总体方案"></a>3.两级控制模式总体方案</h4><h5 id="3-1-控制单元的总体结构"><a href="#3-1-控制单元的总体结构" class="headerlink" title="3.1 控制单元的总体结构"></a>3.1 控制单元的总体结构</h5><p>通过对控制信号的分析，我们已经知道，在执行1条目标指令的时候，需要有控制系统产生九种不同的控制信号。那么应该怎样去设计控制系统的总体结构呢？我们首先需要去分析一下控制单元的输入和输出情况。</p><ul><li>这是一个控制单元的框图，下面是一个控制通路的框图。<ul><li><img src="/posts/33736/控制单元结构.png" style="zoom:50%;"></li></ul></li><li>指令在执行的时候，从指令当中接收操作码，也就是指令的最高6位，如果是R型指令，还需要接收R型指令的功能说明字段，是指令当中的最低六位。如果执行的是i型的分支指令，那么它还需要接收从ALU返回的零标志位，控制单元接收到这三个输入信息以后，需要产生9种不同的控制信号。这些控制信号通过控制通路传输到数据通路当中的受控部件，让这些功能部件协同一致地工作，完成指令的执行。</li><li>在这9种控制信号当中，有7种控制信号是1位的，但是还有2种控制信号是多位的，比如operation这个控制信号，他是用来控制ALU的运算操作，她是一个4位的控制信号。另外还有一个PCSrc这样一个控制信号，它是用来控制pc输入端的三选一的多路选择器，他也是一个两位的控制信号。这两个就比较特殊。通过分析我们已经知道，控制系统产生的这9种控制信号中，operation和PCSrc比较特殊，operation是一个4位的控制信号，PCSrc是一个两位的控制信号，其他的7中控制信号都是一位的控制信号。所以对这两个多位的控制信号，PCSrc和operation在设计控制系统的时候需要进行特殊的考虑，单独进行设计，这样才能够简化控制系统的设计。</li><li>我们首先分析一下这两个多位的控制信号：对于PCSrc，因为它是用在控制pc输入端的三选一的多路选择器，可能的控制代码有00,01,10，在什么情况下，控制系统输出的PCSrc控制信号应该为00，01,10？这就要根据当前的指令是否是beq和j，beq指令比较特殊，它在执行的时候是否需要进行分支跳转还需要参考alu输出的零标志位。如果零标志位为1，那么就需要执行分支跳转，这时候就需要选中加法器的输出来作为pc寄存器的输入。因此，相应就需要有控制系统产生控制代码01，来控制这个三选一的多路选择器。如果执行的是j address这条无条件跳转指令，那么就应该让多路选择器选中拼接器的输出来作为pc寄存器的输入。这时候控制系统产生的控制信号就应该是10。只有这样才能够正确地选中pc寄存器的输入通路。对于operation这样一个4位的代码。要让ALU做不同操作，就应该让控制系统输出不同的operation代码，对于r型指令，因为r型指令所有的操作码全部都为0，所以在执行R型指令的时候，需要根据op字段还有功能说明字段，才能够确定alu做什么运算操作。因此，才有可能让控制系统产生相应的控制代码，去控制alu。对于i型指令，因为没有功能说明字段，只有op字段，根据op字段也能够确定alu做什么样的运算操作。因此对于i型指令，控制系统只需要根据op字段就能够知道产生什么样的控制信号operation去控制ALU。对于J指令，它是采用伪直接寻址方式产生跳转以后的目标地址，用目标地址去更新pc寄存器，在执行过程当中，涉及不到alu的运算操作，所以在执行j型指令的时候 ，控制系统不需要去控制alu，因此它也就没有必要去输出相应的控制信号operation。这是r型、i型、j型指令在执行的时候，控制系统输出的alu控制信号operation的三种不同的情况。</li><li>基于对7种一位控制信号或这两种多位控制信号的分析，我们很容易就想到这样一个思路：也就是采用分级的控制方案，具体而言就是让主控单元直接产生7个移位的简单控制信号，另外再让主控单元产生一些中间控制信号去控制二级控制器，也称为下级控制器，让下级控制器来直接产生两种复杂的控制信号PCSrc和operation。这就是一种分级控制方案。主控单元产生一部分简单控制信号，复杂的控制信号则由二级的控制器来产生。主控单元只需要去控制二级控制器。</li><li>基于这些分析我们就可以把我们的控制系统设计为这种两级控制模式：<ul><li><img src="/posts/33736/两级控制.png" style="zoom:50%;"></li><li>指令在执行的时候输入一个32位的指令代码，32位的指令代码当中op字段，也就是指令的高六位输入到主控单元之中，主控单元接收操作码然后直接产生7个一位的控制信号，用这7个一位的控制信号去控制数据通路当中的功能部件，这就是两级控制模式当中的第一级控制。另外还需要设计第二级控制，第二级控制它包括两个部件，第一个部件就是直接产生alu控制信号operation的这样一个alu控制器，这个控制器一方面要从主控单元接收一个中间控制信号，我们把它命名为aluop，另外如果是R型指令，它还需要接收从指令当中传输的第六位，也就是R型指令的功能说明字段。alu控制器接收这两个输入信息以后，产生一个4位的控制信号operation，用operation去控制alu的运算操作，另外还有一个专门的PCSrc控制器。这个控制器主要的作用就是产生PCSrc控制信号。这个控制信号是两位的，它用来控制一个三选一的多路选择器，这个控制器在产生控制信号的时候，要考虑当前的指令是否是I型的分支指令，如果是i型的分支指令，它产生的控制信号就应该是01，如果是J型的无条件跳转指令，它产生的控制信号就应该是10.如果指令是顺序执行，产生的应该是00.所以PCSrc控制器还需要从主控单元接收两个标志位。beq指令的标志位和j指令的标志位，另外还需要从控制通路中接收alu返回的零标志位。接受到这三个信息以后，才能够决定产生什么样的控制信号pcsrc，然后用这个控制信号去控制pc输入端的三选一的多路选择器。这就是我们设计的两级控制模式，第一级控制模式和第二级控制模式，主控单元产生7个一位的控制信号，再产生3个中间控制信号去控制二级控制器。由两个控制器去直接产生两种多位控制信号，在这种两级控制模式下，主控单元只需要接收指令的操作码，功能说明字段也只需要输入到alu控制器，零标志位也只输入到PSCrc控制器，因此，采用这种两级控制模式能够在一定程度上简化控制系统的设计。首先就是需要设计alu控制器，然后再设计pcsrc控制器，然后再对主控单元进行设计，所以在设计二级控制器之前，还需要把主控单元和二级控制器之间的接口定义清楚，在我们设计的这个方案当中，只有三个接口需要进行进一步的定义，分别是aluop,beq,j.实际上他们也是有主控单元产生的三个中间控制信号。那么怎么去定义这三个中间控制信号？怎么样对它们进行编码？以及编码的位数？我们还需要去进一步分析。</li></ul></li></ul><h5 id="3-2-设计ALU控制单元"><a href="#3-2-设计ALU控制单元" class="headerlink" title="3.2 设计ALU控制单元"></a>3.2 设计ALU控制单元</h5><p>在两级控制模式之下，怎样来单独对ALU控制器进行设计？这时候我们首先需要分析一下ALU控制器的输入和输出情况。这是一个alu控制器，下面是一个alu</p><ul><li><img src="/posts/33736/alu2.png" style="zoom:50%;"></li><li><p>alu控制器的作用就是产生一个控制信号来控制alu作不同的运算操作。从方案当中我们知道alu控制器在产生控制信号的时候，他会接收两个输入，第一个输入就是aluop，这个信号是由主控单元产生的。主控单元根据什么来产生？主控单元是根据指令当中的操作码来产生，所以我们也可以把alu看成是操作码的一个函数，主控单元就根据指令当中输入的操作码来产生aluop，这里的aluop是一个多位的中间控制信号，具体是多少位目前我们还不清楚，还必须要进一步去分析。控制器除了接收aluop以外，还会接收r型指令的功能说明字段，这个字段是一个6位的代码，控制器接收这两个输入以后，就会产生一个输出operation，这个控制信号是一个4位的控制信号。输出来以后就去控制alu，让alu做不同的运算</p></li><li><p>上面表格当中就表现了不同不同的运算控制代码跟alu完成的具体运算操作之间的对应关系。控制器输出的四位控制代码operation跟alu完成的具体运算操作之间是由一一对应关系的，比如要让alu完成一个逻辑与运算，那么就必须要让控制器输出一个4位的控制代码0000，如果需要让alu完成一个加法运算，那么就需要让控制器输出一个4位的控制代码0010，控制代码和运算操作之间就存在这种对应关系。从alu控制器的输入和输出关系图，我们也可以看到他会接收两个输入产生一个输出，而且这两个输入都是多位的，输出的控制信号也都是4位的，从这一点看，alu的控制逻辑非常复杂，到目前为止它所需要的其中一个控制信号aluop的编码情况我们还不清楚。所以在进行设计的时候，就必须要对它进行重点的关注，才能够完成alu控制器的设计。</p></li><li><p>alu<strong>控制器的输出依赖于？</strong></p><ul><li>我们可以进一步去分析alu控制器产生的输出operation到底跟哪些因素有关？</li><li>这里是一个alu控制器的输入输出关系图。从图上看，控制器接收两个输入：aluop和功能说明字段func，然后产生一个输出，这个输出是4位的。其中的一个输入aluop是由主控单元产生的，主控单元根据指令当中的操作码产生。因此，alu控制器产生的输出控制信号就跟指令的类型有关系，也就是跟指令的操作码有关系。除此之外，它还跟功能说明字段func有关系，当然这个功能说明字段仅仅是r型指令当中才会有，其他类型的指令不管是i型j型都没有。从alu控制器的输入输出关系，我们还可以看到，指令当中的功能说明字段只输入到alu控制器，没有输入到主控单元，也没有输入到其他控制部件。所以，功能说明字段只影响alu控制器输出的operation控制码，不会影响其他控制信号的输出。他跟其他控制信号之间是没有关系的。</li><li>根据前面的这些分析，我们比较容易想到这样一些设计思路：<ul><li>在alu控制器的设计过程当中，因为我们必须要知道aluop的译码情况，所以首先就需要根据目标指令涉及到的alu运算操作，把aluop的编码情况明确，把它定义好。定义之后，功能说明字段的编码应该是明确的，所以我们就可以根据alu控制器的输入输出情况，整理得到输入输出关系的真值表。有了这个真值表以后，那么我们就可以最后把这个真值表当中的代码位进行转换，转换以后就能够得到operation这四位控制信号，每一位都要产生逻辑，最终才能够设计出alu控制器的最终的组合逻辑。</li></ul></li></ul></li></ul><p><strong>在两级控制方案下，aluop是alu控制器的一个必须的输入，所以为了设计alu控制器，就必须对aluop进行编码</strong></p><ul><li><p>所以我们首先分析一下11条目标指令的功能情况。</p></li><li><img src="/posts/33736/指令1.png" style="zoom:50%;"></li><li><p>首先第一种类型是i型指令，有6条，分别是取数、存数、分支、立即数加、立即数与、立即数或，所有的i型指令都没有功能说明字段。对于lw指令，他完成的操作是通过基址寻址方式把rs寄存器当中保存的数据跟16位立即数符号扩展成32位以后的结果相加，相加以后产生主存单元的目标地址。所以这时候需要让alu做一个加法运算，因此也就需要让alu控制器输出一个4位的控制代码0010。对于第二条指令存数指令，它同样是通过基址寻址方式把rs寄存器当中保存的数据跟16位立即数符号扩展成32位以后再相加，通过这种方式产生主存单元的目标地址，所以这时候需要让alu做一个加法运算，因此也需要让alu控制器输出一个4位的控制代码0010。对于第三条指令beq，这是一条分支指令，这条指令在执行的时候需要把rs和rt两个寄存器当中的数据相减，再通过相减以后的结果是否为0来判断是否更符合分支条件。所以这时候就要求alu做一个减法运算，相应也就需要有控制器输出一个4位的控制代码0110.第四条指令立即数加addi，这条指令完成的操作是把rs寄存器当中的数据跟16位立即数扩展成32位以后再相加，所以这时候alu要完成一个加法运算，相应也就需要控制器输出一个4位的控制代码0010.对于第五条指令andi指令，这条指令完成的操作是把rs寄存器当中的数据取出来以后跟16位立即数做零扩展以后扩展成为32位，两者再做一个逻辑与运算，所以在这种情况下，alu完成的是一个逻辑与运算。相应也就需要由控制器输出一个4位的控制代码0000。最后一条i型指令ori，这条指令完成的操作是把rs寄存器当中的数据取出来以后跟16位立即数零扩展为32位以后，在做一个或运算。</p></li><li><p>另外还有4条R型指令。这四条指令的操作码全部为0，所以就增加了一个功能说明字段，在其中，高三位全部为100，低三位相互不同。add完成加法运算，sub完成的是个减法操作，因此也就需要让控制器输出一个4位控制代码0110.对于and指令，它是做逻辑与运算，因此需要让控制器输出一个4位控制代码0000.or完成的操作是做一个或运算，因此她需要让alu控制器输出一个四位的控制代码0001.</p></li><li><p>另外还有一条j型指令。这条指令当中没有功能说明字段，而且在执行的时候通过伪直接寻址方式产生跳转以后的目标地址。不会使用到ALU。</p></li></ul><h5 id="3-3-ALU控制器的真值表"><a href="#3-3-ALU控制器的真值表" class="headerlink" title="3.3 ALU控制器的真值表"></a>3.3 ALU控制器的真值表</h5><p>完成对aluop的编码以后，就可以进一步整理ALU控制器的真值表。</p><ul><li>这时ALU控制器的两个输入一个输出在11条目标指令当中，指令j与ALU是没有关系的，只有10条指令跟ALU有关系。我们就根据这10条指令来整理ALU控制器的输入输出关系真值表。</li><li>在整理真值表的时候，必须要忽略无关项，控制器的线路才可以得到简化，首先看他的输入，ALU控制器有两种输入，第一种输入就是aluop，它是一个3位的控制代码，第二种输入就是功能说明字段，是一个6位的控制代码。对于R型指令，它有四种不同的aluop编码，分别是010,110,000,001，R型指令只有一种编码，全部为100，总共就是5种aluop编码。对于这5种aluop编码，必须要先取出他们中的无关项：<ul><li>先看第一种编码010，此编码中假设我们把最低位0去除，那么就还剩下最高的两位01，在这五种编码当中没有其他任何一种编码最高的两位是01，控制器只根据输入的aluop的最高的两位，如果最高两位为01，那么它也可以断定当前是要让alu做一个加法运算，也不会跟其他的四种编码发生任何冲突。因此在第一种编码010当中，最低位的0就是一个无关项，应该把它去除，用同样的方法我们也可以标记出其他几种编码当中的无关项。</li><li>ALU控制器的另外一个输入是功能说明字段，I型指令当中没有功能说明字段，所以这六位全部都是无关项，我们用X来表示，R型指令当中每一条指令都有功能说明字段，这四条R型指令的功能说明字段最高位全部都为100，低三位相互不同，所以根据aluop的有效编码为10以及功能说明字段的低三位我们同样可以确定当前的ALU执行什么样的操作，所以这四条指令对应的功能说明字段中，高三位100全部都为无关项，这里我们也需要把它去除。这就是ALU控制器的两种输入。那么他的输出情况呢？它的输出有四位，当输入的aluop编码为01的时候，这时候实际上是要让alu做一个加法运算，所以alu控制器当前的预期输出operation就是0010.当aluop的最高两位为11的时候，这时候实际上是要让ALU做一个减法运算，因此预期的输出就是0110,。当aluop的三位代码全部为0的时候，这时候是要让ALU做一个逻辑与运算，因此预期的输出就是0000.当aluop最低位为1的时候，这时候实际上是要求ALU做一个或运算，因此预期的输出就是0001，这是在执行i型指令的时候的四种情况。在执行R型指令的时候，输入的aluop为10，当功能说明字段的最低三位为000的时候，表明是在做加法运算，因此预期的输出是0010，当功能说明字段的最低三位为010的时候，当前是在做减法运算，因此预期的输出就是0110.当功能说明字段最低三位为100的时候，需要让ALU做逻辑与运算，因此输出就应该是0000.当功能说明字段最低三位为101的时候，就意味着要让ALU做一个或运算，所以相应的预期输出就应该是0001.这样就完成ALU控制器输入输出关系的真值表的整理。怎样根据真值表得到每一位的产生逻辑？先分析控制器输出的operation代码当中的第三位，第三位全部都为0，这就意味着不管在什么情况下，operation的最高位也就是第三位永远都不会为1，始终为0.operation的第二位代码中有两个1，这就意味着当aluop为11的时候，第二位代码它会输出为1，另外，当aluop为10而且功能说明字段的最低三位为010的时候，operation的第二位代码也会为1，这样就可以把它转换成一个逻辑表达式。控制器输出的operation代码当中的第一位有4个一，当ALUOP为01或者ALUOP为11，以及aluop为10，而且功能说明字段的最低三位分别为000和010的时候，控制器输出的第一位代码为1，控制器输出的最低位代码中只有两个1，这就意味着当aluop的最低位为1，或者aluop为10，功能说明字段为101的时候，operation的最低位都会为1，根据对ALU控制器输出的四位控制代码当中的每一位为1的情况进行分析以后，就可以分别写出每一位的产生逻辑。</li><li><img src="/posts/33736/真值表.png" style="zoom:50%;"></li></ul></li></ul><h5 id="3-4-ALU控制器-输出逻辑"><a href="#3-4-ALU控制器-输出逻辑" class="headerlink" title="3.4 ALU控制器-输出逻辑"></a>3.4 ALU控制器-输出逻辑</h5><img src="/posts/33736/逻辑式.png" style="zoom:50%;"><p>整理完成ALU控制器的真值表之后，根据输入和输出之间的对应关系，就可以写出每一位输出的控制信号与输入条件之间的对应关系的逻辑表达式。alu控制器输出的是一个4位的控制信号operation,每一位控制信号都对应一个逻辑表达式，总共就可以写出4个逻辑表达式。控制器输出的最高位operation3，这意味在任何情况下都不会为1，始终等于0.也就意味着这一位的控制信号始终保持为低电平，控制器输出的第二位控制信号operation2在两种条件下会等于1，第一种条件就是输入的alu最高两位分别为11,的时候，另外一个条件就是当输入的aluop的最高两位分别为10，而且功能说明字段的最低三位分别为010的时候，这两种条件下，operation2都是等于1的。控制器输出的第三位控制信号operation1在四种条件下会等于1，当输入的aluop的最高两位分别为01，或者为11的时候，以及aluop的最高两位分别为10而且功能说明字段的最高三位分别为000或者为010的时候，这四种条件下operation1都是输出为1的，输出为高电平。控制器输出的第四位控制信号operation0在两种条件下会等于1，第一种条件就是输入的aluop的最低位为1的时候，另外一种条件就是当输入的aluop的最高两位分别为10，而且功能说明字段分别为1，0,1的时候，这两种条件下，operation0都是等于1输出为高电平。</p><p>写出ALU控制器输出的四位控制信号每一位的产生逻辑表达式以后，就可以直接用硬件描述语言来仿真这种逻辑关系，同样也可以把这些逻辑关系表达式通过总的转换以后得到alu控制器的组合逻辑电路。在转换的过程当中，需要把逻辑表达式当中所有的加号都转换成逻辑的或门。把所有的乘号都转换为逻辑与门，表达式当中的乘号我们都是用小圆点来表示的。转换以后就可以得到一个初步的组成逻辑电路，在把逻辑电路经过集成经过综合经过化简就可以得到完整的ALU控制器的组合逻辑。</p><p>下面的图使我们转换以后得到的最终结果，这个组合逻辑有两组输入，第一组输入就是输入三位的aluop，另外还有一组输入就是输入的功能说明字段最低三位，因为功能说明字段的最高三位是无关项，所以在组合逻辑中就不会使用。输入的这两组信号经过组合逻辑电路以后，最终就会输出用于控制ALU工作的operation这样一个4位的控制信号，alu控制器的组合逻辑由9个与门和4个或门构成，结构还是相对比较简单的。那么怎么知道设计的结构是正确的呢？我们可以进一步进行验证：</p><ul><li><img src="/posts/33736/逻辑式2.png" style="zoom:50%;"></li><li>​    假设当前有一个输入aluop3位代码分别是100，输入的功能说明字段的最低三位分别为000，我们验证一下在组合逻辑电路端它会输出什么样的operation这四位控制信号？aluop的三位分别为100，把他标记出来，功能说明字段地最低三位分别为000，第一个与门a1，他有两个输入，一个输入为0另外一个输入也是0，所以与门a1输出的结果也是0。与门a2有两个输入，一个输入为0，另外一个输入为1，所以与门a2输出的结果也是0。与门a3也有两个输入，一个是0变反以后的结果，另外一个是1.所以与门a3输出的值为1,。与门a4有三个输入，中间的一个输入为0，所以与门a4输出也就为0.与门a5有三个输入，这三个输入都是把0变反以后，再输入到a5当中的。所以与门a5的输出结果就是1。a6的三个输入当中，有两个输入都为0，所以与门a6也输出为0。a7的一个输入为0，所以a7也就输出为0。或门o1有两个输入，一个输入是0，另外一个输入是1，所以或门o1输出为1，a8也有两个输入，一个输入为1，另外一个输入为0，所以a8输出的结果就是0。a9的两个输入都为1，所以a9也就输出为1,。operation3固定输出为0，operation2对应的或门o2的输入当中两个都为0.所以o2输出也为零。o3也是一个或门，它其中的一个输入是1，所以o3就输出为1，或门o4两个输入都为0.所以，o4也输出为0.这样就得到组合逻辑电路输出的4位代码就是0010，如果用其他的编码和功能说明字段去验证这个组合逻辑电路，验证的结果也都是正确的，都符合真值表当中列举的各种情况。这就说明我们设计的alu控制系统的组合逻辑电路是正确的，能够满足alu控制器产生控制信号的需求。这样一来，我们就完成了整个alu控制器的设计。</li></ul><h5 id="3-5-PCRsc控制器"><a href="#3-5-PCRsc控制器" class="headerlink" title="3.5 PCRsc控制器"></a>3.5 PCRsc控制器</h5><img src="/posts/33736/两级.png" style="zoom:50%;"><ul><li>单周期cpu的控制系统采用两级译码模式，第一级和第二级</li><li>第二级由两个二级控制器构成，分别是alu控制器和pcsrc控制器。ALU控制器是用来控制alu，pcsrc控制器是用来控制一个pc输入端的三选一的多路选择器。现在alu控制器已经设计完成，下一步就是要继续设计pcsrc控制器的组合逻辑。</li><li>这个图是pcsrc控制器的输入和输出关系图。</li><li><img src="/posts/33736/pc2.png" style="zoom:50%;"></li><li>在这个图当中我们看到，pcsrc会接收三个输入，一个是从alu返回的零标志位，另外的两个输入是主控单元产生的beq_flag标志和j_flag标志。接受到这三个输入以后，产生一个两位的输出控制信号PCSrc.用这个控制信号去控制pc寄存器输入端的三选一的多路选择器，pcsrc控制器比较特殊，执行beq指令的时候，如果符合分支转移条件，多路选择器就应该选中加法器的输出来作为pc寄存器的输入。在执行j指令的时候，多路选择器应该选中拼接器的输出来作为pc寄存器的输入。注意在执行11条目标指令的过程当中，对于pcsrc的控制器它特别需要关注beq指令和j指令，因此我们这里就对方案进行一个分析。假设在执行beq指令的时候，主控单元输出的beq_flag等于1，为高电平。这就表明当前是正在执行beq指令。执行j指令的时候，让主控单元输出的j_flag=1，为高电平，这也就标志着当前正在执行j指令。执行其他指令的时候，让主控单元输出的beq_flag和j_flag这两个标志位都为0都保持为低电平的输出。pcsrc控制器接收到的beq_flag等于1的时候，他还需要去根据零标志位来进一步判断当前是否符合分支转移条件，从而决定产生什么样的pcsrc控制信号输出。当它接收到的j_flag标志等于1的时候，他就直接根据这个标志位去决定当前应该输出什么样的pcsrc让多路选择器选中拼接器的输出来作为pc寄存器的输入。</li><li>基于这样一些分析我们就能够整理出pcsrc控制器的“输入-输出”关系对应的真值表：<ul><li>这个表中表明了两种指令，另外还表示出了pcsrc控制器接收到的三个输入分别是beq_flag,j_flag和zero零标志位。另外还会产生两个输出pcsrc1和pcsrc0，这是一个两位的pcsrc控制信号。</li><li>当执行beq指令的时候，这时候主控单元输出的两个标志位应该为1，表明当前正在执行beq指令，j_flag标志跟beq指令无关，只对应j指令，所以不需要考虑。当zero为0的时候不符合分支转移条件，三选一的多路选择器应该选中pc+4来作为pc寄存器的输入。因此，对应的pcsrc控制信号分别应该是00.当返回的零标志位为1，beq指令符合分支转移条件，三选一的多路选择器应该选中加法器的输出来作为pc寄存器的输入。在这种情况下，就应该让pcsrc寄存器输出两位的控制信号01，这样才能让多路选择器选中加法器的输出作为pc寄存器的输入。当执行j指令的时候，beq_flag这个标志跟j指令无关，j_flag标志为1，表明当前正在执行j指令。这时候的零标志位也是跟j指令没有关系的。因为j指令执行的是无条件跳转，它通过伪直接寻址方式来产生跳转到目标地址，因此在这时三选一的多路选择器就应该选中拼接器的输出来作为pc寄存器的输入。这就要求pcsrc控制器输出一个为10的控制信号。</li></ul></li></ul><p>根据逻辑，我们也可以画出它的组合逻辑电路：</p><ul><li>pcsrc1是直接跟j_flag标志位联通，中间没有经过任何逻辑处理。beq_flag和零标志位作为一个与门的两个输入，与门输出的结果就是PCSrc[0],相对于alu控制器，这个pcsrc控制器的组合逻辑相对非常简单。这样我们就完成了pcsrc控制器的组合逻辑设计。</li></ul><h5 id="3-6-主控单元-真值表"><a href="#3-6-主控单元-真值表" class="headerlink" title="3.6 主控单元-真值表"></a>3.6 主控单元-真值表</h5><img src="/posts/33736/两级3.png" style="zoom:50%;"><p>单周期cpu的控制系统采用两级控制模式，在这个两级控制模式当中，主控单元控制二级控制器，pcsrc和alu，然后主控单元还会接收一个从指令当中传输过来的6位操作码，根据操作码产生7个一位的控制信号。现在pcsrc控制器和alu控制器已经设计完成，下一步就是要设计主控单元的组合逻辑。</p><h6 id="主控单元的设计"><a href="#主控单元的设计" class="headerlink" title="主控单元的设计"></a>主控单元的设计</h6><img src="/posts/33736/主控1.png" style="zoom:50%;"><p>一下是主控单元的示意图，其只接受从指令当中传输过来的6位操作码op字段，另外他还会产生7个一位控制信号，这7个一位的控制信号都是直接控制信号，直接用来控制数据通路当中的功能部件。他们都是一位的。除此之外还会产生3个进阶控制信号aluop和beq_flag,和j_flag.aluop是用来控制alu控制器的，beq_flag和j_flag是用来控制pcsrc控制器的。aluop是一个三位的控制信号，beq_flag和j_flag是一位的控制信号。所以从输入输出的角度可以看到，主控单元会根据1个输入，输入一个op字段操作码，总共会产生10个输出。在这10个输出当中，有9个1位的控制信号，另外还包括1个三位的控制信号。所以我们就可以根据它的输入和输出的对应关系整理出主控单元的输入输出真值表。有了真值表以后，我们就可以写出每一个控制信息的产生逻辑，从而完成主控单元的组合逻辑设计。</p><h6 id="主控单元的“输入-输出”真值表"><a href="#主控单元的“输入-输出”真值表" class="headerlink" title="主控单元的“输入-输出”真值表"></a>主控单元的“输入-输出”真值表</h6><img src="/posts/33736/真.png" style="zoom:50%;"><p>以上为主控单元输入-输出的真值表。</p><ul><li>输入只有一个，就是指令的操作码字段op，总共有6位，主控单元的输出包括七个直接控制信号，而且这七个信号都是一位的。其中这个Regdst是用来控制寄存器堆写地址端口的二选一的多路选择器。ALUSrc是用来控制ALU的B端口的二选一的多路选择器。Mem2Reg是控制寄存器堆的写模式，    MemWrite和 MemRead是用来控制数据存储器的读写模式   extend是用来控制扩展器的零扩展或者符号扩展。除此之外主控单元还输出三个控制信号aluop，beq_flag和j_flag</li><li>总共的目标指令有11条，其中的R型有4条，i型有6条，还有J型指令1条。先看R型指令，R型指令的6位操作码全部都为0，在执行R型这四条运算指令的时候，需要把rs和rt这两个寄存器当中的数据取出来以后做运算，运算以后的结果保存到rd寄存器。所以寄存器堆写地址端口的二选一的多路选择器就应该选中rd数据通路。因此，所需要的RegDst控制信号就应该全为0.在做运算的时候，ALU的B端口是要选中从寄存器堆B端口输出的数据，对应的二选一的多路选择器就应该选中寄存器堆的B端口。在这种情况下，相应的控制信号alusrc就应该为0.运算以后的数据是要写入寄存器堆，因此，寄存器堆的写数据端口就应该选中alu的输出。所以对应的二选一多路选择器上的控制信号mem2reg就需要为0.运算以后需要把结果写回到寄存器堆，所以寄存器堆就应该被设置为写模式。相应的控制信号regwrite就应该为1。R型运算指令在运算的过程当中不会使用到数据存储器，所以数据存储器的两个读写模式控制端口memwrite和memread全部为0.这四条指令没有涉及到立即数的扩展，所以extend为x。</li></ul><h6 id="写出各输出信号的逻辑式"><a href="#写出各输出信号的逻辑式" class="headerlink" title="写出各输出信号的逻辑式"></a>写出各输出信号的逻辑式</h6><p><strong>得到主控单元输入输出真值表之后，通过分析输出信号在等于1的时候所对应的输入条件，就可以写出每一位控制信号产生的对应逻辑</strong></p><p>主控单元总共会输出10种一共12位控制信号，每一个控制信号对应一个产生逻辑。这样就可以写出12个产生逻辑。这是这个Regdst的产生逻辑。它由四项相加以后得出。第一项表达式的含义就是当输入的操作码的第三位第二位和第一位分别为100的时候，其输出为1。</p><p>分别写出这12个控制信号的产生逻辑，就可以通过硬件描述语言来进行仿真，也可以把这些逻辑表达式进行转换，转换以后就可以得到主控单元的组合逻辑。把这些组合逻辑经过合并化简，就可以得到主控单元的组合逻辑设计。</p><p>如下为主控单元的组合逻辑电路图。</p><img src="/posts/33736/主控2.png" style="zoom:50%;"><ul><li>这个图就是把12个逻辑表达式经过合并化简以后转换的电路图，这个电路图接收6位输入，刚好就是输入指令的6位操作码。然后会从电路当中输出10种一共12位控制信号。它的核心还是一组译码器。通过译码器对指令的操作进行译码，就能够指导当前执行的是什么指令，然后再通过一组或门来确定当前输出的12位控制信号等于0还是等于1，输出为低电平还是为高电平。从电路的结构来看，组合逻辑电路并不复杂，主控单元的组合路基非常简单，这是因为我们的目标指令只有11条，而且采用两级控制模式，已经极大的简化了控制系统。</li></ul><p><strong>完成单周期cpu的数据通路和控制系统的设计以后，把两者整合到一起，就能够得到完整的单周期cpu微架构</strong></p><h3 id="3-5-4-单周期cpu"><a href="#3-5-4-单周期cpu" class="headerlink" title="3.5.4 单周期cpu"></a>3.5.4 单周期cpu</h3><p>指令的最高6位，也就是操作码字段连接到控制系统。指令的最低六位也就是功能说明字段也连接到控制系统，数据通路当中alu返回的零标志位也连接到控制系统，这样一来，在时钟信号的驱动之下，控制系统就能够产生9种不同的控制信号，把这九种控制信号连接到数据通路当中的受控部件，就能够控制这些受控部件协调一致地工作，一起配合完成指令的执行。这就是我们设计得到的单周期cpu的硬件结构，它包括数据通路部分和控制系统。把数据通路和控制系统整合在一起以后，就得到单周期cpu的完整硬件结构。它就能够支持11条目标指令的执行。这就是单周期cpu设计的最终的结果。</p><img src="/posts/33736/单周期1.png" style="zoom:50%;"><h4 id="指令的时间特性"><a href="#指令的时间特性" class="headerlink" title="指令的时间特性"></a>指令的时间特性</h4><p>单周期cpu设计完成以后，怎么确定每一个时钟周期的宽度？</p><p>因为每一条指令都需要在一个时钟周期内完成，所以时钟周期的宽度就是一个非常重要的因素。怎么确定一个时钟周期具体要多少时间？</p><ul><li>我们首先需要分析每一条指令的实际执行时间，假设每个部件的硬件延时，也就是执行运算操作或者读写操作所需要时间，单位:每皮秒为10的-12次方</li><li>存储器的读写操作假设是200ps，寄存器堆的读写操作是100ps，ALU和加法器运算所需要的时间是150ps，拼接器完成拼接操作产生跳转的目标地址所需要的时间是50ps，其他功能部件，比如控制器，忽略不计，为0ps。有了这样一些基本的假设以后，我们就可以进一步分析MIPS32单周期cpu的一些时间特性</li></ul><h5 id="1-mips32单周期cpu分析："><a href="#1-mips32单周期cpu分析：" class="headerlink" title="1.mips32单周期cpu分析："></a>1.mips32单周期cpu分析：</h5><p>所有这些时间特性都是基于我们前面设计的能够支持11条目标指令的单周期处理器。因为我们设计的单周期处理器能够支持I型，R型，J型一共11条目标指令，所以我们在确定时钟周期的时候，就必须要分析这11条指令直接的执行时间。</p><p>下面是我们设计完成的数据通路：</p><img src="/posts/33736/数据通路3.png" style="zoom:50%;"><ul><li>我们先看第一条指令 add rd,rs,rt<ul><li>这是一条R型的运算指令，他完成的基本操作是把rs和rt这两个寄存器当中的数据从寄存器堆当中读出来，然后在ALU当中做一个加法，把运算的结果写回到rd寄存器。指令在执行的时候首先是取指令，从pc寄存器输出指令的地址码，然后根据这个地址码去读取指令存储器。在读取指令存储器的过程中，pc会自动加4，需要的时间是150ps，这两步的操作是并行的。读取指令存储器所需要的时间是200ps，pc+4只要150ps，所以我们要计算指令的最长时间是要以下面读取指令存储器的时间为准：200ps。指令读取出来以后对指令进行译码，产生ra地址、rb地址，和写入地址rw，下一步就是根据这个地址去读取两个操作数，读取寄存器堆的时间是100ps，所以在加上一个100，这两个数在alu当中做一个加法运算，所需要的时间是150ps，所以再加上150.运算的结果还需要写回rd寄存器，这个寄存器是在寄存器堆当中，所以这里还会有一个把数据写入到寄存器堆的操作。他所需要的时间是100ps，因此还要加上一个100。这四个时间相加的结果就是550ps。这就意味着在执行i的指令的时候，他所需要的实际的时间是550ps。因为pc自动加4这个操作所需要的时间是150ps，但是它跟读取指令存储器是并行执行的。所以我们要以最长的时间，也就是关键路径的时间为准。pc回路只是一个非关键路径，所以我们就不需要考虑。只需要考虑读取指令存储器，读取寄存器堆，alu运算以及把结果写回到寄存器堆这样4个操作的时间。</li></ul></li></ul><p>第二个就是i型指令的：</p><img src="/posts/33736/i1.png" style="zoom:50%;"><ul><li><p>第二条指令lw rt,imm(rs)</p><ul><li>这条指令完成的操作首先就是根据寄存器基址寻址方式来产生主存的目标地址，也就意味着需要把16位立即数扩展成32位以后，再跟rs当中的寄存器相加，相加以后的结果作为主存的目标地址去读取数据存储器当中的数据。并把读取到的数据保存到rt寄存器。指令在执行的时候首先也是取指令，取指令的同时pc寄存器自动加4，我们要以最长的时间为准，所以只考虑读取指令存储器的时间。这个时间是200ps。指令读取出来以后进行译码，产生两个地址，一个是基址寄存器的地址，一个是写入寄存器堆的地址rw。同时把16位立即数进行带符号的扩展，输入到ALU的B端口，rs输入到寄存器堆的ra端口以后，就可以从寄存器堆当中读取出一个数据。这个数据的读取时间是10ps。这两个数据准备好了以后在ALU当中做一个加法运算，相加所需要的时间是150ps。相加以后的结果是作为目标地址去访问存储器的，因此就从存储器当中读取出一个数据，读取出数据的时间是200ps。相加的结果最后要写回rt寄存器，写入到寄存器堆的时候时间是100ps。将这五项相加的结果就是750ps。在读取指令存储器的时候，pc自动加4这个回路是一个非关键路径，所以不用考虑。</li></ul></li></ul><p>  <strong>通过同样的方法我们发现，；</strong></p><ul><li>用同样方法我们可以得到如下时间：<ul><li><img src="/posts/33736/如下时间.png" style="zoom:50%;"></li><li>R型的运算指令和I型的运算指令两者所需要的时间都是550ps</li><li>I型的取数指令所需要的总时间是750ps</li><li>I型的存数指令总时间是650ps，包括读取指令存储器、读取寄存器堆、alu做运算，以及把数据写入数据存储器所需要的时间</li><li>i型的分支指令总时间是450ps</li><li>j型的j指令所需要的时间是250ps，包括读取指令所需要的200ps和拼接器产生跳转的目标地址所需要的时间为50ps</li></ul></li><li>由以上可见，LW指令耗时最长，达到750ps<ul><li>因为是单周期cpu，所以每一条指令都必须要在一个时钟周期内完成，因此时钟周期的宽度就应该以最长的指令时间为准：即750ps</li><li>所以确定的时钟周期宽度也应该是750ps</li><li>只有当时钟周期的宽度为750ps的时候，才能够确保每一条指令在一个时钟周期内才能够执行完成。</li></ul></li><li>时钟周期确定以后用1来除以时钟周期的宽度即750ps，得到cpu主频约等于1.33GHZ</li></ul><h5 id="单周期cpu特性总结"><a href="#单周期cpu特性总结" class="headerlink" title="单周期cpu特性总结"></a>单周期cpu特性总结</h5><p>最后我们总结一下单周期cpu的特性：</p><p>单周期cpu具备的第一个特性：指令周期与时钟周期等长，而且宽度比较大</p><p>因为是单周期cpu，就要求每一条指令必须要在一个时钟周期内完成。所以他的指令周期刚好跟时钟周期等长，是一对一的关系。</p><p>第二个特性：处理器的cpi等于1，因为cpi指的是每执行一条指令所分配的时钟周期数，单周期cpu每一条指令只分配一个时钟周期，所以cpi恒等于1</p><p>第三个特点：在指令周期当中，各种硬件资源均被相应的功能操作所独占，不能被共享，所以硬件的利用效率很低。我们在设计的数据通路当中，pc+4要做一个加法，我们专门给它设计了一个加法器，其他的运算操作是根据专用的alu来执行，我们并没有用ALU来实现pc+4的操作，因为在单周期当中，这两个部件不能够被共享，这就导致硬件的利用效率低。</p><p>第四个特点，所有指令不管实际执行时间长短，都分配较长的时钟周期，会造成时间浪费严重。因为是单周期cpu，每条指令都要固定分配一个时钟周期，那么有的指令执行的时间比较长，有的较短，但不管执行时间长短都分配一个时钟周期，导致时间浪费。</p><p>单周期cpu通常对简单的一些小规模的指令集支持比较好，所以就要求指令集当中的指令功能非常简单，确保他能够在一个时钟周期内完成，而且指令的数量也不能太大，否则单周期cpu就不能够支持。对于一些功能比较复杂的运算指令，比如浮点的加法运算，浮点的乘法运算等等，分析指令的功能十分复杂，很难确保这些复杂指令能够在一个时钟周期内完成。</p><h3 id="3-5-5"><a href="#3-5-5" class="headerlink" title="3.5.5"></a>3.5.5</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道-计组-第一章</title>
      <link href="/posts/37002.html"/>
      <url>/posts/37002.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><p>知识框架:</p><ul><li>1.1 计算机发展历程<ul><li>硬件的发展</li><li>软件的发展</li><li>计算机分类与发展方向</li></ul></li><li>1.2 计算机系统层次结构<ul><li>计算机系统的组成</li><li>计算机硬件的组成</li><li>计算机软件的分类</li><li>计算机工作过程</li><li>计算机系统的多级层次结构</li></ul></li><li>1.3 计算机性能指标<ul><li>计算机的主要性能指标</li><li>几个专业术语</li></ul></li></ul><h2 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h2><h3 id="1-1-1-计算机硬件的发展"><a href="#1-1-1-计算机硬件的发展" class="headerlink" title="1.1.1 计算机硬件的发展"></a>1.1.1 计算机硬件的发展</h3><h4 id="计算机的四代变化"><a href="#计算机的四代变化" class="headerlink" title="计算机的四代变化"></a>计算机的四代变化</h4><ul><li>从1946年，世界第一台电子数字计算机ENIAC问世起（Electronic Numerical Integrator And Computer）</li><li>计算机发展已四代</li></ul><h5 id="第一代计算机："><a href="#第一代计算机：" class="headerlink" title="第一代计算机："></a>第一代计算机：</h5><ul><li>1946-1957 电子管时代</li><li>逻辑元件：<ul><li>电子管</li></ul></li><li>编程语言：<ul><li>机器语言</li></ul></li><li>主存：<ul><li>用延迟线、磁鼓存储信息</li></ul></li><li>特点：<ul><li>容量极小，体积庞大</li><li>成本高</li></ul></li><li>运算速度:<ul><li>较低，一般只有几千次到几万次每秒</li></ul></li><li>操作系统：<ul><li>尚无</li></ul></li></ul><h5 id="第二代计算机："><a href="#第二代计算机：" class="headerlink" title="第二代计算机："></a>第二代计算机：</h5><ul><li>1958-1964  晶体管时代</li><li>逻辑元件：<ul><li>晶体管</li></ul></li><li>编程语言：<ul><li>高级语言。eg：FORTRAN</li></ul></li><li>主存：<ul><li>磁心存储器</li></ul></li><li>运算速度:<ul><li>提高至几万次到几十万次每秒</li></ul></li><li>操作系统：<ul><li>有了操作系统的雏形</li></ul></li></ul><h5 id="第三代计算机："><a href="#第三代计算机：" class="headerlink" title="第三代计算机："></a>第三代计算机：</h5><ul><li>1965-1971年  中小规模集成电路时代</li><li>逻辑元件：<ul><li>中小规模集成电路</li></ul></li><li>存储器：<ul><li>半导体存储器</li></ul></li><li>编程语言：<ul><li>高级语言发展迅速</li></ul></li><li>操作系统：<ul><li>进一步发展</li><li>有了分时操作系统</li></ul></li></ul><h5 id="第四代计算机"><a href="#第四代计算机" class="headerlink" title="第四代计算机"></a>第四代计算机</h5><ul><li>1972年至今  超大规模集成电路时代</li><li>逻辑元件：<ul><li>大规模集成电路和超大规模集成电路</li></ul></li><li>产生微处理器</li><li>并行、流水线、高速缓存和虚拟存储器等概念出现</li></ul><h4 id="计算机元件的更新换代"><a href="#计算机元件的更新换代" class="headerlink" title="计算机元件的更新换代"></a>计算机元件的更新换代</h4><ol><li>摩尔定律<ul><li>价格不变时，集成电路上可容纳的晶体管数量<ul><li>约每隔18个月便增加一倍</li><li>性能也将提高一倍</li></ul></li><li>这一定律揭示信息技术进步的速度</li></ul></li><li>半导体存储器的发展<ul><li>1970年仙童半导体公司生产出第一个较大容量的半导体存储器</li><li>至今，半导体存储器经历11代<ul><li>单芯片1KB,4KB,16KB,64KB,256KB</li><li>1MB,4MB,16MB,256MB</li><li>1GB</li></ul></li></ul></li><li>微处理器的发展<ul><li>1971年Intel公司开发第一个微处理器Intel 4004</li><li>至今经历：<ul><li>Intel 8008 (8),Intel 8080 (8),Intel 8086(16),Intel80286(32位)，Intel80386(32)</li><li>Pentium(32位)，Pentium pro(64位)，Pentium II(64位)，Pentium III(64位)，Pentium 4(64位·)</li><li>（这里的位数指的是机器字长：计算机进行一次整数运算所能处理的二进制数据的位数）</li></ul></li></ul></li></ol><h3 id="1-1-2-计算机软件的发展"><a href="#1-1-2-计算机软件的发展" class="headerlink" title="1.1.2 计算机软件的发展"></a>1.1.2 计算机软件的发展</h3><ul><li>高级语言的发展真正促进了软件的发展<ul><li>科学计算和工程计算的FORTRAN</li><li>结构化程序设计的PASCAL</li><li>面向对象的C++</li><li>适应网络环境的Java</li></ul></li><li>直接影响计算机系统性能提升的各种系统软件也有了长足发展<ul><li>特别是操作系统</li><li>eg：Windows,UNIX,Linux</li></ul></li></ul><h3 id="1-1-3-计算机的分类与发展方向"><a href="#1-1-3-计算机的分类与发展方向" class="headerlink" title="1.1.3 计算机的分类与发展方向"></a>1.1.3 计算机的分类与发展方向</h3><h4 id="电子计算机："><a href="#电子计算机：" class="headerlink" title="电子计算机："></a>电子计算机：</h4><ul><li>电子模拟计算机</li><li>电子数字计算机</li></ul><h4 id="数字计算机："><a href="#数字计算机：" class="headerlink" title="数字计算机："></a>数字计算机：</h4><ul><li>按用途分为：<ul><li>专用计算机</li><li>通用计算机</li></ul></li><li>这是根据计算机效率、速度、价格、运行的经济性、适应性来划分的</li></ul><h5 id="通用计算机："><a href="#通用计算机：" class="headerlink" title="通用计算机："></a>通用计算机：</h5><ul><li>分为：巨型机，大型机，中型机，小型机，微型机，单片机 六类</li><li>它们体积、功耗、性能、数据存储量、指令系统复杂程度、价格依次递减</li></ul><h4 id="计算机按指令和数据流分为"><a href="#计算机按指令和数据流分为" class="headerlink" title="计算机按指令和数据流分为:"></a>计算机按指令和数据流分为:</h4><ol><li>单指令流和单数据流系统<ul><li>SISD</li><li>即传统冯诺依曼体系结构</li></ul></li><li>单数据流和多数据流系统<ul><li>阵列处理器和向量处理器系统</li></ul></li><li>多指令流和单数据流系统<ul><li>这种计算机实际上不存在</li></ul></li><li>多指令流和多数据流系统<ul><li>包括多处理器和多计算机系统</li></ul></li></ol><h4 id="计算机发展趋势"><a href="#计算机发展趋势" class="headerlink" title="计算机发展趋势"></a>计算机发展趋势</h4><ul><li>向两极分化<ul><li>一极是 微型计算机向更微型化、网络化、高性能、多用途方向发展</li><li>另一极 向更巨型化，超高速，并行处理，智能化方向发展</li></ul></li></ul><h2 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h2><h3 id="1-2-1-计算机系统的组成"><a href="#1-2-1-计算机系统的组成" class="headerlink" title="1.2.1 计算机系统的组成"></a>1.2.1 计算机系统的组成</h3><h4 id="完整的计算机系统："><a href="#完整的计算机系统：" class="headerlink" title="完整的计算机系统："></a>完整的计算机系统：</h4><ul><li>由硬件系统与软件系统共同构成</li></ul><h4 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h4><ul><li>是指有形的物理设备</li><li>是计算机系统中实际物理装置的总称</li></ul><h4 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h4><ul><li>是指在硬件上运行的程序和相关的数据及文档</li></ul><h4 id="软、硬件在逻辑上等效："><a href="#软、硬件在逻辑上等效：" class="headerlink" title="软、硬件在逻辑上等效："></a>软、硬件在逻辑上等效：</h4><ul><li>计算机系统性能好坏，很大程度由软件效率、作用来表征<ul><li>而软件性能的发挥离不开硬件支持</li></ul></li><li>对于某一功能来说<ul><li>其既可以用软件实现，又可以用硬件实现</li><li>则称软硬件在逻辑上等效</li></ul></li></ul><h4 id="软硬件功能分配："><a href="#软硬件功能分配：" class="headerlink" title="软硬件功能分配："></a>软硬件功能分配：</h4><ul><li>一个功能若使用频繁，且用硬件实现的成本较理想<ul><li>则用硬件解决可提高效率</li><li>用软件实现<ul><li>可提高灵活性</li><li>但效率没有用硬件高</li></ul></li></ul></li></ul><h3 id="1-2-2-计算机硬件的基本组成"><a href="#1-2-2-计算机硬件的基本组成" class="headerlink" title="1.2.2 计算机硬件的基本组成"></a>1.2.2 计算机硬件的基本组成</h3><h4 id="早期的冯诺依曼机"><a href="#早期的冯诺依曼机" class="headerlink" title="早期的冯诺依曼机"></a>早期的冯诺依曼机</h4><ul><li>冯诺依曼在研究EDVAC机时提出“存储程序”概念<ul><li>以此概念为基础的各类计算机被称为：冯诺依曼机</li></ul></li><li>“存储程序”概念：<ul><li>特点：<ol><li>计算机硬件系统由运算器、存储器、控制器、输入设备、输出设备5大部件组成</li><li>指令和数据以同等地位存储在存储器中，并按地址寻访</li><li>指令和数据均用二进制代码表示</li><li>指令由操作码、地址码组成<ul><li>操作码：用于表示操作的性质</li><li>地址码：用来表示操作数在存储器中的位置</li></ul></li><li>指令在存储器内按顺序存放<ul><li>通常，指令是顺序执行的</li><li>但在特定条件下可根据运算结果或设定的条件改变执行顺序</li></ul></li><li>早期的冯诺依曼机以运算器为中心，输入、输出设备通过运算器与存储器传送数据</li></ol></li><li>意义：<ul><li>奠定了现代计算机的基本结构</li></ul></li><li>定义：<ul><li>指将指令以代码的形式事先输入计算机的主存储器</li><li>然后按其在存储器中的首地址执行程序的第一条指令</li><li>以后就按该程序的规定顺序执行其他指令</li><li>直至程序执行结束</li></ul></li></ul></li><li>典型的冯诺依曼计算机结构：<ul><li><img src="/posts/37002/冯诺依曼.png" alt="冯诺依曼" style="zoom:50%;"></li></ul></li></ul><h4 id="现代计算机的组织结构"><a href="#现代计算机的组织结构" class="headerlink" title="现代计算机的组织结构"></a>现代计算机的组织结构</h4><h5 id="以运算器为中心的结构"><a href="#以运算器为中心的结构" class="headerlink" title="以运算器为中心的结构"></a>以运算器为中心的结构</h5><ul><li>原因：<ul><li>微处理器面世前，运算器与控制器分离</li><li>存储器容量很小</li><li>因此设计为运算器为中心<ul><li>其他部件都通过运算器完成信息传递</li></ul></li></ul></li><li>缺点:<ul><li>随着微电子技术的进步<ul><li>同时计算机需要处理、加工的信息量也与日俱增</li><li>大量I/O设备的速度与CPU速度差距悬殊</li></ul></li><li>因此以运算器为中心的结构 不能满足计算机发展的要求<ul><li>从而产生 以存储器为中心的结构</li></ul></li></ul></li></ul><h5 id="以存储器为中心的结构"><a href="#以存储器为中心的结构" class="headerlink" title="以存储器为中心的结构"></a>以存储器为中心的结构</h5><ul><li>优点：<ul><li>使I/O操作尽可能绕过CPU</li><li>直接在I/O设备和存储器之间完成</li><li>以提高系统的整体运行效率</li></ul></li><li>以存储器为中心的计算机结构：<ul><li><img src="/posts/37002/存储器为中心.png" style="zoom:50%;"></li></ul></li></ul><h4 id="计算机的功能部件"><a href="#计算机的功能部件" class="headerlink" title="计算机的功能部件"></a>计算机的功能部件</h4><ul><li>传统冯诺依曼计算机与现代计算机结构 功能部件一致</li><li>包括：<ul><li>输入设备</li><li>输出设备</li><li>存储器</li><li>运算器</li><li>控制器</li></ul></li></ul><h5 id="输入设备："><a href="#输入设备：" class="headerlink" title="输入设备："></a>输入设备：</h5><ul><li>主要功能：<ul><li>将程序和数据</li><li>以机器所能识别和接受的信息形式 输入计算机</li></ul></li><li>eg：<ul><li>键盘（最常用最基本）、鼠标、扫描仪、摄像机</li></ul></li></ul><h5 id="输出设备："><a href="#输出设备：" class="headerlink" title="输出设备："></a>输出设备：</h5><ul><li>功能：<ul><li>将计算机处理的结果<ul><li>以人们所能接受的形式</li><li>或其他系统所要求的信息形式输出</li></ul></li></ul></li><li>eg：<ul><li>最常用最基本：显示器、打印机</li></ul></li></ul><h5 id="计算机输入输出设备（I-O设备）"><a href="#计算机输入输出设备（I-O设备）" class="headerlink" title="计算机输入输出设备（I/O设备）"></a>计算机输入输出设备（I/O设备）</h5><ul><li>是计算机与外界联系的桥梁</li><li>是计算机中不可缺少的重要部分</li></ul><h5 id="存储器："><a href="#存储器：" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>功能<ul><li>是计算机的存储部件</li><li>用来存放程序和数据</li></ul></li><li>分类：<ul><li>主存储器<ul><li>也称：主存，内存储器</li><li>是CPU能直接访问的存储器</li></ul></li><li>辅助存储器<ul><li>也称：辅存，外存储器</li><li>用于帮助主存储器记忆更多的信息<ul><li>辅助存储器的信息必须调入主存之后，才能被CPU所访问</li></ul></li></ul></li></ul></li></ul><h6 id="主存储器："><a href="#主存储器：" class="headerlink" title="主存储器："></a>主存储器：</h6><ul><li>组成方式：<ul><li>由许多存储单元组成<ul><li>每个存储单元包含若干存储元件<ul><li>每个存储元件存储一位二进制代码”0”或“1’’</li></ul></li><li>存储单元可存储一串二进制代码<ul><li>这串代码称为  <strong>存储字</strong></li><li>这串代码的 <strong>位数</strong> 为 <strong>存储字长</strong><ul><li>存储字长可以是1B（8bit）或是字节的偶数倍</li></ul></li></ul></li></ul></li></ul></li><li>工作方式：<ul><li>按存储单元的地址进行存取<ul><li>即：<strong>按地址存取方式</strong></li><li>扩展：<strong>相联</strong> 存储器 是按 <strong>内容</strong> 访问的</li></ul></li></ul></li><li>最基本组成：<ul><li>主存储器逻辑图：<ul><li><img src="/posts/37002/主存储器逻辑图.png" style="zoom:50%;"></li></ul></li><li>存储体：<ul><li>存放二进制信息</li></ul></li><li>地址寄存器MAR：<ul><li>存放访存地址</li><li>经过地址译码后找到所选的存储单元</li><li>作用：寻址，其位数对应存储单元的个数<ul><li>eg：MAR有10位，则有2^10=1024个存储单元，记为：1K</li></ul></li><li>长度：与PC的长度相等</li></ul></li><li>数据寄存器MDR:<ul><li>用于暂存要从存储器中读或写的信息</li><li>位数：<ul><li>与存储字长相等</li><li>一般为字节的二次幂的整数倍</li></ul></li><li>注意：<ul><li>MDR与MAR虽然是存储器一部分，但在现代CPU中却存在于CPU之中</li></ul></li></ul></li><li>时序控制逻辑：<ul><li>用于产生存储器操作所需的各种时序信号</li></ul></li></ul></li></ul><h5 id="运算器："><a href="#运算器：" class="headerlink" title="运算器："></a>运算器：</h5><ul><li>功能：<ul><li>是计算机的执行部件</li><li>用于进行算术运算和逻辑运算<ul><li>算术运算：<ul><li>按算术运算规则进行的运算</li><li>eg：加减乘除</li></ul></li><li>逻辑运算：<ul><li>包括与、或、非、异或、比较、移位等运算</li></ul></li></ul></li></ul></li><li>核心：<ul><li>算术逻辑单元ALU Arithmetic and Logical Unit</li></ul></li><li>包含：<ul><li>若干通用寄存器<ul><li>作用：<ul><li>暂存操作数和中间结果</li></ul></li><li>eg：<ul><li>累加器ACC</li><li>乘商寄存器MQ</li><li>操作数寄存器X</li><li>变址寄存器BR等等</li><li>（前三个寄存器必须有）</li></ul></li></ul></li><li>程序状态寄存器PSW<ul><li>也称 标志寄存器</li><li>用于存放ALU运算得到的一些标志信息或处理机的状态信息</li><li>eg：<ul><li>结果是否溢出</li><li>有无产生进位或错位</li><li>结果是否为负</li></ul></li></ul></li></ul></li></ul><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><ul><li>功能：<ul><li>是计算机的指挥中心</li><li>由其指挥各部件自动协调地进行工作</li></ul></li><li>包括：<ul><li>程序计数器PC<ul><li>作用：存放当前欲执行指令的地址</li><li>可以自动加一，以形成下一条指令的地址</li><li>与主存的MAR之间有一条直接通路</li></ul></li><li>指令寄存器IR<ul><li>作用：存放当前的指令</li><li>其内容来自：主存的MDR</li><li>指令中的操作啊OP(IR)送至CU<ul><li>用以分析指令并发出各种微操作命令序列</li></ul></li><li>地址码Ad(IR)送往MAR<ul><li>用以取操作数</li></ul></li></ul></li><li>控制单元CU</li></ul></li></ul><h6 id="cpu："><a href="#cpu：" class="headerlink" title="cpu："></a>cpu：</h6><ul><li>将运算器与控制器集成到同一芯片</li><li>称为中央处理器CPU</li></ul><h6 id="主机："><a href="#主机：" class="headerlink" title="主机："></a>主机：</h6><ul><li>包含：<ul><li>cpu</li><li>主存储器</li></ul></li></ul><h6 id="外部设备："><a href="#外部设备：" class="headerlink" title="外部设备："></a>外部设备：</h6><ul><li>简称：外设</li><li>除主机外的其他硬件装置（外存、I/O设备等）统称外部设备</li></ul><h5 id="冯诺依曼结构的模型机"><a href="#冯诺依曼结构的模型机" class="headerlink" title="冯诺依曼结构的模型机"></a>冯诺依曼结构的模型机</h5><ul><li>cpu包含：<ul><li>ALU</li><li>通用寄存器组GPRs</li><li>标志寄存器</li><li>控制器</li><li>指令寄存器IR</li><li>程序计数器PC</li><li>存储器地址寄存器MAR</li><li>存储器数据寄存器MDR</li></ul></li><li>结构图：<ul><li><img src="/posts/37002/冯诺依曼模型机.png" style="zoom:50%;"></li><li>从控制器送出的虚线：<strong>控制信号</strong><ul><li>可以控制修改PC以得到下一条指令的地址</li><li>可以控制ALU执行什么运算</li><li>可以控制主存是进行读操作还是写操作（读/写控制信号）</li></ul></li><li>CPU与主存之间通过一条 <strong>总线</strong> 相连<ul><li>总线中有：<ul><li>地址、控制、数据 三条信号线</li></ul></li><li>MAR中地址信息 会直接送到地址线上<ul><li>用于指向读/写操作的主存存储单元</li></ul></li><li>控制线中有读/写信号线<ul><li>指出数据<ul><li>是从CPU写入主存</li><li>还是从主存读出到CPU</li></ul></li><li>根据是读操作还是写操作来控制将MDR中的数据<ul><li>是直接送到数据线上</li><li>还是将数据线上的数据接收到MDR中</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="1-2-3-计算机软件的分类"><a href="#1-2-3-计算机软件的分类" class="headerlink" title="1.2.3 计算机软件的分类"></a>1.2.3 计算机软件的分类</h3><h4 id="系统软件和应用软件"><a href="#系统软件和应用软件" class="headerlink" title="系统软件和应用软件"></a>系统软件和应用软件</h4><ul><li>软件按功能分类，分为：<ul><li>系统软件</li><li>应用软件</li></ul></li></ul><h5 id="系统软件："><a href="#系统软件：" class="headerlink" title="系统软件："></a>系统软件：</h5><ul><li>定义：<ul><li>是一组保证计算机系统高效、正确运行的基础软件</li></ul></li><li>作用：<ul><li>通常作为系统资源提供给用户使用</li></ul></li><li>eg：<ul><li>操作系统 OS</li><li>数据库管理系统 DBMS</li><li>语言处理程序</li><li>分布式软件系统</li><li>网络软件系统</li><li>标准库程序</li><li>服务性程序</li></ul></li></ul><h5 id="应用软件："><a href="#应用软件：" class="headerlink" title="应用软件："></a>应用软件：</h5><ul><li>定义：<ul><li>是指用户为解决某个应用领域中的各类问题而编制的程序</li></ul></li><li>eg：<ul><li>各种科学计算类程序</li><li>工程设计类程序</li><li>数据统计与处理程序等</li></ul></li></ul><h5 id="数据库管理系统DBMS与数据系统DBS"><a href="#数据库管理系统DBMS与数据系统DBS" class="headerlink" title="数据库管理系统DBMS与数据系统DBS"></a>数据库管理系统DBMS与数据系统DBS</h5><ul><li><p>是有区别的</p></li><li><p>DMBS：</p><ul><li>是位于用户和操作系统之间的一层数据管理软件</li><li>是系统软件</li></ul></li><li><p>DBS:</p><ul><li><p>是指计算机系统中引入数据库后的系统</p></li><li><p>一般包括：</p><ul><li><p>数据库</p></li><li><p>数据库管理系统</p></li><li><p>数据库管理员DBA</p></li><li><p>应用系统</p></li></ul></li></ul></li></ul><h4 id="三个级别的语言"><a href="#三个级别的语言" class="headerlink" title="三个级别的语言"></a>三个级别的语言</h4><ul><li>机器语言</li><li>汇编语言</li><li>高级语言</li></ul><h5 id="机器语言："><a href="#机器语言：" class="headerlink" title="机器语言："></a>机器语言：</h5><ul><li>又称：二进制代码语言</li><li>需要编程人员记忆每条指令的二进制编码</li><li>是计算机唯一可以直接识别和执行的语言</li></ul><h5 id="汇编语言："><a href="#汇编语言：" class="headerlink" title="汇编语言："></a>汇编语言：</h5><ul><li>用英文单词或其缩写代替二进制的指令代码<ul><li>更容易记忆与理解</li></ul></li><li>使用此语言编辑的程序<ul><li>必须经过一个称为 <strong>汇编程序</strong>的系统软件的翻译</li><li>将其转换为计算机的机器语言后</li><li>才能在计算机的硬件系统上执行</li></ul></li></ul><h5 id="高级语言："><a href="#高级语言：" class="headerlink" title="高级语言："></a>高级语言：</h5><ul><li>是为方便程序设计人员<ul><li>写出解决问题的处理方案和解题过程的程序</li></ul></li><li>通常高级语言需要经过 <strong>编译程序</strong> 编译成 <strong>汇编语言程序</strong><ul><li>然后经过 <strong>汇编操作</strong>得到机器语言程序</li><li>或直接由 <strong>高级</strong> 语言程序翻译成 <strong>机器</strong> 语言程序</li></ul></li></ul><h3 id="1-2-4-计算机的工作过程"><a href="#1-2-4-计算机的工作过程" class="headerlink" title="1.2.4 计算机的工作过程"></a>1.2.4 计算机的工作过程</h3><ul><li>分为三步骤：<ul><li>把程序和数据 装入 主存储器</li><li>将 源程序 转换成 可执行文件</li><li>从 可执行文件的首地址 开始逐条执行指令</li></ul></li></ul><h4 id="从源程序到可执行文件"><a href="#从源程序到可执行文件" class="headerlink" title="从源程序到可执行文件"></a>从源程序到可执行文件</h4><ul><li>计算机中编写的C语言程序<ul><li>必须被转换成一系列的 <strong>低级机器指令</strong></li><li>这些指令 按照一种称为：<strong>可执行目标文件的格式</strong> 打包</li><li>并以 <strong>二进制磁盘文件</strong>的形式存放</li></ul></li></ul><h5 id="实例：UNIX系统中GCC编译器程序"><a href="#实例：UNIX系统中GCC编译器程序" class="headerlink" title="实例：UNIX系统中GCC编译器程序"></a>实例：UNIX系统中GCC编译器程序</h5><ul><li>读取源程序文件hello.c</li><li>并翻译成一个可执行目标文件hello</li><li>整个翻译过程可分为四个阶段完成：<ul><li>预处理阶段</li><li>编译阶段</li><li>汇编阶段</li><li>链接阶段</li></ul></li><li>过程：<ul><li><img src="/posts/37002/源程序转换过程.png" style="zoom:50%;"></li></ul></li></ul><h6 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h6><ul><li>预处理器CPP<ul><li>对源程序中以字符#开头的命令进行处理</li><li>eg：<ul><li>将#include命令后面的.h文件内容插入程序文件</li><li>输出结果：是一个以.i为扩展名的源文件hello.i</li></ul></li></ul></li></ul><h6 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h6><ul><li>编译器CCL<ul><li>对预处理后的源程序进行编译</li><li>生成一个汇编语言源程序hello.s</li><li>汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令</li></ul></li></ul><h6 id="汇编阶段："><a href="#汇编阶段：" class="headerlink" title="汇编阶段："></a>汇编阶段：</h6><ul><li>汇编器as<ul><li>将hello.s翻译成机器语言指令</li><li>把这些指令打包成一个称为 <strong>可重定位目标文件</strong>的hello.o<ul><li>它是一种二进制文件</li><li>因此在文本编辑器中打开它会显示乱码</li></ul></li></ul></li></ul><h6 id="链接阶段："><a href="#链接阶段：" class="headerlink" title="链接阶段："></a>链接阶段：</h6><ul><li>链接器ld<ul><li>将多个 <strong>可重定位目标文件</strong>和 <strong>标准库函数</strong><ul><li>合并为一个 <strong>可执行目标文件</strong></li><li>或简称：可执行文件</li></ul></li><li>本例中，链接器将hello.o和标准库函数prinft<ul><li>所在的 <strong>可重定位目标模块</strong>prinft.o合并</li><li>生成可执行文件hello</li><li>最终生成的可执行文件被保存在磁盘上</li></ul></li></ul></li></ul><h4 id="指令执行过程描述"><a href="#指令执行过程描述" class="headerlink" title="指令执行过程描述"></a>指令执行过程描述</h4><h5 id="过程概述："><a href="#过程概述：" class="headerlink" title="过程概述："></a>过程概述：</h5><ul><li>程序中第一条指令的地址 置于PC中<ul><li>根据PC取出第一条指令</li></ul></li><li>经过译码、执行步骤等<ul><li>控制计算机各功能部件协同运行</li><li>完成这条指令的功能</li><li>并计算下一条指令的地址</li></ul></li><li>用新得到的指令地址<ul><li>继续读出第二条指令并执行</li><li>直到程序结束为止</li></ul></li></ul><h5 id="以取数指令为例说明-指令的执行过程"><a href="#以取数指令为例说明-指令的执行过程" class="headerlink" title="以取数指令为例说明 指令的执行过程"></a>以取数指令为例说明 指令的执行过程</h5><ul><li>即 将指令地址码知识的存储单元中的操作数<ul><li>取出后</li><li>送至运算器的ACC中</li></ul></li><li>信息流程:<ol><li>取指令</li><li>分析指令</li><li>执行指令</li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 王道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第九章</title>
      <link href="/posts/59439.html"/>
      <url>/posts/59439.html</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-软件项目配置管理计划"><a href="#第九章-软件项目配置管理计划" class="headerlink" title="第九章 软件项目配置管理计划"></a>第九章 软件项目配置管理计划</h1><p>本章要点：</p><ul><li>软件配置管理基本概念</li><li>软件配置管理过程</li><li>敏捷项目配置管理</li><li>案例分析</li></ul><h2 id="1-软件配置管理基本概念"><a href="#1-软件配置管理基本概念" class="headerlink" title="1 软件配置管理基本概念"></a>1 软件配置管理基本概念</h2><h3 id="1-1-配置管理定义"><a href="#1-1-配置管理定义" class="headerlink" title="1.1 配置管理定义"></a>1.1 配置管理定义</h3><ul><li>记录软件产品的演化过程</li><li>得到精确地产品配置</li><li>最终保证软件产品的<ul><li>完整性</li><li>一致性</li><li>追溯性</li><li>可控性</li></ul></li></ul><h3 id="1-2-配置管理的主要功能"><a href="#1-2-配置管理的主要功能" class="headerlink" title="1.2 配置管理的主要功能"></a>1.2 配置管理的主要功能</h3><ul><li>版本管理</li><li>变更管理</li><li>其他</li></ul><h3 id="1-3-软件配置项"><a href="#1-3-软件配置项" class="headerlink" title="1.3 软件配置项"></a>1.3 软件配置项</h3><ul><li><p>SCI：</p><ul><li>software configration item</li></ul></li><li><p>受控于软件配置管理的款项</p></li><li><p>配置项例子：</p><ul><li><img src="/posts/59439/配置项例子.png" style="zoom:50%;"></li></ul></li></ul><h3 id="1-4-基线"><a href="#1-4-基线" class="headerlink" title="1.4 基线"></a>1.4 基线</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>基线提供了软件生存期中各个开发阶段的一个特定点<ul><li>标志开发过程一个阶段的结束</li><li>或者里程碑</li></ul></li><li>一个（些）配置项形成并通过审核，即形成基线</li><li>基线修改需要按照正式的程序执行</li></ul><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><img src="/posts/59439/基线例子.png" style="zoom:50%;"><h3 id="1-5-SCCB"><a href="#1-5-SCCB" class="headerlink" title="1.5 SCCB"></a>1.5 SCCB</h3><ul><li>software configuration control board</li><li>软件配置控制委员会<ul><li>评估变更</li><li>批量变更申请</li><li>在生存期内规范变更申请流程</li><li>对变更进行反馈</li><li>与项目管理层沟通</li></ul></li></ul><h2 id="2-软件配置管理过程"><a href="#2-软件配置管理过程" class="headerlink" title="2. 软件配置管理过程"></a>2. 软件配置管理过程</h2><h3 id="2-1-配置管理基本过程"><a href="#2-1-配置管理基本过程" class="headerlink" title="2.1 配置管理基本过程"></a>2.1 配置管理基本过程</h3><ul><li>配置项标识、跟踪</li><li>配置管理环境建立</li><li>基线变更管理</li><li>配置管理审计</li><li>配置状态空寂</li><li>配置管理计划</li></ul><h4 id="配置项标识、跟踪"><a href="#配置项标识、跟踪" class="headerlink" title="配置项标识、跟踪"></a>配置项标识、跟踪</h4><ul><li>将软件项目中需要进行控制的部分拆分成SCI</li><li>配置项是唯一的标识</li><li>配置项的跟踪<ul><li>建立配置项的对应关系</li><li>以便于进行跟踪和版本控制</li><li>实现数字化管理</li></ul></li></ul><h4 id="配置管理环境建立"><a href="#配置管理环境建立" class="headerlink" title="配置管理环境建立"></a>配置管理环境建立</h4><ul><li>建立配置管理库<ul><li>软件配置管理库<ul><li>是用来存储所有基线配置项</li><li>及相关文件的等内容的系统</li></ul></li><li>是在软件产品的整个生存期中建立和维护软件产品完成性的主要手段</li></ul></li></ul><h5 id="受控操作："><a href="#受控操作：" class="headerlink" title="受控操作："></a>受控操作：</h5><img src="/posts/59439/受控操作.png" style="zoom:50%;"><h4 id="基线变更管理过程"><a href="#基线变更管理过程" class="headerlink" title="基线变更管理过程"></a>基线变更管理过程</h4><ul><li>极限修改应受到控制</li><li>这种变化要经SCCB授权</li><li>按程序进行控制并记录基线修改的过程</li></ul><h5 id="基线变更系统"><a href="#基线变更系统" class="headerlink" title="基线变更系统"></a>基线变更系统</h5><img src="/posts/59439/基线变更系统.png" style="zoom:50%;"><h5 id="变更请求"><a href="#变更请求" class="headerlink" title="变更请求"></a>变更请求</h5><img src="/posts/59439/变更请求.png" style="zoom:50%;"><h5 id="变更评估"><a href="#变更评估" class="headerlink" title="变更评估"></a>变更评估</h5><p><img src="/posts/59439/%E5%8F%98%E6%9B%B4%E8%AF%84%E4%BC%B0.png" alt=""></p><h5 id="变更批准-拒绝"><a href="#变更批准-拒绝" class="headerlink" title="变更批准/拒绝"></a>变更批准/拒绝</h5><img src="/posts/59439/变更批准.png" style="zoom:50%;"><h5 id="变更实现"><a href="#变更实现" class="headerlink" title="变更实现"></a>变更实现</h5><img src="/posts/59439/变更实现.png" style="zoom:50%;"><h4 id="配置管理审计"><a href="#配置管理审计" class="headerlink" title="配置管理审计"></a>配置管理审计</h4><ul><li>配置管理过程审计</li><li>基线审计</li></ul><h4 id="配置状态统计"><a href="#配置状态统计" class="headerlink" title="配置状态统计"></a>配置状态统计</h4><ul><li>eg：<ul><li>被批准的配置项</li><li>变更请求的数量</li><li>配置项的所有请求的变化状态</li><li>配置项所有被批准的变更实现状态</li><li>配置管理系统以及SCCB在运作中发生异常的次数</li></ul></li></ul><h4 id="配置管理计划大纲-举例"><a href="#配置管理计划大纲-举例" class="headerlink" title="配置管理计划大纲-举例"></a>配置管理计划大纲-举例</h4><ul><li>人员职责（确定SCCB等）</li><li>配置项定义</li><li>基线定义</li><li>版本控制（说明配置管理工具）</li><li>定义变更控制系统</li></ul><h2 id="3-敏捷项目配置管理"><a href="#3-敏捷项目配置管理" class="headerlink" title="3.敏捷项目配置管理"></a>3.敏捷项目配置管理</h2><h3 id="3-1-敏捷配置管理"><a href="#3-1-敏捷配置管理" class="headerlink" title="3.1 敏捷配置管理"></a>3.1 敏捷配置管理</h3><ul><li>敏捷的一个重要特征是持续交付<ul><li>因此，配置管理是重要的因素</li></ul></li><li>敏捷需要全面配置管理</li></ul><h3 id="3-2-全面配置管理的基本要求"><a href="#3-2-全面配置管理的基本要求" class="headerlink" title="3.2 全面配置管理的基本要求"></a>3.2 全面配置管理的基本要求</h3><ul><li>代码和编译构建产物的配置管理</li><li>应用的配置管理</li><li>环境的配置管理</li></ul><h3 id="3-3-代码和编译构建产物的配置管理"><a href="#3-3-代码和编译构建产物的配置管理" class="headerlink" title="3.3 代码和编译构建产物的配置管理"></a>3.3 代码和编译构建产物的配置管理</h3><ul><li>制定有效的分支管理策略</li><li>配置管理工具</li></ul><h3 id="3-4-制定有效的分支管理策略"><a href="#3-4-制定有效的分支管理策略" class="headerlink" title="3.4 制定有效的分支管理策略"></a>3.4 制定有效的分支管理策略</h3><ul><li>基于分支的开发</li><li>基于主干的开发</li></ul><h4 id="基于分支的开发"><a href="#基于分支的开发" class="headerlink" title="基于分支的开发"></a>基于分支的开发</h4><ul><li>开发都在分支上提交</li><li>并且可能有多个并行分支</li><li>直到快要上线时甚至上线后才合并到主干</li></ul><h4 id="基于主干的开发"><a href="#基于主干的开发" class="headerlink" title="基于主干的开发"></a>基于主干的开发</h4><ul><li>所有提交到主干上，提交后自动触发持续集成进行验证和快速反馈</li><li>持续交付更倾向于使用主干的开发模式</li></ul><h3 id="3-5-配置管理工具-Git分支管理"><a href="#3-5-配置管理工具-Git分支管理" class="headerlink" title="3.5 配置管理工具-Git分支管理"></a>3.5 配置管理工具-Git分支管理</h3><ul><li>Master</li><li>Develop</li><li>Release</li><li>Hotfix</li><li>feature</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第八章</title>
      <link href="/posts/46193.html"/>
      <url>/posts/46193.html</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-软件项目质量计划"><a href="#第八章-软件项目质量计划" class="headerlink" title="第八章 软件项目质量计划"></a>第八章 软件项目质量计划</h1><p>本章要点：</p><ul><li>软件质量基本概念</li><li>软件质量活动</li><li>敏捷质量活动</li><li>软件质量计划</li><li>案例分析</li></ul><h2 id="1-软件质量基本概念"><a href="#1-软件质量基本概念" class="headerlink" title="1. 软件质量基本概念"></a>1. 软件质量基本概念</h2><h3 id="1-1-质量的定义"><a href="#1-1-质量的定义" class="headerlink" title="1.1 质量的定义"></a>1.1 质量的定义</h3><ul><li>质量是满足要求的程度</li><li>包括符合规定的要求和满足顾客隐含需求</li></ul><h3 id="1-2-软件质量的定义"><a href="#1-2-软件质量的定义" class="headerlink" title="1.2 软件质量的定义"></a>1.2 软件质量的定义</h3><ul><li>软件质量是软件满足明确说明或者隐含的需求的程度</li></ul><h3 id="1-3-软件质量模型"><a href="#1-3-软件质量模型" class="headerlink" title="1.3 软件质量模型"></a>1.3 软件质量模型</h3><ul><li>人们通常把影响软件质量的特性用软件质量模型来描述</li><li><img src="/posts/46193/软件质量模型.png" style="zoom:50%;"></li></ul><h3 id="1-4-质量的形成"><a href="#1-4-质量的形成" class="headerlink" title="1.4 质量的形成"></a>1.4 质量的形成</h3><ul><li>质量形成于产品或者服务的开发过程中</li><li>而不是事后的检查(测试)把关</li></ul><h3 id="1-5-质量成本（CoQ）"><a href="#1-5-质量成本（CoQ）" class="headerlink" title="1.5 质量成本（CoQ）"></a>1.5 质量成本（CoQ）</h3><ul><li>预防成本：前期质量成本</li><li>缺陷成本：后期质量成本</li></ul><h2 id="2-软件质量活动"><a href="#2-软件质量活动" class="headerlink" title="2. 软件质量活动"></a>2. 软件质量活动</h2><h3 id="2-1-软件质量管理活动"><a href="#2-1-软件质量管理活动" class="headerlink" title="2.1 软件质量管理活动"></a>2.1 软件质量管理活动</h3><ul><li>软件质量保证</li><li>软件质量控制</li></ul><h3 id="2-2-质量管理的对象"><a href="#2-2-质量管理的对象" class="headerlink" title="2.2 质量管理的对象"></a>2.2 质量管理的对象</h3><ul><li>过程的质量</li><li>产品的质量</li></ul><h3 id="2-3-质量保证QA"><a href="#2-3-质量保证QA" class="headerlink" title="2.3 质量保证QA"></a>2.3 质量保证QA</h3><img src="/posts/46193/QA.png" style="zoom:50%;"><h3 id="2-4-质量保证活动-审计Audit"><a href="#2-4-质量保证活动-审计Audit" class="headerlink" title="2.4 质量保证活动-审计Audit"></a>2.4 质量保证活动-审计Audit</h3><ul><li>审计Audit<ul><li>是对过程或者产品的一次独立评估</li><li>将审核的主体与为该主体以前建立的一组规程和标准进行比较</li></ul></li></ul><h3 id="2-5-软件项目中常用的质量保证活动"><a href="#2-5-软件项目中常用的质量保证活动" class="headerlink" title="2.5 软件项目中常用的质量保证活动"></a>2.5 软件项目中常用的质量保证活动</h3><ul><li>项目执行过程审计</li><li>项目产品审计</li></ul><h3 id="2-6-情景项目：质量审计"><a href="#2-6-情景项目：质量审计" class="headerlink" title="2.6 情景项目：质量审计"></a>2.6 情景项目：质量审计</h3><img src="/posts/46193/质量审计.png" style="zoom:50%;"><h3 id="2-7-质量控制QC"><a href="#2-7-质量控制QC" class="headerlink" title="2.7 质量控制QC"></a>2.7 质量控制QC</h3><img src="/posts/46193/QC.png" style="zoom:50%;"><h3 id="2-8-质量控制活动"><a href="#2-8-质量控制活动" class="headerlink" title="2.8 质量控制活动"></a>2.8 质量控制活动</h3><ul><li>技术评审</li><li>代码走查</li><li>测试</li><li>数据分析</li></ul><h3 id="2-9-质量保证与质量控制比较"><a href="#2-9-质量保证与质量控制比较" class="headerlink" title="2.9 质量保证与质量控制比较"></a>2.9 质量保证与质量控制比较</h3><ul><li>QA：后期质量活动</li><li>QC：前期质量活动</li></ul><h2 id="3-敏捷质量活动"><a href="#3-敏捷质量活动" class="headerlink" title="3.敏捷质量活动"></a>3.敏捷质量活动</h2><h3 id="3-1-敏捷项目的质量规划特征"><a href="#3-1-敏捷项目的质量规划特征" class="headerlink" title="3.1 敏捷项目的质量规划特征"></a>3.1 敏捷项目的质量规划特征</h3><ul><li>全程质量审查</li><li>早发现问题，多版本提交</li><li>不断进行质量方法评估和改进</li></ul><h3 id="3-2-敏捷项目的质量活动"><a href="#3-2-敏捷项目的质量活动" class="headerlink" title="3.2 敏捷项目的质量活动"></a>3.2 敏捷项目的质量活动</h3><img src="/posts/46193/敏捷项目.png" style="zoom:50%;"><h4 id="TDD："><a href="#TDD：" class="headerlink" title="TDD："></a>TDD：</h4><ul><li>测试驱动开发</li><li>基本思想：<ul><li>在开发功能代码之前，先编写测试代码。然后编写相关的代码满足这些测试用例</li></ul></li></ul><h4 id="持续集成与测试"><a href="#持续集成与测试" class="headerlink" title="持续集成与测试"></a>持续集成与测试</h4><ul><li>频繁地将工作集成到整体中</li><li>然后再进行重新测试</li><li>以确定整个产品仍然按照预期工作</li></ul><h4 id="不同层面自动化测试"><a href="#不同层面自动化测试" class="headerlink" title="不同层面自动化测试"></a>不同层面自动化测试</h4><ul><li>单元测试</li><li>集成测试</li><li>系统级测试</li><li>冒烟测试</li><li>回归测试</li></ul><h4 id="验收测试驱动开发-ATDD"><a href="#验收测试驱动开发-ATDD" class="headerlink" title="验收测试驱动开发 ATDD"></a>验收测试驱动开发 ATDD</h4><ul><li>与客户一起讨论验收标准</li><li>创建测试用例</li><li>据此驱动代码编写，进行自动化测试，满足验收标准</li></ul><h4 id="敏捷开发中的管理会议"><a href="#敏捷开发中的管理会议" class="headerlink" title="敏捷开发中的管理会议"></a>敏捷开发中的管理会议</h4><img src="/posts/46193/管理会议.png" style="zoom:50%;"><h4 id="重构Refactoring"><a href="#重构Refactoring" class="headerlink" title="重构Refactoring"></a>重构Refactoring</h4><ul><li>简单设计之后编写可以运行的代码</li><li>版本运行之后逐步完善代码和设计</li></ul><h2 id="4-软件质量计划"><a href="#4-软件质量计划" class="headerlink" title="4.软件质量计划"></a>4.软件质量计划</h2><ul><li>确定项目应达到的质量标准（目标）</li><li>决定如何满足质量标准的计划安排和方法</li></ul><h3 id="4-1-质量计划方法"><a href="#4-1-质量计划方法" class="headerlink" title="4.1 质量计划方法"></a>4.1 质量计划方法</h3><ul><li>试验设计</li><li>基准对照</li><li>质量成本分析</li><li>数据图形分析<ul><li>流程图方法</li><li>因果分析图</li><li>思维导图</li></ul></li></ul><h3 id="4-2-MED项目质量控制计划"><a href="#4-2-MED项目质量控制计划" class="headerlink" title="4.2 MED项目质量控制计划"></a>4.2 MED项目质量控制计划</h3><img src="/posts/46193/MED1.png" style="zoom:50%;"><h3 id="MED项目：质量保证计划"><a href="#MED项目：质量保证计划" class="headerlink" title="MED项目：质量保证计划"></a>MED项目：质量保证计划</h3><img src="/posts/46193/质量保证计划.png" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第七章</title>
      <link href="/posts/20.html"/>
      <url>/posts/20.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-软件项目进度计划"><a href="#第七章-软件项目进度计划" class="headerlink" title="第七章 软件项目进度计划"></a>第七章 软件项目进度计划</h1><ul><li>进度计划的重要性：<ul><li>按时完成项目是项目经理最大的挑战之一</li><li>时间是项目规划中灵活性最小的因素</li><li>进度问题是项目冲突的主要原因</li></ul></li><li>进度的定义：<ul><li>进度是对执行的活动和里程碑制定的工作计划日期表</li></ul></li><li>项目进度计划过程：<ul><li>任务定义</li><li>任务关系</li><li>历时估算</li><li>项目进度编排</li><li>项目进度确定</li></ul></li></ul><p>本章要点：</p><ul><li>进度管理基本概念</li><li>历时估算-传统和敏捷</li><li>进度计划编排-传统和敏捷</li><li>项目进度规划模型</li><li>案例分析</li></ul><h2 id="1-进度管理基本概念"><a href="#1-进度管理基本概念" class="headerlink" title="1.进度管理基本概念"></a>1.进度管理基本概念</h2><h3 id="1-1-任务定义-Defining-Activities"><a href="#1-1-任务定义-Defining-Activities" class="headerlink" title="1.1 任务定义 Defining Activities"></a>1.1 任务定义 Defining Activities</h3><ul><li>确定为完成项目的各个交付成果多必须进行的诸项具体活动</li><li>eg:<ul><li>编写设计说明书</li><li>设计评审</li></ul></li></ul><h3 id="1-2-项目任务的关联关系"><a href="#1-2-项目任务的关联关系" class="headerlink" title="1.2 项目任务的关联关系"></a>1.2 项目任务的关联关系</h3><ul><li>项目各项活动之间存在一定的关联关系</li><li>根据这些关系安排任务之间的顺序<ul><li>eg：<ul><li>前置活动（任务）</li><li>后置活动（任务）</li></ul></li></ul></li></ul><h3 id="1-3-任务之间的关系"><a href="#1-3-任务之间的关系" class="headerlink" title="1.3 任务之间的关系"></a>1.3 任务之间的关系</h3><ul><li>结束-开始</li><li>结束-结束</li><li>开始-开始</li><li>开始-结束</li></ul><h3 id="1-4-任务之间关联关系的依据"><a href="#1-4-任务之间关联关系的依据" class="headerlink" title="1.4 任务之间关联关系的依据"></a>1.4 任务之间关联关系的依据</h3><ul><li>强制性依赖关系</li><li>软逻辑关系</li><li>外部依赖关系</li><li>内部依赖关系</li></ul><h3 id="1-5-关系依赖矩阵"><a href="#1-5-关系依赖矩阵" class="headerlink" title="1.5 关系依赖矩阵"></a>1.5 关系依赖矩阵</h3><ul><li><img src="/posts/20/关系依赖矩阵.png" style="zoom:50%;"></li></ul><p>eg：</p><img src="/posts/20/矩阵举例.png" style="zoom:50%;"><h3 id="1-6-进度管理图示"><a href="#1-6-进度管理图示" class="headerlink" title="1.6 进度管理图示"></a>1.6 进度管理图示</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ul><li>网络图</li><li>甘特图</li><li>里程碑图</li><li>资源图</li></ul><h4 id="网络图"><a href="#网络图" class="headerlink" title="网络图"></a>网络图</h4><ul><li><p>定义：</p><ul><li>网络图是活动排序的一个输出</li><li>展示项目中各个活动以及活动之间的逻辑关系</li></ul></li><li><p>常用的网络图：</p><ul><li>PDM（Precedence Diagramming Method）<ul><li>优先图法、节点法（单代号）网络图</li></ul></li><li>ADM（Arrow Diagramming Method）<ul><li>箭线法（双代号）网络图</li></ul></li></ul></li><li><p>PDM图例</p><ul><li><img src="/posts/20/PDM.png" alt="PDM" style="zoom:50%;"></li><li><img src="/posts/20/PDM1.png" style="zoom:50%;"></li></ul></li><li><p>PDM定义：</p><ul><li>构成PDM网络图的基本特点是节点（Box）</li><li>节点（Box）表示活动（任务）</li><li>用箭线表示各活动（任务）之间的逻辑关系、</li><li>可以方便的表示活动之间的各种逻辑关系</li></ul></li><li><p>ADM图例：</p><ul><li><img src="/posts/20/ADM1.png" style="zoom:50%;"></li></ul></li><li><p>ADM定义：</p><ul><li>ADM也称为双代号项目网络图</li><li>在ADM网络图中，箭线表示活动（任务）</li><li>两个代号唯一确定一个任务</li><li>代号表示前一任务的结束，同时也表后一任务的开始</li></ul></li><li><p>ADM虚活动</p><ul><li>为了定义活动</li><li>为了表示逻辑关系</li><li>不消耗资源的</li><li><img src="/posts/20/虚活动.png" style="zoom:50%;"></li></ul></li></ul><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h4><img src="/posts/20/甘特图.png" style="zoom:50%;"><h4 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h4><img src="/posts/20/里程碑.png" style="zoom:50%;"><h4 id="资源图"><a href="#资源图" class="headerlink" title="资源图"></a>资源图</h4><img src="/posts/20/流程图.png" style="zoom:50%;"><h4 id="燃尽图、进度图"><a href="#燃尽图、进度图" class="headerlink" title="燃尽图、进度图"></a>燃尽图、进度图</h4><img src="/posts/20/燃尽图.png" style="zoom:50%;"><h4 id="燃起图、进度图"><a href="#燃起图、进度图" class="headerlink" title="燃起图、进度图"></a>燃起图、进度图</h4><img src="/posts/20/燃起图.png" style="zoom:50%;"><h2 id="2-任务历时估算-传统和敏捷"><a href="#2-任务历时估算-传统和敏捷" class="headerlink" title="2.任务历时估算-传统和敏捷"></a>2.任务历时估算-传统和敏捷</h2><h3 id="2-1-历时估算"><a href="#2-1-历时估算" class="headerlink" title="2.1 历时估算"></a>2.1 历时估算</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>估计任务、路径、项目的持续时间</li></ul><h4 id="基本方法：-传统"><a href="#基本方法：-传统" class="headerlink" title="基本方法：-传统"></a>基本方法：-传统</h4><ul><li>定额估算法</li><li>经验导出模型</li><li>CPM（关键路径法估计）</li><li>PERT（工程评估评审技术）</li><li>预留分析</li><li>其他<ul><li>Jones的一阶估算准则</li><li>类比估算</li><li>专家判断</li><li>基于承诺的估计</li></ul></li></ul><h5 id="定额估算法"><a href="#定额估算法" class="headerlink" title="定额估算法"></a>定额估算法</h5><img src="/posts/20/定额估算法.png" style="zoom:50%;"><h5 id="经验导出模型"><a href="#经验导出模型" class="headerlink" title="经验导出模型"></a>经验导出模型</h5><img src="/posts/20/参数模型.png" style="zoom:50%;"><img src="/posts/20/经验导出.png" style="zoom:50%;"><h6 id="建议掌握模型"><a href="#建议掌握模型" class="headerlink" title="建议掌握模型"></a>建议掌握模型</h6><img src="/posts/20/建议掌握模型.png" style="zoom:50%;"><h6 id="基本COCOMO举例"><a href="#基本COCOMO举例" class="headerlink" title="基本COCOMO举例"></a>基本COCOMO举例</h6><img src="/posts/20/cocomo.png" style="zoom:50%;"><h6 id="经验导出模型举例"><a href="#经验导出模型举例" class="headerlink" title="经验导出模型举例"></a>经验导出模型举例</h6><img src="/posts/20/经验举例.png" style="zoom:50%;"><h5 id="关键路径法估计CPM"><a href="#关键路径法估计CPM" class="headerlink" title="关键路径法估计CPM"></a>关键路径法估计CPM</h5><ul><li>方法：<ul><li>确定项目网络图</li><li>每个任务有单一的历时估算</li><li>确定网络图中任务的逻辑关系</li><li>关键路径是网=网络图中最长的路径</li><li>关键路径可以确定项目完成时间</li></ul></li><li>实例：<ul><li><img src="/posts/20/关键.png" style="zoom:50%;"></li></ul></li></ul><h5 id="PERT-工程评估评审技术"><a href="#PERT-工程评估评审技术" class="headerlink" title="PERT 工程评估评审技术"></a>PERT 工程评估评审技术</h5><h6 id="定义；"><a href="#定义；" class="headerlink" title="定义；"></a>定义；</h6><ul><li>Program Evaluation and Review Technique</li><li>利用网络顺序图逻辑关系</li><li>项目中某项单独的活动，存在很大的不确定性</li><li>加权算法估算任务历时</li><li>利用网络图逻辑关系、确定路径、项目历时</li></ul><h6 id="加权算法"><a href="#加权算法" class="headerlink" title="加权算法"></a>加权算法</h6><img src="/posts/20/加权算法.png" style="zoom:50%;"><h6 id="加权因子"><a href="#加权因子" class="headerlink" title="加权因子"></a>加权因子</h6><img src="/posts/20/加权因子.png" style="zoom:50%;"><h6 id="风险指标"><a href="#风险指标" class="headerlink" title="风险指标"></a>风险指标</h6><img src="/posts/20/风险指标.png" style="zoom:50%;"><h6 id="评估一条路径的指标"><a href="#评估一条路径的指标" class="headerlink" title="评估一条路径的指标"></a>评估一条路径的指标</h6><img src="/posts/20/指标.png" style="zoom:50%;"><h6 id="PERT估算举例"><a href="#PERT估算举例" class="headerlink" title="PERT估算举例"></a>PERT估算举例</h6><img src="/posts/20/估算举例.png" style="zoom:50%;"><h6 id="标准差的概率理论"><a href="#标准差的概率理论" class="headerlink" title="标准差的概率理论"></a>标准差的概率理论</h6><img src="/posts/20/概率1.png" style="zoom:50%;"><img src="/posts/20/概率2.png" style="zoom:50%;"><img src="/posts/20/概率3.png" style="zoom:50%;"><img src="/posts/20/概率4.png" style="zoom:50%;"><h6 id="PERT估算评估举例"><a href="#PERT估算评估举例" class="headerlink" title="PERT估算评估举例"></a>PERT估算评估举例</h6><img src="/posts/20/举例1.png" style="zoom:50%;"><img src="/posts/20/举例2.png" style="zoom:50%;"><h5 id="预留分析"><a href="#预留分析" class="headerlink" title="预留分析"></a>预留分析</h5><ul><li>应急预留</li><li>管理预留</li></ul><h6 id="应急预留："><a href="#应急预留：" class="headerlink" title="应急预留："></a>应急预留：</h6><ul><li>是包含在进度基准中的一段储备时间</li><li>用来应对已经接受的已识别风险</li><li>以应对进度方面的不确定性</li></ul><h6 id="管理预留："><a href="#管理预留：" class="headerlink" title="管理预留："></a>管理预留：</h6><ul><li>是为管理控制的目的而特别留出的项目预算</li><li>用来应对项目范围中不可预见的风险</li></ul><h5 id="Jones的一阶估算准则"><a href="#Jones的一阶估算准则" class="headerlink" title="Jones的一阶估算准则"></a>Jones的一阶估算准则</h5><img src="/posts/20/jones.png" style="zoom:50%;"><p>实例：<img src="/posts/20/jones1.png" style="zoom:50%;"></p><h5 id="类比估算："><a href="#类比估算：" class="headerlink" title="类比估算："></a>类比估算：</h5><ul><li>以过去类似项目的实际持续时间为依据</li><li>来估算当前项目的持续时间</li></ul><h5 id="专家判断："><a href="#专家判断：" class="headerlink" title="专家判断："></a>专家判断：</h5><p>根据下面专业知识做出的历时估算</p><ul><li>进度计划</li><li>有关估算</li><li>学科或应用知识</li></ul><h5 id="基于承诺的进度估算"><a href="#基于承诺的进度估算" class="headerlink" title="基于承诺的进度估算"></a>基于承诺的进度估算</h5><ul><li>要求开发人员做出进度承诺</li><li>不进行中间的工作量（规模）估计<ul><li>优点：<ul><li>有利于开发者对进度的关注</li></ul></li></ul></li></ul><h4 id="历时估算的基本方法-敏捷"><a href="#历时估算的基本方法-敏捷" class="headerlink" title="历时估算的基本方法-敏捷"></a>历时估算的基本方法-敏捷</h4><ul><li>开发速度稳定前<ul><li>项目经理组织 <strong>举手表决</strong><ul><li><img src="/posts/20/举手表决.png" style="zoom:50%;"></li></ul></li></ul></li><li>开发速度稳定后<ul><li>基于故事点生产率的估算</li><li>基于迭代生产率的估算</li></ul></li></ul><h5 id="基于Story-Point生产率的历时估算"><a href="#基于Story-Point生产率的历时估算" class="headerlink" title="基于Story Point生产率的历时估算"></a>基于Story Point生产率的历时估算</h5><img src="/posts/20/story.png" style="zoom:50%;"><h5 id="基于迭代生产率的历时估算"><a href="#基于迭代生产率的历时估算" class="headerlink" title="基于迭代生产率的历时估算"></a>基于迭代生产率的历时估算</h5><img src="/posts/20/迭代.png" style="zoom:50%;"><h2 id="3-进度计划编排-传统和敏捷"><a href="#3-进度计划编排-传统和敏捷" class="headerlink" title="3.进度计划编排-传统和敏捷"></a>3.进度计划编排-传统和敏捷</h2><h3 id="3-1-进度编制的基本方法"><a href="#3-1-进度编制的基本方法" class="headerlink" title="3.1 进度编制的基本方法"></a>3.1 进度编制的基本方法</h3><ul><li>超前Lead和滞后Lag<ul><li>关键路径法</li><li>时间压缩法</li><li>资源优化</li><li>敏捷计划</li></ul></li></ul><h4 id="任务滞后Lag"><a href="#任务滞后Lag" class="headerlink" title="任务滞后Lag"></a>任务滞后Lag</h4><img src="/posts/20/lag.png" style="zoom:50%;"><p>举例：</p><img src="/posts/20/lag1.png" style="zoom:50%;"><h4 id="任务超前Lead"><a href="#任务超前Lead" class="headerlink" title="任务超前Lead"></a>任务超前Lead</h4><img src="/posts/20/lead.png" style="zoom:50%;"><img src="/posts/20/lead2.png" style="zoom:50%;"><img src="/posts/20/lead3.png" style="zoom:50%;"><h4 id="关键路径法："><a href="#关键路径法：" class="headerlink" title="关键路径法："></a>关键路径法：</h4><h5 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h5><ul><li>最早开始时间 Early start</li><li>最晚开始时间 Late start</li><li>最早完成时间 Early finish</li><li>最晚完成时间 Late finish</li><li>总浮动 Total Float</li><li>自由浮动 Free Float</li></ul><img src="/posts/20/总.png" style="zoom:50%;"><h5 id="浮动时间Float"><a href="#浮动时间Float" class="headerlink" title="浮动时间Float"></a>浮动时间Float</h5><ul><li>浮动时间是一个任务的机动性</li><li>他是一个任务在不影响其他任务或者项目完成的情况下可以延迟的时间量</li></ul><h5 id="总浮动与自由浮动"><a href="#总浮动与自由浮动" class="headerlink" title="总浮动与自由浮动"></a>总浮动与自由浮动</h5><ul><li><p>总浮动：</p><ul><li>Total Float</li><li>在不影响项目最早完成时间的前提下</li><li>一个任务可以延迟的时间</li></ul></li><li><p>自由浮动</p><ul><li>Free Float</li><li>在不影响后置任务最早开始时间的前提下</li><li>一个任务可以延迟的时间</li></ul><img src="/posts/20/浮动.png" style="zoom:50%;"></li></ul><h5 id="关键路径Critical-Path"><a href="#关键路径Critical-Path" class="headerlink" title="关键路径Critical Path"></a>关键路径Critical Path</h5><ul><li>网络图中最长的路径</li><li>关键路径是决定项目完成的最短时间</li><li>时间浮动为0（Float=0）的路径</li><li>关键路径上任何活动延迟，都会导致整个项目完成时间的延迟</li><li>关键路径可能不止一条</li></ul><h5 id="项目网络图："><a href="#项目网络图：" class="headerlink" title="项目网络图："></a>项目网络图：</h5><img src="/posts/20/1.png" style="zoom:50%;"><img src="/posts/20/2.png" style="zoom:50%;"><img src="/posts/20/3.png" style="zoom:50%;"><img src="/posts/20/4.png" style="zoom:50%;"><img src="/posts/20/5.png" style="zoom:50%;"><img src="/posts/20/6.png" style="zoom:50%;"><h5 id="正推法Forward-pass"><a href="#正推法Forward-pass" class="headerlink" title="正推法Forward pass"></a>正推法Forward pass</h5><ul><li><p>定义：</p><ul><li>按照时间顺序计算最早开始时间和最早完成时间的方法</li></ul></li><li><p>确定项目的开始时间，网络图中第一个任务的最早开始时间是项目的开始时间</p></li><li><p>ES+Duration=EF</p></li><li><p>EF+Lag=ES(s)</p><ul><li>当一个任务有多个前置任务时，选择前置任务中最大的EF加上Lag作为ES</li></ul></li><li><p>依次类推，从左到右，从上到下，计算每个路径的所有任务的ES和最早完成时间EF</p></li><li><p>实例：</p><ul><li><img src="/posts/20/正推.png" style="zoom:50%;"></li></ul></li></ul><h5 id="逆推法-Backward-pass"><a href="#逆推法-Backward-pass" class="headerlink" title="逆推法 Backward pass"></a>逆推法 Backward pass</h5><ul><li><p>定义：</p><ul><li>按照逆时间顺序计算最晚开始时间和最晚结束时间的方法</li></ul></li><li><p>首先确定项目的结束时间</p><ul><li>网络图中的最后一个任务最晚完成时间是项目的结束时间</li></ul></li><li><p>LF-Duration=LS</p></li><li><p>LS-Lag=LF(p)</p><ul><li>当一个任务有多个后置任务时</li><li>选择其后置任务中最小LS减Lag作为LF</li></ul></li><li><p>依次类推，从右到左，从上倒下，计算每个任务的最晚开始时间LS和最晚结束时间LF</p></li><li><p>实例：</p><ul><li><img src="/posts/20/逆推法.png" style="zoom:50%;"></li></ul></li></ul><h5 id="课堂练习："><a href="#课堂练习：" class="headerlink" title="课堂练习："></a>课堂练习：</h5><img src="/posts/20/练习1.png" style="zoom:50%;"><img src="/posts/20/练习.png" style="zoom:50%;"><h4 id="时间压缩法"><a href="#时间压缩法" class="headerlink" title="时间压缩法"></a>时间压缩法</h4><ul><li>定义：<ul><li>是在不改变项目范围的前提下缩短项目工期的方法</li></ul></li><li>分类：<ul><li>应急法-赶工 Crash</li><li>平行作业法-快速跟进</li></ul></li></ul><h5 id="应急法-赶工"><a href="#应急法-赶工" class="headerlink" title="应急法-赶工"></a>应急法-赶工</h5><ul><li>在最小相关成本增加的条件下，压缩关键路径上的关键活动历时的方法</li><li>赶工也称为时间-成本平衡方法</li></ul><h6 id="赶工时间与赶工成本关系图"><a href="#赶工时间与赶工成本关系图" class="headerlink" title="赶工时间与赶工成本关系图"></a>赶工时间与赶工成本关系图</h6><img src="/posts/20/赶工.png" style="zoom:50%;"><ol><li>进度压缩单位成本方法<ol><li>线性关系</li></ol></li><li>Charles Symons(1991)方法<ol><li>进度压缩比普通进度短的时候，费用迅速上涨</li></ol></li></ol><h6 id="进度压缩单位成本方法"><a href="#进度压缩单位成本方法" class="headerlink" title="进度压缩单位成本方法"></a>进度压缩单位成本方法</h6><ul><li><p>压缩范围：</p><ul><li>正常值与可压缩值之间</li></ul></li><li><p>项目活动的正常值</p><ul><li>正常历时</li><li>正常成本</li></ul></li><li><p>项目活动的压缩值</p><ul><li>压缩历时</li><li>压缩成本</li></ul></li><li><p>eg：</p><ul><li>任务A：正常进度7周，成本5万<ul><li>压缩到5周的成本是6.2万</li></ul></li><li>压缩范围：7周-5周</li></ul></li><li><p>进度压缩单位成本=（压缩成本-正常成本）/（正常进度-压缩进度）</p><ul><li>eg;<ul><li><img src="/posts/20/压缩1.png" style="zoom:50%;"></li></ul></li></ul><h6 id="时间压缩例题"><a href="#时间压缩例题" class="headerlink" title="时间压缩例题"></a>时间压缩例题</h6><img src="/posts/20/压缩题1.png" style="zoom:50%;"></li></ul><img src="/posts/20/压缩题2.png" style="zoom:50%;"><img src="/posts/20/压缩题3.png" style="zoom:50%;"><img src="/posts/20/压缩题4.png" style="zoom:50%;"><img src="/posts/20/压缩题5.png" style="zoom:50%;"><img src="/posts/20/压缩题6.png" style="zoom:50%;"><h6 id="项目存在一个可能的最短进度"><a href="#项目存在一个可能的最短进度" class="headerlink" title="项目存在一个可能的最短进度"></a>项目存在一个可能的最短进度</h6><img src="/posts/20/最短进度.png" style="zoom:50%;"><h5 id="Charles-Symons方法"><a href="#Charles-Symons方法" class="headerlink" title="Charles Symons方法"></a>Charles Symons方法</h5><img src="/posts/20/ch.png" style="zoom:50%;"><h5 id="平行作业法-快速跟进"><a href="#平行作业法-快速跟进" class="headerlink" title="平行作业法-快速跟进"></a>平行作业法-快速跟进</h5><ul><li>改变活动间的逻辑关系</li><li>并行开展某些活动</li><li>提前量方法</li><li>eg：<ul><li><img src="/posts/20/平行作业法.png" style="zoom:50%;"></li></ul></li></ul><h5 id="任务超前（Lead-应用"><a href="#任务超前（Lead-应用" class="headerlink" title="任务超前（Lead)应用"></a>任务超前（Lead)应用</h5><img src="/posts/20/lead应用.png" style="zoom:50%;"><h4 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h4><ul><li>根据资源供需情况，调整活动的开始和完成日期</li><li>资源优化配置，形成最有效的利用资源<ul><li>使资源闲置的时间最小化</li><li>尽量避免超出资源能力</li></ul></li></ul><h5 id="分类：-1"><a href="#分类：-1" class="headerlink" title="分类："></a>分类：</h5><ul><li>资源平衡</li><li>资源平滑</li></ul><h5 id="资源平衡"><a href="#资源平衡" class="headerlink" title="资源平衡"></a>资源平衡</h5><ul><li>为了在资源需求与资源供给之间取得平衡<ul><li>根据资源制约因素对开始日期和完成日期进行调整的一种技术</li></ul></li><li>通过调整任务的时间来协调资源的冲突</li><li>资源平衡往往导致关键路径改变</li></ul><h6 id="资源平衡法"><a href="#资源平衡法" class="headerlink" title="资源平衡法"></a>资源平衡法</h6><img src="/posts/20/资源平衡法.png" style="zoom:50%;"><h5 id="资源平滑法"><a href="#资源平滑法" class="headerlink" title="资源平滑法"></a>资源平滑法</h5><ul><li>资源平滑法是在项目编排中进行资源的优化配置，保证资源最优化、最优效</li><li>资源平滑不会改变项目关键路径，完工日期也不会延迟。活动只在其自由和总浮动时间内延迟</li></ul><h4 id="敏捷计划"><a href="#敏捷计划" class="headerlink" title="敏捷计划"></a>敏捷计划</h4><h5 id="Agile-Planning"><a href="#Agile-Planning" class="headerlink" title="Agile Planning"></a>Agile Planning</h5><ul><li>Release planning<ul><li>发布计划 远期计划 粗计划</li></ul></li><li>Iteration planning<ul><li>迭代计划 近期计划 细计划</li></ul></li></ul><h2 id="4-项目进度规划模型"><a href="#4-项目进度规划模型" class="headerlink" title="4.项目进度规划模型"></a>4.项目进度规划模型</h2><h3 id="软件项目进度问题模型SPSP"><a href="#软件项目进度问题模型SPSP" class="headerlink" title="软件项目进度问题模型SPSP"></a>软件项目进度问题模型SPSP</h3><ul><li>软件项目进度问题Software Project Scheduling Problem,SPSP</li><li>是在给定的项目任务工作量及其关系和资源限制下，对项目确定合适的人员安排，以保证项目的时间最短，成本最小</li><li>目标：<ul><li>时间最短，成本最低</li></ul></li></ul><h4 id="Pdm网络图"><a href="#Pdm网络图" class="headerlink" title="Pdm网络图"></a>Pdm网络图</h4><img src="/posts/20/pdm111.png" style="zoom:50%;"><p>成本计算：<img src="/posts/20/成本计算.png" style="zoom:50%;"></p><h5 id="计划优化调整"><a href="#计划优化调整" class="headerlink" title="计划优化调整"></a>计划优化调整</h5><ol><li>调整资源，解决资源冲突</li><li>调整进度，优化项目，缩短工期</li><li>调整项目成本预算，以便减少项目费用</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第六章</title>
      <link href="/posts/15473.html"/>
      <url>/posts/15473.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-软件项目成本计划"><a href="#第六章-软件项目成本计划" class="headerlink" title="第六章 软件项目成本计划"></a>第六章 软件项目成本计划</h1><p>本章要点：</p><ul><li>估算过程概念</li><li>传统估算方法</li><li>敏捷估算方法</li><li>成本预算</li><li>案例分析</li></ul><h2 id="1-估算过程概念"><a href="#1-估算过程概念" class="headerlink" title="1. 估算过程概念"></a>1. 估算过程概念</h2><h3 id="1-1-关于估算"><a href="#1-1-关于估算" class="headerlink" title="1.1 关于估算"></a>1.1 关于估算</h3><ul><li>估算不是很准确、有误差</li><li>项目经验数据非常重要</li><li>不要太迷信某些数学模型</li></ul><h3 id="1-2-软件项目规模"><a href="#1-2-软件项目规模" class="headerlink" title="1.2 软件项目规模"></a>1.2 软件项目规模</h3><ul><li>软件项目规模即工作量</li><li>例如：<ul><li>软件规划、软件管理、需求</li><li>设计、编码、测试</li><li>以及后期的维护等任务</li></ul></li></ul><h3 id="1-3-软件规模单位"><a href="#1-3-软件规模单位" class="headerlink" title="1.3 软件规模单位"></a>1.3 软件规模单位</h3><ul><li>LOC(Loc of Code)<ul><li>源代码长度的测量</li></ul></li><li>FP（Function Point）<ul><li>用系统的功能数量来测量</li></ul></li><li>人月</li><li>人天</li><li>人年</li></ul><h3 id="1-4-软件项目成本"><a href="#1-4-软件项目成本" class="headerlink" title="1.4 软件项目成本"></a>1.4 软件项目成本</h3><ul><li>完成软件规模相应付出的代价</li><li>待开发的软件项目需要的资金</li><li>人的劳动的消耗所需要的代价是软件产品的主要成本</li><li>货币单位</li></ul><h3 id="1-5-软件规模和软件成本的关系"><a href="#1-5-软件规模和软件成本的关系" class="headerlink" title="1.5 软件规模和软件成本的关系"></a>1.5 软件规模和软件成本的关系</h3><ul><li>工作量-&gt;规模-&gt;成本</li></ul><h3 id="1-6-成本估算结果"><a href="#1-6-成本估算结果" class="headerlink" title="1.6 成本估算结果"></a>1.6 成本估算结果</h3><ul><li>直接成本：<ul><li>与具体项目相关的成本</li><li>eg:<ul><li>参与项目的人员成本</li></ul></li></ul></li><li>间接成本：<ul><li>可以分摊到各个具体项目中的成本<ul><li>eg：<ul><li>培训</li><li>房租水电</li><li>员工福利</li><li>市场费用</li><li>管理费</li><li>其他等等</li></ul></li></ul></li></ul></li></ul><h2 id="2-传统估算方法"><a href="#2-传统估算方法" class="headerlink" title="2. 传统估算方法"></a>2. 传统估算方法</h2><ul><li>代码行估算法</li><li>功能点估算法</li><li>用例点估算法</li><li>类比（自顶向下）估算法</li><li>自下而上估算法</li><li>三点估算法</li><li>参数估算法</li><li>专家估算法</li></ul><h3 id="2-1-传统估算方法-代码行估算法"><a href="#2-1-传统估算方法-代码行估算法" class="headerlink" title="2.1 传统估算方法-代码行估算法"></a>2.1 传统估算方法-代码行估算法</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ul><li>从软件程序两的角度定义项目规模<ul><li>与具体的编程语言有关</li><li>分解足够详细</li><li>有一定的经验数据</li></ul></li></ul><h4 id="代码行的主要优缺点："><a href="#代码行的主要优缺点：" class="headerlink" title="代码行的主要优缺点："></a>代码行的主要优缺点：</h4><ul><li>主要优点：<ul><li>代码是所有软件开发项目都有的“产品”</li><li>而且很容易计算代码行数</li></ul></li><li>主要缺陷：<ul><li>对代码行没有公认的可接受的标准定义</li><li>代码行数量依赖于所用的编程语言和个人的编程风格</li><li>在项目早期，需求不稳定，设计不成熟，实现不确定的情况下很难准确地估算代码量</li><li>代码行强调编码的工作量，只是项目实现阶段的一部分</li></ul></li></ul><h3 id="2-2-传统估算方法-功能点估算："><a href="#2-2-传统估算方法-功能点估算：" class="headerlink" title="2.2 传统估算方法-功能点估算："></a>2.2 传统估算方法-功能点估算：</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>与实现的语言和技术没有关系</li><li>用系统的功能数量来测量器规模</li><li>通过评估、加权、量化得到功能点</li></ul><h4 id="传统估算方法-Albrecht功能点估算"><a href="#传统估算方法-Albrecht功能点估算" class="headerlink" title="传统估算方法-Albrecht功能点估算"></a>传统估算方法-Albrecht功能点估算</h4><ul><li>1979年，Alan Albrecht提出</li><li>也称为IFPUG（国际功能点用户组织）功能点</li><li>适用于信息系统</li></ul><h4 id="功能点公式："><a href="#功能点公式：" class="headerlink" title="功能点公式："></a>功能点公式：</h4><ul><li>FP=UFC*TCF<ul><li>UFC:<ul><li>来调整功能点计数</li></ul></li><li>TCF：<ul><li>技术复杂度因子</li></ul></li></ul></li></ul><h4 id="UFC-未调整功能点计数"><a href="#UFC-未调整功能点计数" class="headerlink" title="UFC-未调整功能点计数"></a>UFC-未调整功能点计数</h4><ul><li>功能计数项：<ul><li>外部输入</li><li>外部输出</li><li>外部查询</li><li>内部逻辑文件</li><li>外部接口文件</li></ul></li></ul><h4 id="外部输入（External-Inputs-EI）"><a href="#外部输入（External-Inputs-EI）" class="headerlink" title="外部输入（External Inputs:EI）"></a>外部输入（External Inputs:EI）</h4><ul><li>给软件提供面向应用的数据的项<ul><li>eg：屏幕、表单、对话框、控件、文件等</li></ul></li><li>在这个过程中，数据穿越外部边界进入系统内部</li><li>eg<ul><li>课堂登录系统的登录框</li></ul></li></ul><h4 id="外部输出External-Outputs-EO"><a href="#外部输出External-Outputs-EO" class="headerlink" title="外部输出External Outputs EO"></a>外部输出External Outputs EO</h4><ul><li>向用户提供（经过处理的）面向应用的信息</li><li>eg：<ul><li>报表和出错信息等</li></ul></li><li>eg：<ul><li><img src="/posts/15473/外部输出.png" alt="外部输出" style="zoom:50%;"></li></ul></li></ul><h4 id="外部查询-External-Inquiry-EQ"><a href="#外部查询-External-Inquiry-EQ" class="headerlink" title="外部查询 External Inquiry EQ"></a>外部查询 External Inquiry EQ</h4><ul><li>外部查询是一个输入引出一个即时的简单输出</li><li>没有处理过程</li><li>eg：<ul><li><img src="/posts/15473/外部查询.png" alt="外部查询" style="zoom:50%;"></li></ul></li></ul><h4 id="外部接口文件-External-Interface-Files-EIF’s"><a href="#外部接口文件-External-Interface-Files-EIF’s" class="headerlink" title="外部接口文件 External Interface Files EIF’s"></a>外部接口文件 External Interface Files EIF’s</h4><ul><li>外部接口文件<ul><li>是用户可以识别的一组逻辑相关数据</li><li>这组数据只能被引用</li><li>用这些接口把信息传送给另一个系统</li></ul></li></ul><h4 id="内部逻辑文件-Internal-Logical-Files-ILF’s"><a href="#内部逻辑文件-Internal-Logical-Files-ILF’s" class="headerlink" title="内部逻辑文件 Internal Logical Files:ILF’s"></a>内部逻辑文件 Internal Logical Files:ILF’s</h4><ul><li>用户可以识别的一组逻辑相关的数据</li><li>而且完全存在于应用的边界之内</li><li>并且通过外部输入维护</li><li>是逻辑主文件的数目</li><li>eg：<ul><li><img src="/posts/15473/内部逻辑.png" alt="内部逻辑" style="zoom:50%;"></li></ul></li></ul><h4 id="FP计数的规则"><a href="#FP计数的规则" class="headerlink" title="FP计数的规则"></a>FP计数的规则</h4><ul><li>国际功能点用户组织IFPUG发布FP计数的规则<ul><li>IFPUG功能点估算方法使用指南</li></ul></li></ul><h4 id="事务组件进行定级"><a href="#事务组件进行定级" class="headerlink" title="事务组件进行定级"></a>事务组件进行定级</h4><img src="/posts/15473/事务组件.png" alt="事务组件" style="zoom:50%;"><h4 id="内部逻辑文件和外部接口文件"><a href="#内部逻辑文件和外部接口文件" class="headerlink" title="内部逻辑文件和外部接口文件"></a>内部逻辑文件和外部接口文件</h4><img src="/posts/15473/内部逻辑文件.png" alt="内部逻辑文件" style="zoom:50%;"><h4 id="功能计数项的复杂度等级"><a href="#功能计数项的复杂度等级" class="headerlink" title="功能计数项的复杂度等级"></a>功能计数项的复杂度等级</h4><img src="/posts/15473/复杂度.png" alt="复杂度" style="zoom:50%;"><h4 id="功能点估算方法举例"><a href="#功能点估算方法举例" class="headerlink" title="功能点估算方法举例"></a>功能点估算方法举例</h4><p><img src="/posts/15473/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%B8%BE%E4%BE%8B.png" alt="功能点举例"></p><h5 id="外贸订单：UFC"><a href="#外贸订单：UFC" class="headerlink" title="外贸订单：UFC"></a>外贸订单：UFC</h5><ul><li>外部输入：3项  </li><li>外部输出：1项</li><li>外部查询：1项</li><li>外部接口文件：1项</li><li>内部逻辑文件：2项</li></ul><img src="/posts/15473/UFC.png" alt="UFC" style="zoom:50%;"><h5 id="TCF-计数复杂度因子"><a href="#TCF-计数复杂度因子" class="headerlink" title="TCF-计数复杂度因子"></a>TCF-计数复杂度因子</h5><ul><li>TCF=0.65+0.01（sum（Fi））:Fi:0-5,TCF：0.65-1.35</li><li><img src="/posts/15473/TCF.png" alt="TCF"></li></ul><h5 id="技术复杂度因子的取值范围"><a href="#技术复杂度因子的取值范围" class="headerlink" title="技术复杂度因子的取值范围"></a>技术复杂度因子的取值范围</h5><ul><li><img src="/posts/15473/计数复杂度.png" alt="计数复杂度" style="zoom:50%;"></li></ul><h5 id="外贸订单项目-功能点计算"><a href="#外贸订单项目-功能点计算" class="headerlink" title="外贸订单项目-功能点计算"></a>外贸订单项目-功能点计算</h5><ul><li>因为：EFC=45<ul><li>TCF=0.65+0.01(14*3)=1.07</li></ul></li><li>所以：FP=UFC*TCF=45 * 1.07=48</li><li>如果：PF=15工时/功能点</li><li>则：Effort=48*15=720工时</li></ul><h4 id="其他功能点方法："><a href="#其他功能点方法：" class="headerlink" title="其他功能点方法："></a>其他功能点方法：</h4><ul><li>Mark II 功能点（主要应用在英国)</li><li>COSMIC-FFP 功能点（适用于实时系统或者嵌入式系统）</li></ul><h4 id="功能点与代码行的转换"><a href="#功能点与代码行的转换" class="headerlink" title="功能点与代码行的转换"></a>功能点与代码行的转换</h4><ul><li><img src="/posts/15473/功能点转换.png" alt="功能点转换" style="zoom:50%;"></li></ul><h3 id="2-3-用例点估算法"><a href="#2-3-用例点估算法" class="headerlink" title="2.3 用例点估算法"></a>2.3 用例点估算法</h3><h4 id="传统估算方法-用例模型"><a href="#传统估算方法-用例模型" class="headerlink" title="传统估算方法-用例模型"></a>传统估算方法-用例模型</h4><img src="/posts/15473/用例模型.png" alt="用例模型" style="zoom:50%;"><h4 id="传统估算方法-用例点估算模型"><a href="#传统估算方法-用例点估算模型" class="headerlink" title="传统估算方法-用例点估算模型"></a>传统估算方法-用例点估算模型</h4><img src="/posts/15473/用例点.png" alt="用例点" style="zoom:50%;"><h4 id="用例点估算方法的基本步骤"><a href="#用例点估算方法的基本步骤" class="headerlink" title="用例点估算方法的基本步骤"></a>用例点估算方法的基本步骤</h4><ol><li>计算未调整的角色权值UAW</li><li>计算未调整的用例权值UUCW</li><li>计算未调整的用例点UUCP</li><li>计算技术和环境因子TEF</li><li>计算调整的用例点UCP</li><li>计算工作量man-hours</li></ol><h5 id="1-计算未调整的角色权值UAW"><a href="#1-计算未调整的角色权值UAW" class="headerlink" title="1.计算未调整的角色权值UAW"></a>1.计算未调整的角色权值UAW</h5><img src="/posts/15473/UAW.png" alt="UAW" style="zoom:50%;"><h5 id="2-计算未调整的用例权值UUCW"><a href="#2-计算未调整的用例权值UUCW" class="headerlink" title="2. 计算未调整的用例权值UUCW"></a>2. 计算未调整的用例权值UUCW</h5><img src="/posts/15473/uucw.png" alt="UUCW" style="zoom:50%;"><h5 id="3-计算未调整的用例点UUCP"><a href="#3-计算未调整的用例点UUCP" class="headerlink" title="3.计算未调整的用例点UUCP"></a>3.计算未调整的用例点UUCP</h5><ul><li>UUCP=UAW+UUCW</li><li><img src="/posts/15473/UUCP.png" alt="UUCP" style="zoom:50%;"></li></ul><h5 id="4-计算技术因子TCF"><a href="#4-计算技术因子TCF" class="headerlink" title="4.计算技术因子TCF"></a>4.计算技术因子TCF</h5><ul><li><img src="/posts/15473/TCF计算.png" alt="TCF计算" style="zoom:50%;"></li></ul><h5 id="5-计算调整的用例点UCP"><a href="#5-计算调整的用例点UCP" class="headerlink" title="5.计算调整的用例点UCP"></a>5.计算调整的用例点UCP</h5><ul><li>UCP=UUCP * TCF * ECF</li><li><img src="/posts/15473/UCP.png" alt="UCP" style="zoom:50%;"></li></ul><h5 id="6-计算工作量"><a href="#6-计算工作量" class="headerlink" title="6.计算工作量"></a>6.计算工作量</h5><img src="/posts/15473/工作量.png" alt="工作量" style="zoom:50%;"><h3 id="2-4-类比（自顶向下-估算法"><a href="#2-4-类比（自顶向下-估算法" class="headerlink" title="2.4 类比（自顶向下)估算法"></a>2.4 类比（自顶向下)估算法</h3><h4 id="类比估算-定义："><a href="#类比估算-定义：" class="headerlink" title="类比估算-定义："></a>类比估算-定义：</h4><ul><li>估算人员根据以往的完成类似项目所消耗的总成本（或工作量）</li><li>来推算将要开发的软件的总成本（或工作量)</li><li>是一种自上而下的估算形式</li></ul><h5 id="类比估算-使用情况"><a href="#类比估算-使用情况" class="headerlink" title="类比估算-使用情况"></a>类比估算-使用情况</h5><ul><li>有类似的历史项目数据</li><li>信息不足（例如市场招标）的时候</li><li>要求不是非常精确估算的时候</li></ul><h5 id="类比估算-理论举例"><a href="#类比估算-理论举例" class="headerlink" title="类比估算-理论举例"></a>类比估算-理论举例</h5><img src="/posts/15473/理论举例.png" alt="理论举例" style="zoom:50%;"><h5 id="类比估算-主观判断举例"><a href="#类比估算-主观判断举例" class="headerlink" title="类比估算-主观判断举例"></a>类比估算-主观判断举例</h5><ul><li>证券交易网站<ul><li>需求类似</li><li>历史数据10万</li><li>类比估算10万</li></ul></li></ul><h3 id="2-5-自上而下估算法"><a href="#2-5-自上而下估算法" class="headerlink" title="2.5 自上而下估算法"></a>2.5 自上而下估算法</h3><h4 id="自上而下估算-定义"><a href="#自上而下估算-定义" class="headerlink" title="自上而下估算-定义"></a>自上而下估算-定义</h4><ul><li>利用任务分解图WBS<ul><li>对各个具体工作包进行详细的成本估算</li><li>然后将结果累加起来得出项目总成本</li></ul></li></ul><h4 id="自上而下估算-特点"><a href="#自上而下估算-特点" class="headerlink" title="自上而下估算-特点"></a>自上而下估算-特点</h4><ul><li>相对比较准确<ul><li>他的准确度来源于每个任务的估算情况</li></ul></li><li>花费时间</li></ul><h4 id="自上而下估算举例"><a href="#自上而下估算举例" class="headerlink" title="自上而下估算举例"></a>自上而下估算举例</h4><img src="/posts/15473/自上而下举例.png" alt="自上而下举例" style="zoom:50%;"><h3 id="2-6-三点估算法"><a href="#2-6-三点估算法" class="headerlink" title="2.6 三点估算法"></a>2.6 三点估算法</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>基于任务成本的三种估算值来计算预期成本的方法</li></ul><h4 id="三种估算值"><a href="#三种估算值" class="headerlink" title="三种估算值"></a>三种估算值</h4><ul><li>最可能成本Cm<ul><li>比较现实的估算成本</li></ul></li><li>最乐观成本Co<ul><li>最好情况所得到的估算成本</li></ul></li><li>最悲观成本Cp<ul><li>最差情况所得到的估算成本</li></ul></li></ul><h4 id="三点估算结果"><a href="#三点估算结果" class="headerlink" title="三点估算结果"></a>三点估算结果</h4><img src="/posts/15473/三点估算结果.png" alt="三点估算结果" style="zoom:50%;"><p>举例：</p><img src="/posts/15473/三点估算举例.png" alt="三点估算举例" style="zoom:50%;"><h3 id="2-7-参数估算法"><a href="#2-7-参数估算法" class="headerlink" title="2.7 参数估算法"></a>2.7 参数估算法</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><ul><li>通过项目数据<ul><li>进行回归分析</li><li>得出回归模型</li></ul></li><li>通过参数模型估算（规模）成本的方法</li></ul><h4 id="参数模型-面向LOC驱动的"><a href="#参数模型-面向LOC驱动的" class="headerlink" title="参数模型:面向LOC驱动的"></a>参数模型:面向LOC驱动的</h4><img src="/posts/15473/LOC驱动.png" alt="Loc驱动" style="zoom:50%;"><h4 id="参数模型：面向FP驱动的"><a href="#参数模型：面向FP驱动的" class="headerlink" title="参数模型：面向FP驱动的"></a>参数模型：面向FP驱动的</h4><img src="/posts/15473/FP驱动.png" alt="FP驱动" style="zoom:50%;"><h4 id="参数模型：整体公式"><a href="#参数模型：整体公式" class="headerlink" title="参数模型：整体公式"></a>参数模型：整体公式</h4><img src="/posts/15473/整体公式.png" alt="整体公式" style="zoom:50%;"><h4 id="建议掌握模型"><a href="#建议掌握模型" class="headerlink" title="建议掌握模型"></a>建议掌握模型</h4><ul><li>Walston-Felix模型</li><li>COCOMO模型</li></ul><h5 id="Walston-Felix模型"><a href="#Walston-Felix模型" class="headerlink" title="Walston-Felix模型"></a>Walston-Felix模型</h5><ul><li><img src="/posts/15473/walston公式.png" alt="walston公式" style="zoom:50%;"></li><li><p>举例：</p><ul><li><img src="/posts/15473/walston举例.png" alt="walston举例" style="zoom:50%;"></li></ul></li></ul><h5 id="COCOMO"><a href="#COCOMO" class="headerlink" title="COCOMO"></a>COCOMO</h5><ul><li><p>定义：</p><ul><li>Constructive cost model</li><li>结构化成本模型</li><li>是目前应用最广泛的参数型软件成本估计模型</li><li>由Barry Boehm团队开发</li></ul></li><li><p>分类：</p><ul><li>COCOMO 81</li><li>COCOMO II</li></ul></li><li><p>基本原理：</p><ul><li><img src="/posts/15473/cocomo基本原理.png" alt="cocomo基本原理" style="zoom:50%;"></li></ul></li><li><p>COCOMO 81</p><ul><li>模型级别：<ul><li>基本COCOMO</li><li>中等COCOMO</li><li>高级COCOMO</li></ul></li><li>项目类型：<ul><li>有机:Organic</li><li>嵌入式：Embedded</li><li>半嵌入：Semidetached</li></ul></li></ul></li></ul><h5 id="基本COCOMO-81"><a href="#基本COCOMO-81" class="headerlink" title="基本COCOMO-81"></a>基本COCOMO-81</h5><ul><li><img src="/posts/15473/81.png" alt="81" style="zoom:50%;"></li><li><p>基本COCOMO-81系数表</p><ul><li><img src="/posts/15473/81表.png" alt="81表" style="zoom:50%;"></li></ul></li><li><p>eg：</p><ul><li><img src="/posts/15473/81eg.png" alt="81eg" style="zoom:50%;"></li></ul></li></ul><h5 id="中等COCOMO-81"><a href="#中等COCOMO-81" class="headerlink" title="中等COCOMO-81"></a>中等COCOMO-81</h5><img src="/posts/15473/中等81.png" alt="中等81" style="zoom:50%;"><ul><li>乘法因子的成本驱动属性<ul><li>产品属性</li><li>平台属性</li><li>人员属性</li><li>过程属性</li></ul></li><li>乘法因子<ul><li><img src="/posts/15473/乘法因子.png" alt="乘法因子" style="zoom:50%;"></li><li>举例：<ul><li><img src="/posts/15473/乘法因子举例.png" alt="乘法因子举例" style="zoom:50%;"></li></ul></li></ul></li></ul><h5 id="高级COCOMO"><a href="#高级COCOMO" class="headerlink" title="高级COCOMO"></a>高级COCOMO</h5><ul><li>特点：<ul><li>将项目分解为一系列的子系统或者子模型</li><li>更加精确地调整一个模型的属性</li></ul></li></ul><h3 id="2-8-专家估算法"><a href="#2-8-专家估算法" class="headerlink" title="2.8 专家估算法"></a>2.8 专家估算法</h3><ul><li>由多位专家进行成本估算<ul><li>一个专家可能会有偏见</li><li>最好由多位专家进行估算，取得多个估算值</li><li>最后得出综合的估算值</li></ul></li></ul><h4 id="Deiphi"><a href="#Deiphi" class="headerlink" title="Deiphi"></a>Deiphi</h4><img src="/posts/15473/deiphi.png" alt="deiphi" style="zoom:50%;"><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><img src="/posts/15473/deiphi举例.png" alt="deiphi举例" style="zoom:50%;"><h2 id="3-敏捷估算方法"><a href="#3-敏捷估算方法" class="headerlink" title="3.敏捷估算方法"></a>3.敏捷估算方法</h2><h3 id="3-1-敏捷估算思维"><a href="#3-1-敏捷估算思维" class="headerlink" title="3.1 敏捷估算思维"></a>3.1 敏捷估算思维</h3><ul><li>采用轻量级估算方法快速生成高层级估算</li><li>短期规划可以进行详细的估算</li></ul><h3 id="3-2-Story-point估算方法"><a href="#3-2-Story-point估算方法" class="headerlink" title="3.2 Story point估算方法"></a>3.2 Story point估算方法</h3><ul><li>Story point（故事点）<ul><li>用来度量实现一个story需要付出的工作量的相对估算</li><li><img src="/posts/15473/故事点例子.png" alt="故事点例子" style="zoom:50%;"></li></ul></li></ul><h4 id="常用的两个标准："><a href="#常用的两个标准：" class="headerlink" title="常用的两个标准："></a>常用的两个标准：</h4><img src="/posts/15473/两个标准.png" alt="两个标准" style="zoom:50%;"><h4 id="Fibonacci七个等级："><a href="#Fibonacci七个等级：" class="headerlink" title="Fibonacci七个等级："></a>Fibonacci七个等级：</h4><img src="/posts/15473/七个等级.png" alt="七个等级" style="zoom:50%;"><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><img src="/posts/15473/story举例.png" alt="story举例" style="zoom:50%;"><h4 id="总估算成本（BAC）"><a href="#总估算成本（BAC）" class="headerlink" title="总估算成本（BAC）"></a>总估算成本（BAC）</h4><img src="/posts/15473/BAC.png" alt="BAC" style="zoom:50%;"><h2 id="4-成本预算"><a href="#4-成本预算" class="headerlink" title="4.成本预算"></a>4.成本预算</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><ul><li>成本预算是将项目的总成本按照项目的进度分摊到各个工作单元中去</li></ul><h3 id="4-2-目的："><a href="#4-2-目的：" class="headerlink" title="4.2 目的："></a>4.2 目的：</h3><ul><li>产生成本基线</li></ul><h3 id="4-3-估算（BAC）与预算（BCWS）"><a href="#4-3-估算（BAC）与预算（BCWS）" class="headerlink" title="4.3 估算（BAC）与预算（BCWS）"></a>4.3 估算（BAC）与预算（BCWS）</h3><img src="/posts/15473/BCWS.png" alt="BCWS" style="zoom:50%;"><h3 id="4-4-项目成本预算"><a href="#4-4-项目成本预算" class="headerlink" title="4.4 项目成本预算"></a>4.4 项目成本预算</h3><ul><li>分配项目成本预算包括三种情况：<ul><li>给任务分配资源成本</li><li>给任务分配固定资源成本</li><li>给任务分配固定成本</li></ul></li></ul><h4 id="给任务分配资源成本：常规方法"><a href="#给任务分配资源成本：常规方法" class="headerlink" title="给任务分配资源成本：常规方法"></a>给任务分配资源成本：常规方法</h4><ul><li>与资源的费率相关<ul><li>标准费率</li><li>加班费率</li><li>每次使用费率</li></ul></li></ul><h4 id="给任务分配资源成本：例子"><a href="#给任务分配资源成本：例子" class="headerlink" title="给任务分配资源成本：例子"></a>给任务分配资源成本：例子</h4><img src="/posts/15473/任务分配资源成本.png" style="zoom:50%;"><h4 id="分配固定资源成本"><a href="#分配固定资源成本" class="headerlink" title="分配固定资源成本"></a>分配固定资源成本</h4><ul><li>当一个项目的资源需要固定数量的资金时<ul><li>可以向任务分配固定资源成本</li></ul></li><li>eg：项目中的一个兼职人员成本</li></ul><h4 id="分配固定成本"><a href="#分配固定成本" class="headerlink" title="分配固定成本"></a>分配固定成本</h4><ul><li>有些任务是固定成本的典型的任务</li><li>即，管理者知道某项任务的成本不变</li><li>不管任务的工期有多长，或不管任务使用了哪些资源</li><li>在这种情况下，管理者向任务直接分配成本</li><li>eg：<ul><li>某外包任务、培训任务</li></ul></li></ul><h3 id="4-5-成本基线："><a href="#4-5-成本基线：" class="headerlink" title="4.5 成本基线："></a>4.5 成本基线：</h3><img src="/posts/15473/成本基线.png" alt="成本基线" style="zoom:50%;"><h2 id="5-案例分析"><a href="#5-案例分析" class="headerlink" title="5.案例分析"></a>5.案例分析</h2><h3 id="5-1-医疗信息商务平台成本估算"><a href="#5-1-医疗信息商务平台成本估算" class="headerlink" title="5.1 医疗信息商务平台成本估算"></a>5.1 医疗信息商务平台成本估算</h3><ul><li>工作量成本估算案例<ul><li>自下而上的估算</li><li>用例点估算</li></ul></li></ul><h4 id="MED自下而上的估算"><a href="#MED自下而上的估算" class="headerlink" title="MED自下而上的估算"></a>MED自下而上的估算</h4><img src="/posts/15473/MED.png" alt="MED" style="zoom:50%;"><h5 id="计算开发成本"><a href="#计算开发成本" class="headerlink" title="计算开发成本"></a>计算开发成本</h5><img src="/posts/15473/计算开发成本.png" alt="计算开发成本" style="zoom:50%;"><h5 id="计算直接、间接成本"><a href="#计算直接、间接成本" class="headerlink" title="计算直接、间接成本"></a>计算直接、间接成本</h5><img src="/posts/15473/间接成本.png" alt="间接成本" style="zoom:50%;"><h5 id="计算总估算成本"><a href="#计算总估算成本" class="headerlink" title="计算总估算成本"></a>计算总估算成本</h5><img src="/posts/15473/总估算成本.png" alt="总估算成本" style="zoom:50%;"><h4 id="MED用例点估算"><a href="#MED用例点估算" class="headerlink" title="MED用例点估算"></a>MED用例点估算</h4><img src="/posts/15473/MED用例点.png" alt="MED用例点" style="zoom:50%;"><h4 id="角色-user"><a href="#角色-user" class="headerlink" title="角色;user"></a>角色;user</h4><img src="/posts/15473/角色.png" alt="角色" style="zoom:50%;"><h5 id="计算未调整的角色的权值：UAW"><a href="#计算未调整的角色的权值：UAW" class="headerlink" title="计算未调整的角色的权值：UAW"></a>计算未调整的角色的权值：UAW</h5><img src="/posts/15473/UAW计算.png" alt="UAW计算" style="zoom:50%;"><h5 id="计算未调整的用例权值：UUCW"><a href="#计算未调整的用例权值：UUCW" class="headerlink" title="计算未调整的用例权值：UUCW"></a>计算未调整的用例权值：UUCW</h5><img src="/posts/15473/计算UUCW.png" alt="计算UUCW" style="zoom:50%;"><h5 id="计算未调整的用例点：UUCP"><a href="#计算未调整的用例点：UUCP" class="headerlink" title="计算未调整的用例点：UUCP"></a>计算未调整的用例点：UUCP</h5><img src="/posts/15473/计算UUCP.png" style="zoom:50%;"><h5 id="技术复杂因子TCF"><a href="#技术复杂因子TCF" class="headerlink" title="技术复杂因子TCF"></a>技术复杂因子TCF</h5><img src="/posts/15473/技术复杂因子.png" alt="技术复杂因子" style="zoom:50%;"><h5 id="环境因子ECF"><a href="#环境因子ECF" class="headerlink" title="环境因子ECF"></a>环境因子ECF</h5><img src="/posts/15473/环境因子.png" style="zoom:50%;"><h5 id="计算用例点UCP"><a href="#计算用例点UCP" class="headerlink" title="计算用例点UCP"></a>计算用例点UCP</h5><img src="/posts/15473/计算用例点.png" alt="计算用例点" style="zoom:50%;"><h5 id="规模：Effort"><a href="#规模：Effort" class="headerlink" title="规模：Effort"></a>规模：Effort</h5><img src="/posts/15473/规模.png" alt="规模" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第五章</title>
      <link href="/posts/29800.html"/>
      <url>/posts/29800.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-软件项目任务分解"><a href="#第五章-软件项目任务分解" class="headerlink" title="第五章 软件项目任务分解"></a>第五章 软件项目任务分解</h1><p>类比：</p><ul><li>房屋建筑工程项目的三级分解</li><li>日本某建筑项目任务分解过程<ul><li>标准化过程</li><li>搭积木过程</li></ul></li><li>构建厂里的生产线</li><li>生产线上下来的楼梯</li><li>工厂里贴瓷砖</li><li>工厂里出来的墙体就直接带着墙砖</li><li>卫浴间是整体安装</li></ul><p><strong>强调</strong></p><ul><li><strong>任务分解是项目管理的基础</strong></li></ul><p>本章要点：</p><ul><li>任务分解基本概念</li><li>任务分解方法</li><li>敏捷任务分解</li><li>案例分析</li></ul><h2 id="1-任务分解基本概念"><a href="#1-任务分解基本概念" class="headerlink" title="1.任务分解基本概念"></a>1.任务分解基本概念</h2><h3 id="1-1-任务分解"><a href="#1-1-任务分解" class="headerlink" title="1.1 任务分解"></a>1.1 任务分解</h3><ul><li>任务分解的过程：<ul><li>将一个项目分解为更多的工作细目或者子项目</li><li>是项目变得更小</li><li>更以管理</li><li>更易操作</li></ul></li><li>任务分解的结果：<ul><li>WBS（work breakdown structure）</li><li>任务分解结构</li></ul></li></ul><h3 id="1-2-任务需求分解"><a href="#1-2-任务需求分解" class="headerlink" title="1.2 任务需求分解"></a>1.2 任务需求分解</h3><ul><li>需求拆分以获取范围灵活性</li></ul><h3 id="1-3-WBS"><a href="#1-3-WBS" class="headerlink" title="1.3 WBS"></a>1.3 WBS</h3><ul><li>WBS是对项目由粗到细的分解过程</li><li>面向交付成果的</li><li>WBS组织并定义了整个项目范围</li></ul><h3 id="1-4-工作包-Work-packages"><a href="#1-4-工作包-Work-packages" class="headerlink" title="1.4 工作包 Work packages"></a>1.4 工作包 Work packages</h3><ul><li>WBS的最低层次的可交付成果</li><li>工作包应由唯一主体负责</li></ul><h4 id="组织结构图（图表）形式的WBS"><a href="#组织结构图（图表）形式的WBS" class="headerlink" title="组织结构图（图表）形式的WBS"></a>组织结构图（图表）形式的WBS</h4><img src="/posts/29800/图表WBS.png" alt="图表WBS" style="zoom:50%;"><h4 id="提纲（清单）式的WBS"><a href="#提纲（清单）式的WBS" class="headerlink" title="提纲（清单）式的WBS"></a>提纲（清单）式的WBS</h4><img src="/posts/29800/提纲WBS.png" alt="提纲WBS" style="zoom:50%;"><h4 id="WBS字典："><a href="#WBS字典：" class="headerlink" title="WBS字典："></a>WBS字典：</h4><img src="/posts/29800/WBS字典.png" alt="WBS字典" style="zoom:50%;"><h2 id="2-任务分解方法"><a href="#2-任务分解方法" class="headerlink" title="2.任务分解方法"></a>2.任务分解方法</h2><ul><li>类比</li><li>模版参照</li><li>自上而下</li><li>自下而上</li></ul><h3 id="2-1-模板参照"><a href="#2-1-模板参照" class="headerlink" title="2.1 模板参照"></a>2.1 模板参照</h3><img src="/posts/29800/模版参照.png" alt="模版参照" style="zoom:50%;"><h3 id="2-2-自上而下"><a href="#2-2-自上而下" class="headerlink" title="2.2 自上而下"></a>2.2 自上而下</h3><img src="/posts/29800/自上而下.png" alt="自上而下" style="zoom:50%;"><h3 id="2-3-自上而下"><a href="#2-3-自上而下" class="headerlink" title="2.3 自上而下"></a>2.3 自上而下</h3><img src="/posts/29800/自下而上.png" alt="自下而上" style="zoom:50%;"><h3 id="2-4-WBS任务分解建议"><a href="#2-4-WBS任务分解建议" class="headerlink" title="2.4 WBS任务分解建议"></a>2.4 WBS任务分解建议</h3><ul><li>最低层是可控的和可管理的，但是不必要的过细</li><li>每个Work package必须有一个提交物</li><li>定义任务完成的标准</li><li>有利于责任分配</li><li>推荐任务分解到40小时以内，敏捷项目分解到小时</li></ul><h2 id="3-敏捷项目的任务分解"><a href="#3-敏捷项目的任务分解" class="headerlink" title="3. 敏捷项目的任务分解"></a>3. 敏捷项目的任务分解</h2><ul><li><p>基于story的分解</p><ul><li>Epics</li><li>Epics break down</li></ul><img src="/posts/29800/敏捷任务分解.png" alt="敏捷任务分解" style="zoom:50%;"></li></ul><h3 id="3-1-敏捷任务分解输出"><a href="#3-1-敏捷任务分解输出" class="headerlink" title="3.1 敏捷任务分解输出"></a>3.1 敏捷任务分解输出</h3><ul><li>product (Sprint)backlog<ul><li>逐步完善</li></ul></li></ul><h2 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4. 案例分析"></a>4. 案例分析</h2><h3 id="4-1-医疗信息商务平台"><a href="#4-1-医疗信息商务平台" class="headerlink" title="4.1 医疗信息商务平台"></a>4.1 医疗信息商务平台</h3><img src="/posts/29800/医疗信息.png" alt="医疗信息" style="zoom:50%;"><h3 id="4-2-MED-任务分解结果"><a href="#4-2-MED-任务分解结果" class="headerlink" title="4.2 MED:任务分解结果"></a>4.2 MED:任务分解结果</h3><img src="/posts/29800/MED.png" alt="MED" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第四章</title>
      <link href="/posts/46806.html"/>
      <url>/posts/46806.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-软件项目需求管理"><a href="#第四章-软件项目需求管理" class="headerlink" title="第四章 软件项目需求管理"></a>第四章 软件项目需求管理</h1><h3 id="需求管理中的问题举例"><a href="#需求管理中的问题举例" class="headerlink" title="需求管理中的问题举例"></a>需求管理中的问题举例</h3><ul><li>需求的隐含错误</li><li>用户不断增加需求、变更需求</li></ul><h3 id="项目失败的原因分析"><a href="#项目失败的原因分析" class="headerlink" title="项目失败的原因分析"></a>项目失败的原因分析</h3><ul><li>不充分的需求规范</li><li>需求的改变</li><li>缺乏系统工程师</li><li>缺乏了解软件特性的经理人</li><li>缺乏合格的项目经理</li><li>缺乏软件工程师</li><li>固定价合同</li><li>系统集成阶段，交流与沟通不充分</li><li>团队缺乏经验</li><li>缺乏应用领域专家</li></ul><h3 id="软件需求定义"><a href="#软件需求定义" class="headerlink" title="软件需求定义"></a>软件需求定义</h3><ul><li>需求：<ul><li>是指用户对软件的功能的性能的要求</li></ul></li></ul><p>本章要点：</p><ul><li>软件需求管理过程</li><li>传统需求建模方法</li><li>敏捷需求建模方法</li><li>案例分析</li></ul><h2 id="1-软件需求管理的过程"><a href="#1-软件需求管理的过程" class="headerlink" title="1.软件需求管理的过程"></a>1.软件需求管理的过程</h2><img src="/posts/46806/管理过程.png" alt="管理过程" style="zoom:50%;"><h3 id="1-1-需求获取"><a href="#1-1-需求获取" class="headerlink" title="1.1 需求获取"></a>1.1 需求获取</h3><h4 id="需求获取的方法："><a href="#需求获取的方法：" class="headerlink" title="需求获取的方法："></a>需求获取的方法：</h4><ul><li>用户要求</li><li>软件需求</li></ul><h3 id="1-2-需求分析"><a href="#1-2-需求分析" class="headerlink" title="1.2 需求分析"></a>1.2 需求分析</h3><ul><li>需求分析<ul><li>是为最终用户所看到的系统建立的一个概念模型</li><li>是对需求的抽象描述</li></ul></li><li>需求分析模型<ul><li><img src="/posts/46806/需求分析模型.png" alt="需求分析模型" style="zoom:50%;"></li></ul></li></ul><h3 id="1-3-需求规格编写"><a href="#1-3-需求规格编写" class="headerlink" title="1.3 需求规格编写"></a>1.3 需求规格编写</h3><ul><li>需求分析工作完成的一个基本标志<ul><li>是形成了一份完整的、规范的需求规格说明书</li></ul></li></ul><h3 id="1-4-需求验证"><a href="#1-4-需求验证" class="headerlink" title="1.4 需求验证"></a>1.4 需求验证</h3><ul><li>需求是正确的吗</li><li>需求是一致的吗</li><li>需求是完全的吗</li><li>需求是实际可行的吗</li><li>需求是必要的吗</li><li>需求是可检验的吗</li><li>需求是可跟踪的吗</li><li>最后的签字</li></ul><h3 id="1-5-需求总在变化"><a href="#1-5-需求总在变化" class="headerlink" title="1.5 需求总在变化"></a>1.5 需求总在变化</h3><h3 id="1-6-需求变更管理"><a href="#1-6-需求变更管理" class="headerlink" title="1.6 需求变更管理"></a>1.6 需求变更管理</h3><ul><li>确定需求变更控制过程</li><li>建立变更控制委员会SCCB</li><li>进行需求变更影响分析</li><li>跟踪所有受需求变更影响的工作产品</li><li>建立需求基准版本和需求控制版本文档</li><li>维护需求变更的历史记录</li><li>跟踪每项需求的状态</li><li>衡量需求稳定性</li></ul><h3 id="1-7-需求变更控制流程"><a href="#1-7-需求变更控制流程" class="headerlink" title="1.7 需求变更控制流程"></a>1.7 需求变更控制流程</h3><img src="/posts/46806/控制流程.png" alt="控制流程" style="zoom:50%;"><h2 id="2-需求建模的基本方法介绍"><a href="#2-需求建模的基本方法介绍" class="headerlink" title="2.需求建模的基本方法介绍"></a>2.需求建模的基本方法介绍</h2><ul><li>传统方法：<ul><li>原型方法</li><li>基于数据流建模</li><li>基于UML建模</li></ul></li><li>敏捷方法</li></ul><h3 id="2-1-原型方法"><a href="#2-1-原型方法" class="headerlink" title="2.1 原型方法"></a>2.1 原型方法</h3><img src="/posts/46806/原型方法.png" alt="原型方法" style="zoom:50%;"><h3 id="2-2-基于数据流-结构化分析方法"><a href="#2-2-基于数据流-结构化分析方法" class="headerlink" title="2.2 基于数据流-结构化分析方法"></a>2.2 基于数据流-结构化分析方法</h3><ul><li>20世纪70年发展起来的面向数据流的方法</li><li>是一种自顶向下逐步求精的分析方法</li><li>根据软件内部数据传递、变换的关系进行分析的</li></ul><h4 id="基于数据流的技术："><a href="#基于数据流的技术：" class="headerlink" title="基于数据流的技术："></a>基于数据流的技术：</h4><ul><li>数据流图DFD</li><li>数据字典DD</li><li>系统流程图</li></ul><h4 id="描述银行取款过程的数据流图"><a href="#描述银行取款过程的数据流图" class="headerlink" title="描述银行取款过程的数据流图"></a>描述银行取款过程的数据流图</h4><img src="/posts/46806/数据流图1.png" alt="数据流图1" style="zoom:50%;"><h4 id="学生管理系统-数据字典-数据流"><a href="#学生管理系统-数据字典-数据流" class="headerlink" title="学生管理系统-数据字典-数据流"></a>学生管理系统-数据字典-数据流</h4><img src="/posts/46806/学生管理系统.png" alt="学生管理系统" style="zoom:50%;"><h3 id="2-3-基于UML方法"><a href="#2-3-基于UML方法" class="headerlink" title="2.3 基于UML方法"></a>2.3 基于UML方法</h3><ul><li>基于面向对象的情景分析方法</li><li>从用户角度出发考虑的功能需求</li><li>用例是系统向用户提供一个有价值的结果的某项功能</li></ul><h4 id="UML需求视图"><a href="#UML需求视图" class="headerlink" title="UML需求视图"></a>UML需求视图</h4><ul><li>用例视图Use case Diagram</li><li>顺序图 Sequence Diagram</li><li>状态图 State Diagram</li><li>活动图 Activity Diagram</li></ul><h4 id="基于UML方法综述"><a href="#基于UML方法综述" class="headerlink" title="基于UML方法综述"></a>基于UML方法综述</h4><ul><li>识别出系统的Actor</li><li>描述需要的Use case</li><li>实现用例视图</li><li>实现顺序视图、活动视图、状态视图等</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第三章</title>
      <link href="/posts/55319.html"/>
      <url>/posts/55319.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-软件生存期模型"><a href="#第三章-软件生存期模型" class="headerlink" title="第三章 软件生存期模型"></a>第三章 软件生存期模型</h1><p>本章要点：</p><ul><li>生存期模型选择</li><li>预测模型</li><li>迭代模型</li><li>增量模型</li><li>敏捷模型</li><li>混合模型</li><li>案例分析</li></ul><h2 id="1-生存期模型选择"><a href="#1-生存期模型选择" class="headerlink" title="1.生存期模型选择"></a>1.生存期模型选择</h2><h3 id="1-1-软件开发模型变迁"><a href="#1-1-软件开发模型变迁" class="headerlink" title="1.1 软件开发模型变迁"></a>1.1 软件开发模型变迁</h3><ul><li>作坊式</li><li>过程控制</li><li>敏捷</li><li>DevOps</li></ul><h3 id="1-2-项目生存期选择"><a href="#1-2-项目生存期选择" class="headerlink" title="1.2 项目生存期选择"></a>1.2 项目生存期选择</h3><ul><li>预测型<ul><li>提前进行大量的计划工作</li><li>然后一次性执行</li><li>执行是一个连续的过程</li></ul></li><li>迭代型<ul><li>允许对未完成的工作进行反馈</li><li>从而改进和修改该工作</li></ul></li><li>增量型：<ul><li>向客户提供各个已完成的，可能立即使用的可交付成果</li></ul></li><li>敏捷型：<ul><li>既有迭代、也有增量</li><li>便于完善工作，频繁交付</li></ul></li></ul><h2 id="2-预测模型"><a href="#2-预测模型" class="headerlink" title="2. 预测模型"></a>2. 预测模型</h2><img src="/posts/55319/预测模型.png" alt="预测模型" style="zoom:50%;"><h3 id="2-1-预测型-模型"><a href="#2-1-预测型-模型" class="headerlink" title="2.1 预测型-模型"></a>2.1 预测型-模型</h3><ul><li>瀑布模型</li><li>V模型</li></ul><h3 id="2-2-瀑布模型"><a href="#2-2-瀑布模型" class="headerlink" title="2.2 瀑布模型"></a>2.2 瀑布模型</h3><img src="/posts/55319/瀑布模型.png" alt="瀑布模型" style="zoom:50%;"><h4 id="适合瀑布模型的项目特征："><a href="#适合瀑布模型的项目特征：" class="headerlink" title="适合瀑布模型的项目特征："></a>适合瀑布模型的项目特征：</h4><ul><li>需求很明确</li><li>方案很明确</li><li>类似项目 ：短期项目等</li></ul><h3 id="2-3-V模型"><a href="#2-3-V模型" class="headerlink" title="2.3 V模型"></a>2.3 V模型</h3><img src="/posts/55319/v模型.png" alt="v模型" style="zoom:50%;"><h4 id="适合v模型的项目特征"><a href="#适合v模型的项目特征" class="headerlink" title="适合v模型的项目特征"></a>适合v模型的项目特征</h4><ul><li>需求很明确</li><li>方案很明确</li><li>类似项目 系统性能、安全等有严格要求等</li></ul><h2 id="3-迭代模型"><a href="#3-迭代模型" class="headerlink" title="3.迭代模型"></a>3.迭代模型</h2><img src="/posts/55319/迭代模型.png" alt="迭代模型" style="zoom:50%;"><h3 id="3-1-OR-原型模型"><a href="#3-1-OR-原型模型" class="headerlink" title="3.1 OR 原型模型"></a>3.1 OR 原型模型</h3><img src="/posts/55319/原型模型.png" alt="原型模型" style="zoom:50%;"><h3 id="3-2-适合迭代模型的项目特征"><a href="#3-2-适合迭代模型的项目特征" class="headerlink" title="3.2 适合迭代模型的项目特征"></a>3.2 适合迭代模型的项目特征</h3><ul><li><p>需求不明确</p></li><li><p>项目复杂性高</p></li><li><p>项目变更频繁</p></li></ul><h2 id="4-增量模型"><a href="#4-增量模型" class="headerlink" title="4.增量模型"></a>4.增量模型</h2><img src="/posts/55319/增量模型.png" alt="增量模型" style="zoom:50%;"><h3 id="4-1-渐进式阶段模型"><a href="#4-1-渐进式阶段模型" class="headerlink" title="4.1 渐进式阶段模型"></a>4.1 渐进式阶段模型</h3><img src="/posts/55319/渐进式.png" alt="渐进式" style="zoom:50%;"><h3 id="4-2-增量模型的优点"><a href="#4-2-增量模型的优点" class="headerlink" title="4.2 增量模型的优点"></a>4.2 增量模型的优点</h3><ul><li>阶段式提交一个可运行的产品</li><li>关键的功能更早出现</li><li>早期预警问题，避免缺陷蔓延</li><li>阶段性完成可以降低估计失误</li></ul><h2 id="5-敏捷模型"><a href="#5-敏捷模型" class="headerlink" title="5.敏捷模型"></a>5.敏捷模型</h2><h3 id="5-1-《敏捷宣言》价值观、原则和通用实践之间的关系"><a href="#5-1-《敏捷宣言》价值观、原则和通用实践之间的关系" class="headerlink" title="5.1 《敏捷宣言》价值观、原则和通用实践之间的关系"></a>5.1 《敏捷宣言》价值观、原则和通用实践之间的关系</h3><img src="/posts/55319/敏捷宣言关系.png" alt="敏捷宣言关系" style="zoom:50%;"><h3 id="5-2-敏捷与传统模型的区别"><a href="#5-2-敏捷与传统模型的区别" class="headerlink" title="5.2 敏捷与传统模型的区别"></a>5.2 敏捷与传统模型的区别</h3><img src="/posts/55319/敏捷区别.png" alt="敏捷区别" style="zoom:50%;"><h3 id="5-3-敏捷方法"><a href="#5-3-敏捷方法" class="headerlink" title="5.3 敏捷方法"></a>5.3 敏捷方法</h3><ul><li>敏捷方法：<ul><li>是一个囊括了各种框架和方法的涵盖性术语</li></ul></li></ul><h3 id="5-4-Scrum模型"><a href="#5-4-Scrum模型" class="headerlink" title="5.4 Scrum模型"></a>5.4 Scrum模型</h3><ul><li>1990年代初，肯施瓦伯在其公司使用了一种方法：<ul><li>Advanced Development Methods</li><li>先进开发方法</li></ul></li><li>这种方法后来发展为Scrum</li><li>敏捷模型的代表</li></ul><h3 id="5-5-迭代开发过程"><a href="#5-5-迭代开发过程" class="headerlink" title="5.5 迭代开发过程"></a>5.5 迭代开发过程</h3><img src="/posts/55319/迭代开发过程.png" alt="迭代开发过程" style="zoom:50%;"><h3 id="5-6-XP极限编程模型"><a href="#5-6-XP极限编程模型" class="headerlink" title="5.6 XP极限编程模型"></a>5.6 XP极限编程模型</h3><ul><li>Extreme Programming</li><li>是由Kent Beck提出的<ul><li>一套针对业务需求和软件开发实践的规则</li></ul></li></ul><h3 id="5-7-精益-Lean"><a href="#5-7-精益-Lean" class="headerlink" title="5.7 精益 Lean"></a>5.7 精益 Lean</h3><ul><li>精益模式<ul><li>提倡持续不断地改进</li><li>减少流程中的浪费</li></ul></li></ul><h3 id="5-8-持续交付"><a href="#5-8-持续交付" class="headerlink" title="5.8 持续交付"></a>5.8 持续交付</h3><ul><li>持续集成</li><li>持续部署</li><li>持续交付</li></ul><h3 id="5-9-DevOps"><a href="#5-9-DevOps" class="headerlink" title="5.9 DevOps"></a>5.9 DevOps</h3><ul><li>Development和Operation的组合</li><li>全程敏捷思维</li><li>开发与运维工作紧密合作</li><li>融合一系列基本原则和实践的方法论</li><li>是<ul><li>一种方法论</li><li>是一组过程、方法与系统的统称</li><li>用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合</li></ul></li></ul><h3 id="5-10-DevCloud"><a href="#5-10-DevCloud" class="headerlink" title="5.10 DevCloud"></a>5.10 DevCloud</h3><ul><li>一站式云端DevOps</li></ul><h2 id="6-混合模型"><a href="#6-混合模型" class="headerlink" title="6.混合模型"></a>6.混合模型</h2><img src="/posts/55319/混合模型.png" alt="混合模型" style="zoom:50%;"><h3 id="6-1-MED生存期模型-敏捷模型"><a href="#6-1-MED生存期模型-敏捷模型" class="headerlink" title="6.1 MED生存期模型-敏捷模型"></a>6.1 MED生存期模型-敏捷模型</h3><img src="/posts/55319/MED.png" alt="MED" style="zoom:50%;"><h3 id="6-2-四个迭代"><a href="#6-2-四个迭代" class="headerlink" title="6.2 四个迭代"></a>6.2 四个迭代</h3><img src="/posts/55319/四个迭代.png" alt="四个迭代" style="zoom:50%;"><h3 id="6-3-迭代模型"><a href="#6-3-迭代模型" class="headerlink" title="6.3 迭代模型"></a>6.3 迭代模型</h3><img src="/posts/55319/迭代模型1.png" alt="迭代模型1" style="zoom:50%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第二章</title>
      <link href="/posts/54382.html"/>
      <url>/posts/54382.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-软件项目确立"><a href="#第二章-软件项目确立" class="headerlink" title="第二章 软件项目确立"></a>第二章 软件项目确立</h1><p>本章要点：</p><ul><li>项目立项</li><li>项目招投标</li><li>项目章程</li><li>案例总结</li></ul><h2 id="1-项目立项"><a href="#1-项目立项" class="headerlink" title="1.项目立项"></a>1.项目立项</h2><h3 id="1-1-项目启动背景"><a href="#1-1-项目启动背景" class="headerlink" title="1.1 项目启动背景"></a>1.1 项目启动背景</h3><ul><li>符合法规、法律或社会要求</li><li>满足相关方的要求或需求</li><li>创造、改进或修复产品、过程或服务</li><li>执行、变更业务或技术战略</li></ul><h3 id="1-2-立项流程"><a href="#1-2-立项流程" class="headerlink" title="1.2 立项流程"></a>1.2 立项流程</h3><ul><li>开始</li><li>识别发起的项目</li><li>论证项目</li><li>申请项目</li><li>申请审核<ul><li>通过<ul><li>确定项目立项</li></ul></li><li>不通过<ul><li>取消项目立项</li></ul></li><li>立项审查报告</li></ul></li><li>结束</li></ul><h3 id="1-3-项目立项"><a href="#1-3-项目立项" class="headerlink" title="1.3 项目立项"></a>1.3 项目立项</h3><ul><li>定义：<ul><li>明确<ul><li>项目的目标、时间表、</li><li>项目使用的资源和经费</li></ul></li><li>而且得到执行该项目的项目经理和项目发起人的认可</li></ul></li><li>包含：<ul><li>目标</li><li>费用</li><li>时间</li></ul></li></ul><h2 id="2-项目招投标"><a href="#2-项目招投标" class="headerlink" title="2. 项目招投标"></a>2. 项目招投标</h2><h3 id="2-1-项目招投标过程"><a href="#2-1-项目招投标过程" class="headerlink" title="2.1 项目招投标过程"></a>2.1 项目招投标过程</h3><ul><li>甲方招标书定义</li><li>乙方项目分析</li><li>招标与竞标</li><li>合同签署</li></ul><h2 id="3-项目章程"><a href="#3-项目章程" class="headerlink" title="3.项目章程"></a>3.项目章程</h2><h3 id="3-1-项目章程定义"><a href="#3-1-项目章程定义" class="headerlink" title="3.1 项目章程定义"></a>3.1 项目章程定义</h3><ul><li>Project Charter</li><li>确定项目存在的文件<ul><li>包括对项目的确认</li><li>对项目经理的授权</li><li>和项目目标的概述等</li></ul></li></ul><h3 id="3-2-敏捷项目章程"><a href="#3-2-敏捷项目章程" class="headerlink" title="3.2 敏捷项目章程"></a>3.2 敏捷项目章程</h3><ul><li>基本要素：<ul><li>项目目标</li><li>发布标准</li><li>预期的工作流</li></ul></li></ul><h3 id="3-3-项目经理的职责"><a href="#3-3-项目经理的职责" class="headerlink" title="3.3 项目经理的职责"></a>3.3 项目经理的职责</h3><ul><li>项目经理是领导团队实现项目目标的个人</li><li>敏捷强调：<ul><li>仆人式领导方式</li></ul></li></ul><h3 id="3-4-项目经理的能力"><a href="#3-4-项目经理的能力" class="headerlink" title="3.4 项目经理的能力"></a>3.4 项目经理的能力</h3><ul><li>PMI人才三角<ul><li>技术项目管理</li><li>领导力</li><li>战略和商务管理</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理-第一章</title>
      <link href="/posts/17428.html"/>
      <url>/posts/17428.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-软件项目管理概述"><a href="#第一章-软件项目管理概述" class="headerlink" title="第一章 软件项目管理概述"></a>第一章 软件项目管理概述</h1><p>本章要点：</p><ul><li>项目与软件项目</li><li>项目管理与软件项目管理</li><li>PMBOK与软件项目管理体系</li><li>敏捷项目管理</li><li>软件项目管理过程</li></ul><h2 id="1-项目与软件项目"><a href="#1-项目与软件项目" class="headerlink" title="1.项目与软件项目"></a>1.项目与软件项目</h2><h3 id="项目的定义"><a href="#项目的定义" class="headerlink" title="项目的定义"></a>项目的定义</h3><p>项目project</p><ul><li>是为了<ul><li>创造一个 <strong>唯一</strong> 的产品</li><li>或提供一个唯一的服务<ul><li>而进行的 <strong>临时性</strong> 的努力</li></ul></li></ul></li></ul><h3 id="项目的特征"><a href="#项目的特征" class="headerlink" title="项目的特征"></a>项目的特征</h3><ul><li>有明确的目标</li><li>项目之间的活动具有相关性</li><li>限定的周期</li><li>有独特性</li><li>资源成本的约束性</li><li>项目的不确定性</li></ul><h3 id="项目与日常运作"><a href="#项目与日常运作" class="headerlink" title="项目与日常运作"></a>项目与日常运作</h3><ul><li>项目：<ul><li>野餐活动</li><li>集体婚礼</li><li>开发操作系统</li><li>神舟飞船计划</li></ul></li><li>日常运作<ul><li>上课</li><li>社区保安</li><li>每天的卫生保洁</li></ul></li></ul><h3 id="项目集-programs与项目-project"><a href="#项目集-programs与项目-project" class="headerlink" title="项目集 programs与项目 project"></a>项目集 programs与项目 project</h3><ul><li><p>项目组合管理 portfolio</p><ul><li><p>eg：承办奥运会</p></li><li><p>项目集 Programs</p><ul><li><p>eg：奥运体育馆建设</p></li><li><p>项目 project</p><ul><li><p>eg：游泳馆建设</p></li><li><p>子项目</p><ul><li>eg：游泳池建造</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="软件项目的特殊性"><a href="#软件项目的特殊性" class="headerlink" title="软件项目的特殊性"></a>软件项目的特殊性</h3><ul><li>逻辑实体</li><li>相互作用的系统</li><li>渐进明细</li><li>变更</li></ul><h2 id="2-项目管理与软件项目管理"><a href="#2-项目管理与软件项目管理" class="headerlink" title="2.项目管理与软件项目管理"></a>2.项目管理与软件项目管理</h2><h3 id="2-1-项目管理背景"><a href="#2-1-项目管理背景" class="headerlink" title="2.1 项目管理背景"></a>2.1 项目管理背景</h3><ul><li>生活中的小项目：<ul><li>生日聚会</li><li>野餐活动</li><li>集体婚礼</li></ul></li><li>工作中的大项目<ul><li>微软的操作系统</li><li>阿波罗计划</li><li>神舟飞船计划</li></ul></li></ul><h3 id="2-2-项目管理定义"><a href="#2-2-项目管理定义" class="headerlink" title="2.2 项目管理定义"></a>2.2 项目管理定义</h3><ul><li>项目管理<ul><li>是一系列的 伴随着项目的进行而进行的</li><li>目的是 为了确保项目能达到期望的结果的</li><li>一系列管理行为</li></ul></li></ul><h3 id="2-3-软件项目管理"><a href="#2-3-软件项目管理" class="headerlink" title="2.3 软件项目管理"></a>2.3 软件项目管理</h3><ul><li>是软件工程组成部分</li><li>确保软件项目满足预算、成本等约束<ul><li>提交高质量软件产品</li></ul></li></ul><h2 id="3-PMBOK与软件项目管理体系"><a href="#3-PMBOK与软件项目管理体系" class="headerlink" title="3.PMBOK与软件项目管理体系"></a>3.PMBOK与软件项目管理体系</h2><h3 id="3-1-PMBOK"><a href="#3-1-PMBOK" class="headerlink" title="3.1 PMBOK"></a>3.1 PMBOK</h3><ul><li>A guide to the Project management Body Of Knowledge</li><li>项目管理知识体系指南</li></ul><h4 id="PMI："><a href="#PMI：" class="headerlink" title="PMI："></a>PMI：</h4><ul><li>对项目管理所需的知识、技能和工具进行的概括性描述</li></ul><h3 id="3-2-PMBOK体系图"><a href="#3-2-PMBOK体系图" class="headerlink" title="3.2 PMBOK体系图"></a>3.2 PMBOK体系图</h3><img src="/posts/17428/体系图.png" alt="体系图" style="zoom:50%;"><h3 id="3-3-项目管理五大过程组"><a href="#3-3-项目管理五大过程组" class="headerlink" title="3.3 项目管理五大过程组"></a>3.3 项目管理五大过程组</h3><ul><li><img src="/posts/17428/五大过程.png" alt="五大过程" style="zoom:50%;"></li></ul><h2 id="4-敏捷项目管理"><a href="#4-敏捷项目管理" class="headerlink" title="4.敏捷项目管理"></a>4.敏捷项目管理</h2><h3 id="4-1-软件项目很特殊"><a href="#4-1-软件项目很特殊" class="headerlink" title="4.1 软件项目很特殊"></a>4.1 软件项目很特殊</h3><ul><li>脑力成果</li><li>唯一性（一次性）</li><li>依赖用户需求</li></ul><h3 id="4-2-传统软件开发面临挑战"><a href="#4-2-传统软件开发面临挑战" class="headerlink" title="4.2 传统软件开发面临挑战"></a>4.2 传统软件开发面临挑战</h3><ul><li>低质量</li><li>特性无法被测试</li><li>使用性与用户经历不好</li><li>花费过高</li><li>团队不交流合作</li><li>过多新手，缺乏技术</li><li>过多文件</li><li>不能很好维持</li></ul><h3 id="4-3-敏捷模型-Agile-Development"><a href="#4-3-敏捷模型-Agile-Development" class="headerlink" title="4.3 敏捷模型 Agile Development"></a>4.3 敏捷模型 Agile Development</h3><ul><li>敏捷组织提出的一个灵活开发方法</li><li>应对迅速变化需求的快速软件开发方法</li><li>是一种迭代、循序渐进的开发方法</li></ul><h3 id="4-4-敏捷开发过程"><a href="#4-4-敏捷开发过程" class="headerlink" title="4.4 敏捷开发过程"></a>4.4 敏捷开发过程</h3><ul><li>一开始都不知道细节</li><li>慢慢改进</li></ul><h3 id="4-5-敏捷宣言-四价值"><a href="#4-5-敏捷宣言-四价值" class="headerlink" title="4.5 敏捷宣言 四价值"></a>4.5 敏捷宣言 四价值</h3><ul><li>个体和互动<ul><li>高于 流程和工具</li></ul></li><li>可工作的软件<ul><li>高于 详尽的文档</li></ul></li><li>客户合作<ul><li>高于 合同谈判</li></ul></li><li>响应变化<ul><li>高于 遵循计划</li></ul></li></ul><h3 id="4-6-敏捷原则-Principles"><a href="#4-6-敏捷原则-Principles" class="headerlink" title="4.6 敏捷原则 Principles"></a>4.6 敏捷原则 Principles</h3><ul><li>我们最先要做的是通过尽早地、持续交付有价值的软件来使客户满意</li><li>即使到了开发后期，也欢迎改变需求。敏捷过程利用适应变化来为客户创造竞争优势</li><li>经常性地交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好</li><li>在整个项目开发期间，业务人员和开发人员可以的话尽可能在一起工作</li></ul><h3 id="4-7-《敏捷宣言》价值观、原则和通用实践之间的关系"><a href="#4-7-《敏捷宣言》价值观、原则和通用实践之间的关系" class="headerlink" title="4.7 《敏捷宣言》价值观、原则和通用实践之间的关系"></a>4.7 《敏捷宣言》价值观、原则和通用实践之间的关系</h3><ul><li>敏捷是一种思维模式</li><li>它由《敏捷宣言》的价值观所界定</li><li>受《敏捷宣言》原则指导</li><li>并通过各种实践实现</li></ul><h2 id="5-软件项目管理过程"><a href="#5-软件项目管理过程" class="headerlink" title="5.软件项目管理过程"></a>5.软件项目管理过程</h2><h3 id="5-1-项目管理过程"><a href="#5-1-项目管理过程" class="headerlink" title="5.1 项目管理过程"></a>5.1 项目管理过程</h3><ul><li>项目初始</li><li>项目计划</li><li>项目执行控制</li><li>项目结束</li></ul><h3 id="5-2-软件项目管理过程"><a href="#5-2-软件项目管理过程" class="headerlink" title="5.2 软件项目管理过程"></a>5.2 软件项目管理过程</h3><ul><li>项目初始</li><li>项目计划</li><li>项目执行控制</li><li>项目结束</li></ul><h4 id="5-2-1-项目初始"><a href="#5-2-1-项目初始" class="headerlink" title="5.2.1 项目初始"></a>5.2.1 项目初始</h4><ul><li>项目确立</li><li>生存期</li></ul><h4 id="5-2-2-项目计划"><a href="#5-2-2-项目计划" class="headerlink" title="5.2.2 项目计划"></a>5.2.2 项目计划</h4><ul><li>范围计划</li><li>成本计划</li><li>进度计划</li><li>质量计划</li><li>配置管理计划</li><li>团队计划</li><li>风险计划</li><li>合同计划</li></ul><h4 id="5-2-3-项目执行控制"><a href="#5-2-3-项目执行控制" class="headerlink" title="5.2.3 项目执行控制"></a>5.2.3 项目执行控制</h4><ul><li>集成计划执行控制</li><li>核心计划执行控制</li><li>辅助计划执行控制</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter的第一个实验</title>
      <link href="/posts/12105.html"/>
      <url>/posts/12105.html</url>
      
        <content type="html"><![CDATA[<p>首先打开jmeter文件夹内bin目录下的 <code>jmeter.bat</code>  从而运行jmeter程序</p><p>再在jmeter中 <code>open file</code>,打开实验要运行的文件， <code>first test plan</code></p><p><img src="/posts/12105/1.png" alt="1"></p><p><code>comment</code>：注释</p><p>刚创立test plan时内部是空的，在设置完名称和注释之后先记得把这个test plan保存</p><p>保存完后，为了利用这个test plan做些东西，就要 add something</p><p>即：</p><ul><li>右键first test plan</li><li>add</li><li>Threads（Users）</li><li>Thread Group<ul><li>即成功添加第一个线程组</li></ul></li></ul><p>但是添加完这个线程组之后还是做不了什么事情，要再在 <code>thread group</code>里 添加一些设置</p><ul><li><p>点击thread group:</p><p><img src="/posts/12105/2.png" alt="2"></p></li><li><p><code>Number of Threads(users)</code>:</p><ul><li>即需要多少线程 或者可以说虚拟用户</li></ul></li><li><p><code>Ramp-up period</code>：</p><ul><li>即这些用户用多久时间生成</li></ul></li><li><p><code>Loop count</code>:</p><ul><li>即循环次数</li></ul></li></ul><p>因为这个test plan意图访问web系统的界面类</p><p>我们不直接对界面进行操作，而是对接口发送请求</p><p>在jmeter中，所有的请求要发出去，都要用到 <code>Add</code>里面的 <code>Sampler</code>(采样器)  </p><p>其中有许多采样器，我们这个实验中使用 <code>Http request</code></p><p>其中设置好名称和网址，如图：</p><p><img src="/posts/12105/3.png" alt="3"></p><ul><li><code>port number</code><ul><li>端口号<ul><li>如果使用默认端口，可以不填</li></ul></li></ul></li><li><code>path</code><ul><li>路径</li><li>因为这里是要访问首页，所以不需要填路径</li></ul></li></ul><p>经过以上操作，我们已经有了一个可以发请求的采样器，现在可以来跑一下。</p><p>但是虽然这时候已经可以跑了，但是结果我们看不到</p><p>因此，需要增加 <code>listener</code>来查看结果</p><ul><li>右键Thread Group</li><li><code>add</code></li><li><code>listener</code></li><li>选择 <code>view results tree</code></li></ul><p>加上之后即可选择start，开始测试，并得到结果</p><p>如果要清除listener，即可选择右上角 <code>clear all</code>   （如果只是清掉当前的view result tree，按clear即可）</p><p>我们查看view result tree里面详情，可以看到一次httprequest包含了两次请求</p><p>这是因为被重定向了</p><p><img src="/posts/12105/4.png" alt="4"></p><p>通过以上操作，我们明白了这样添加线程组并运行</p><p>但我们也要知道，实际操作中还需要添加<code>Config element</code></p><ul><li><code>add</code></li><li><code>config element</code></li><li><code>Http request defaults</code></li></ul><p><img src="/posts/12105/5.png" alt="5"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言学 第一章</title>
      <link href="/posts/17942.html"/>
      <url>/posts/17942.html</url>
      
        <content type="html"><![CDATA[<h2 id="语言学分类-按研究对象分"><a href="#语言学分类-按研究对象分" class="headerlink" title="语言学分类-按研究对象分"></a>语言学分类-按研究对象分</h2><ul><li>linguistics<ul><li>Theoretical Ling</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语语言学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组 第一章 绪论</title>
      <link href="/posts/7573.html"/>
      <url>/posts/7573.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-计算机的发展史"><a href="#1-1-计算机的发展史" class="headerlink" title="1.1 计算机的发展史"></a>1.1 计算机的发展史</h2><h3 id="1-1-1-计算简史"><a href="#1-1-1-计算简史" class="headerlink" title="1.1.1 计算简史"></a>1.1.1 计算简史</h3><h4 id="人类创造工具"><a href="#人类创造工具" class="headerlink" title="人类创造工具"></a>人类创造工具</h4><ul><li>机械工具</li><li>测试工具</li><li>计算工具</li></ul><h4 id="计算经历阶段"><a href="#计算经历阶段" class="headerlink" title="计算经历阶段"></a>计算经历阶段</h4><ul><li><p>手工计算</p></li><li><p>机械计算</p></li><li><p>电子计算</p></li></ul><h4 id="手工计算阶段"><a href="#手工计算阶段" class="headerlink" title="手工计算阶段"></a>手工计算阶段</h4><h5 id="计数工具"><a href="#计数工具" class="headerlink" title="计数工具"></a>计数工具</h5><ul><li>穴石、绳结、刻痕</li><li>十指</li><li>算盘<ul><li>应用时间最长</li><li>功能最完善</li><li>非自然化计数工具</li></ul></li><li>计算尺<ul><li>用长度模拟数值大小</li><li>可进行一些四则运算和复杂非四则运算</li></ul></li></ul><h5 id="计数法："><a href="#计数法：" class="headerlink" title="计数法："></a>计数法：</h5><ul><li>十进制<ul><li>是数学体系计数制基础</li></ul></li></ul><h5 id="口诀："><a href="#口诀：" class="headerlink" title="口诀："></a>口诀：</h5><ul><li>基本操作指令</li><li>算盘指令系统、珠算语言</li></ul><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li>人的技能水平、精力、智力影响计算速度、正确性</li><li>无法进行大的复杂运算</li></ul><h4 id="机械计算阶段"><a href="#机械计算阶段" class="headerlink" title="机械计算阶段"></a>机械计算阶段</h4><ul><li><p>pascal[法]</p><ul><li>1642年</li><li>可做成加减法的机械计算起</li></ul></li><li><p>Leibnitz[德]</p><ul><li>1673年</li><li>改进pascal设计</li><li>增加乘除运算</li></ul></li><li><p>19世纪</p><ul><li>手摇计算机商品化生产</li></ul></li><li><p>Babbage[英]  计算机之父</p><ul><li>首先提出整个计算过程自动化概念</li><li>设计第一台通用自动时序控制机械式计算机<ul><li>但未能制造出来</li></ul></li><li>认为自动计算机必须有五大功能<ul><li>输入</li><li>输出</li><li>处理</li><li>存储</li><li>控制</li></ul></li><li>提出计算机实现自动计算的前提<ul><li>具有记忆功能</li><li>能记住数据和要进行的步骤</li><li>并按步骤规定对机器进行自动控制</li></ul></li></ul></li><li><p>缺陷</p><ul><li>频繁的人工干预限制计算速度提高</li></ul></li></ul><h4 id="电子计算阶段"><a href="#电子计算阶段" class="headerlink" title="电子计算阶段"></a>电子计算阶段</h4><h5 id="电子计算"><a href="#电子计算" class="headerlink" title="电子计算"></a>电子计算</h5><ul><li>理论基础：<ul><li>二进制<ol><li>中国最早使用</li><li>阳爻-&gt;1  阴爻-&gt;0</li></ol></li></ul></li></ul><h5 id="George-Boole-英"><a href="#George-Boole-英" class="headerlink" title="George Boole [英]"></a>George Boole [英]</h5><ul><li><p>发表：</p><ul><li>《逻辑的数学分析》</li><li>《思维规律的研究》<ul><li>两本书核心：<ul><li>现代《布尔代数》精髓</li></ul></li></ul></li></ul></li><li><p>把运算和逻辑理论建立在</p><ul><li>0和1两种数值</li><li>”与“”或“”非“三种基本逻辑运算</li></ul></li><li><p>是现代数字式设备理论基础</p></li></ul><h5 id="V-Atanasolf-美-伊阿华大学"><a href="#V-Atanasolf-美-伊阿华大学" class="headerlink" title="V.Atanasolf 美 伊阿华大学"></a>V.Atanasolf 美 伊阿华大学</h5><ul><li><p>首次</p><ul><li>使用电子原件</li><li>按二进制原理<ul><li>制造一台电子管计算机</li></ul></li></ul></li><li><p>在Cliffod Berry协助下</p><ul><li>制造出一台电子管计算机Atanasoff Berry Computer</li></ul></li></ul><h5 id="ENIAC-Electronic-Numerical-Integrator-and-Computer"><a href="#ENIAC-Electronic-Numerical-Integrator-and-Computer" class="headerlink" title="ENIAC Electronic Numerical Integrator and Computer"></a>ENIAC Electronic Numerical Integrator and Computer</h5><ul><li>地位：<ul><li>世界上第一台电子数字计算机（试运行：1945）</li><li>现代电子数字计算机始祖</li></ul></li><li>大小：<ul><li>高8英尺 长100英尺 宽3英尺 </li><li>18000个真空管 1500个电子继电器</li><li>18000个电容 70000个电阻</li><li>重30吨</li></ul></li><li>计算：<ul><li>弹道计算：<ul><li>60s射程弹道计算为30s</li></ul></li><li>性能：<ul><li>不高<ul><li>5000次加法运算</li><li>50次乘法运算</li></ul></li><li>每秒可进行<ul><li>平方</li><li>立方</li><li>sin</li><li>cos<ul><li>数值运算</li></ul></li></ul></li></ul></li><li>其他领域<ul><li>eg：<ul><li>天气预报</li><li>原子核能</li><li>风洞试验</li></ul></li><li>关于原子裂变的能量计算<ul><li>冯诺依曼邀请</li><li>促进世界第一颗原子弹问世</li></ul></li></ul></li><li>圆周率计算（1949）<ul><li>70小时，计算至小数点后2037位</li><li>人类第一次用机器算的最精确圆周率数值</li></ul></li></ul></li><li>1955年 退休</li></ul><h5 id="EDSAC-英-剑桥"><a href="#EDSAC-英-剑桥" class="headerlink" title="EDSAC [英 剑桥]"></a>EDSAC [英 剑桥]</h5><ul><li>Electronic Delay Storage Automatic Computer<ul><li>世界上第一台通用电子数字计算机<ul><li>人类开始进入电子数字计算机时代</li></ul></li></ul></li></ul><h3 id="1-1-2-计算机发展简史"><a href="#1-1-2-计算机发展简史" class="headerlink" title="1.1.2 计算机发展简史"></a>1.1.2 计算机发展简史</h3><h4 id="经历4代："><a href="#经历4代：" class="headerlink" title="经历4代："></a>经历4代：</h4><ul><li>第一代计算机 20世纪40代中-50末</li><li>第二代计算机 20世纪50中后-60中</li><li>第三代计算机 20世纪60中-70中</li><li>第四代计算机 20世纪70中-今</li></ul><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><ul><li><p>电子器件</p><ul><li>是划分时代最重要标志</li></ul></li></ul><h4 id="第一代计算机：电子管计算机"><a href="#第一代计算机：电子管计算机" class="headerlink" title="第一代计算机：电子管计算机"></a>第一代计算机：电子管计算机</h4><ul><li>逻辑元件：<ul><li>电子管</li></ul></li><li>主存储器：<ul><li>阴极射线管</li><li>声泵延迟线</li><li>磁带、磁鼓</li></ul></li><li>数据表示<ul><li>定点表示</li></ul></li><li>编程语言：<ul><li>机器语言</li><li>汇编语言</li></ul></li><li>机器：<ul><li>ENIAC\EDSCAC</li><li>冯诺依曼为首研制的存储程序计算机<ul><li>IAS</li><li>UNIVAC-1</li><li>IBM 704</li></ul></li><li>我国自己研制的第一代计算机<ul><li>主要<ul><li>104机</li><li>103机</li><li>119机</li></ul></li></ul></li></ul></li></ul><h4 id="第二代计算机：晶体管计算机"><a href="#第二代计算机：晶体管计算机" class="headerlink" title="第二代计算机：晶体管计算机"></a>第二代计算机：晶体管计算机</h4><ul><li><h5 id="逻辑元件："><a href="#逻辑元件：" class="headerlink" title="逻辑元件："></a>逻辑元件：</h5><ul><li>晶体管</li></ul></li><li><p>主存储器元件：</p><ul><li>磁芯</li></ul></li><li><p>运算：</p><ul><li>引入浮点运算硬件</li></ul></li><li><p>建立：</p><ul><li>子程序库</li><li>批处理管理程序</li></ul></li><li><p>语言：</p><ul><li>FORTRAN</li><li>COBOL</li><li>ALGOL<ul><li>等高级语言<ul><li>简化了程序设计</li></ul></li></ul></li></ul></li><li><p>优点：</p><ul><li>体积小</li><li>功耗快</li><li>速度快</li><li>可靠性高</li></ul></li><li><p>机器：</p><ul><li>国外：<ul><li>IBM 7040,7070,7090</li><li>CDC 1604</li></ul></li><li>国内：<ul><li>109机</li><li>441B机</li><li>108机</li></ul></li></ul></li></ul><h4 id="第三代计算机"><a href="#第三代计算机" class="headerlink" title="第三代计算机"></a>第三代计算机</h4><ul><li>基础器件：<ul><li>集成电路<ul><li>微电子技术与计算机技术相结合的一大突破</li></ul></li></ul></li><li>电路：<ul><li>采用<ul><li>小规模</li><li>中规模<ul><li>集成电路</li></ul></li></ul></li></ul></li><li>存储器：<ul><li>半导体存储器</li></ul></li><li>改进：<ul><li>引进多道程序和并行处理等新的技术</li><li>操作系统日趋成熟</li></ul></li><li>机器：<ul><li>国外：<ul><li>IBM 360系列</li><li>CDC 6600/7600系列</li><li>CYBER系列</li></ul></li><li>国产:<ul><li>150,151<ul><li>DJS-2000系列</li><li>DJS-1000系列</li></ul></li></ul></li></ul></li></ul><h4 id="第四代计算机"><a href="#第四代计算机" class="headerlink" title="第四代计算机"></a>第四代计算机</h4><ul><li>电路：<ul><li>大规模集成电路</li><li>超大规模集成电路</li></ul></li><li>改进：<ul><li>技术：<ul><li>并行处理</li><li>多机系统</li><li>分布式计算机</li><li>计算机网络<ul><li>等技术飞速发展</li></ul></li></ul></li><li>机器：<ul><li>微处理机、微型计算机<ul><li>迅速发展</li></ul></li><li>小型机、超级小型机、大型机、巨型机<ul><li>不断问世</li></ul></li></ul></li></ul></li></ul><h2 id="1-2-计算机系统组成"><a href="#1-2-计算机系统组成" class="headerlink" title="1.2 计算机系统组成"></a>1.2 计算机系统组成</h2><h3 id="1-2-1-存储程序原理"><a href="#1-2-1-存储程序原理" class="headerlink" title="1.2.1 存储程序原理"></a>1.2.1 存储程序原理</h3><h4 id="《关于电子计算装置逻辑结果初探》"><a href="#《关于电子计算装置逻辑结果初探》" class="headerlink" title="《关于电子计算装置逻辑结果初探》"></a>《关于电子计算装置逻辑结果初探》</h4><ul><li>美籍匈牙利数学家 冯诺依曼</li><li>所阐述思想构建了<ul><li>现代电子计算机的组成原理</li></ul></li><li>提出了<ul><li>以存储程序为核心的通用电子数字计算机体系结构原理</li></ul></li><li>奠定了<ul><li>当代电子计算机体系结构的基础</li></ul></li></ul><h4 id="“存储程序计算机”："><a href="#“存储程序计算机”：" class="headerlink" title="“存储程序计算机”："></a>“存储程序计算机”：</h4><ul><li>按照存储程序原理构建的计算机</li></ul><h4 id="存储程序原理"><a href="#存储程序原理" class="headerlink" title="存储程序原理"></a>存储程序原理</h4><h5 id="存储程序原理基本思想"><a href="#存储程序原理基本思想" class="headerlink" title="存储程序原理基本思想"></a>存储程序原理基本思想</h5><ul><li>计算机要自动完成解题任务</li><li>必须将实现设计好、用以描述计算机解题过程中的程序<ul><li>和数据一样</li><li>按 <strong>二进制</strong> 形式存储在机器中</li></ul></li><li>计算机在工作时 <strong>自动高速</strong> 地从机器中 <strong>逐条取出指令</strong> 并加以执行</li></ul><h6 id="程序的定义："><a href="#程序的定义：" class="headerlink" title="程序的定义："></a>程序的定义：</h6><ul><li>程序即指令的有序集合</li></ul><h6 id="计算器与计算机不同之处："><a href="#计算器与计算机不同之处：" class="headerlink" title="计算器与计算机不同之处："></a>计算器与计算机不同之处：</h6><ul><li>计算器解题步骤<ul><li>即程序是在执行过程中由人工临时编制和控制执行的</li></ul></li></ul><h5 id="存储程序原理-计算机五大功能"><a href="#存储程序原理-计算机五大功能" class="headerlink" title="存储程序原理 计算机五大功能"></a>存储程序原理 计算机五大功能</h5><ol><li>数据传送功能<ul><li>计算机将 <strong>原始数据</strong> 和 <strong>解题程序</strong> 输入到机器中</li><li>计算机结果与计算过程中情况 也能 <strong>随时输出</strong> 给用户</li><li>即 计算机必须有 <strong>输入和输出</strong> 的功能</li></ul></li><li>数据存储功能<ul><li>计算机能记住<ul><li>输入的原始数据</li><li>解题步骤 即程序</li><li>解题过程中产生中间结果</li></ul></li><li>即具备数据存储功能</li><li>是计算机能实现<strong>自动运算关键</strong></li></ul></li><li>数据处理功能<ul><li>能进行一些基本运算<ul><li>组合成所需要的一切复杂运算和操作</li></ul></li><li>这是计算机 进行<strong>运算、处理、控制的基础</strong></li></ul></li><li>操作控制功能<ul><li>保证程序执行的<strong>正确性</strong></li><li><strong>协调控制</strong> 组成计算机的各部件</li></ul></li><li>操作判断功能<ul><li>完成一步操作后<ul><li>从预先无法确定的几种方案中选择一种方案</li><li>保证解题操作正确完成</li></ul></li></ul></li></ol><h4 id="经典“存储程序计算机”"><a href="#经典“存储程序计算机”" class="headerlink" title="经典“存储程序计算机”"></a>经典“存储程序计算机”</h4><ul><li>即经典冯诺依曼结构计算机框图</li><li><img src="/posts/7573/冯诺依曼计算机.png" alt="冯诺依曼计算机" style="zoom:67%;">- 实线：  - 数据线- 虚线：  - 控制线  - 反馈线</li></ul><h3 id="1-2-2-计算机系统的组成"><a href="#1-2-2-计算机系统的组成" class="headerlink" title="1.2.2 计算机系统的组成"></a>1.2.2 计算机系统的组成</h3><h4 id="完整的计算机系统构成"><a href="#完整的计算机系统构成" class="headerlink" title="完整的计算机系统构成"></a>完整的计算机系统构成</h4><ul><li>硬件系统</li><li>软件系统</li></ul><h4 id="计算机硬件系统"><a href="#计算机硬件系统" class="headerlink" title="计算机硬件系统"></a>计算机硬件系统</h4><h5 id="硬件的定义："><a href="#硬件的定义：" class="headerlink" title="硬件的定义："></a>硬件的定义：</h5><ul><li>Hardware</li><li>是组成电子计算机的所有电子器件和机电装置的总称</li><li>是计算机系统中实际存在的物理实体，看得见摸得着</li></ul><h5 id="硬件系统的构成"><a href="#硬件系统的构成" class="headerlink" title="硬件系统的构成"></a>硬件系统的构成</h5><ul><li>物理构成上看：<ul><li>电子器件</li><li>插件板</li><li>电源</li><li>机架</li><li>各种功能的外部设备</li></ul></li><li>逻辑功能上看：<ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li><li>之间的互连结构</li></ul></li></ul><h5 id="硬件系统地位："><a href="#硬件系统地位：" class="headerlink" title="硬件系统地位："></a>硬件系统地位：</h5><ul><li><p>是构成计算机的物质基础</p></li><li><p>是计算机系统的核心</p></li></ul><h4 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h4><h5 id="软件的定义："><a href="#软件的定义：" class="headerlink" title="软件的定义："></a>软件的定义：</h5><ul><li>按iso国际标准化组织的定义：<ul><li>是电子计算机程序及运用数据处理系统所必须的<ul><li>手续</li><li>规则</li><li>文件<ul><li>的总称</li></ul></li></ul></li></ul></li></ul><h5 id="软件的构成"><a href="#软件的构成" class="headerlink" title="软件的构成"></a>软件的构成</h5><ul><li>程序</li><li>文档</li></ul><h5 id="程序："><a href="#程序：" class="headerlink" title="程序："></a>程序：</h5><ul><li>定义：<ul><li>为了取得一定的结果而编写的计算机指令的有序集合</li></ul></li><li>特点：<ul><li>可由计算机执行</li><li>是计算机软件的主体</li><li>一般说到软件，主要指程序</li></ul></li></ul><h5 id="文档："><a href="#文档：" class="headerlink" title="文档："></a>文档：</h5><ul><li><p>定义：</p><ul><li>是描述程序操作及使用的有关资料</li></ul></li><li><p>特点：</p><ul><li>不能由计算机执行</li></ul></li></ul><h4 id="计算机软件系统和硬件系统关系"><a href="#计算机软件系统和硬件系统关系" class="headerlink" title="计算机软件系统和硬件系统关系"></a>计算机软件系统和硬件系统关系</h4><h5 id="软硬件关系"><a href="#软硬件关系" class="headerlink" title="软硬件关系"></a>软硬件关系</h5><ul><li>软硬件之间是<ul><li>相互渗透、相互依存</li><li>相互配合、相互促进的关系</li><li>二者缺一不可</li></ul></li><li>硬件<ul><li>是躯体，是物质基础</li></ul></li><li>软件<ul><li>是智慧、灵魂、是硬件功能的完善和扩充</li><li>作为计算机用户与硬件之间接口界面<ul><li>在计算机系统中 起指挥管理作用</li></ul></li></ul></li><li>硬件与软件的组合<ul><li>构成了完善实用的计算机系统</li></ul></li></ul><h5 id="软硬件功能："><a href="#软硬件功能：" class="headerlink" title="软硬件功能："></a>软硬件功能：</h5><ul><li>计算机系统功能<ul><li>由硬件或软件实现</li></ul></li><li>软件与硬件在逻辑功能上等价<ul><li>硬件实现的功能可用软件实现</li><li>反之亦然</li></ul></li><li>由软硬件实现的计算机系统的<ul><li>成本</li><li>效率<ul><li>不同</li><li>一般在系统设计时加以权衡</li></ul></li></ul></li></ul><h5 id="软硬件转化："><a href="#软硬件转化：" class="headerlink" title="软硬件转化："></a>软硬件转化：</h5><ul><li><p>随着超大规模集成电路技术的发展</p><ul><li><p>软件硬化成固化是</p><ul><li>提高 <strong>计算机处理能力</strong> 的 最常用手段</li></ul></li><li><p>固件Firmware</p><ul><li><p>是将程序固化在ROM中组成的部件</p></li><li><p>是一种具有软件特性的硬件</p><ul><li><p>具有</p><ul><li><p>硬件的 快速性</p></li><li><p>软件的 灵活性</p></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="1-2-3-计算机硬件系统组成"><a href="#1-2-3-计算机硬件系统组成" class="headerlink" title="1.2.3 计算机硬件系统组成"></a>1.2.3 计算机硬件系统组成</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><h5 id="两类计算机结构"><a href="#两类计算机结构" class="headerlink" title="两类计算机结构"></a>两类计算机结构</h5><ul><li>冯诺依曼计算机结构<ul><li>以 <strong>运算器</strong> 为中心</li><li>计算机效率不高<ul><li>原因：<ul><li>输入输出设备速度慢</li><li>传输操作都需通过运算器</li></ul></li></ul></li></ul></li><li>现代计算机结构<ul><li>以 <strong>存储器</strong> 为中心</li></ul></li></ul><h5 id="中央处理器："><a href="#中央处理器：" class="headerlink" title="中央处理器："></a>中央处理器：</h5><ul><li>Central Processing Unit,CPU<ul><li>包含：<ul><li>运算器</li><li>控制器</li></ul></li><li>名称原因：<ul><li>运算器、控制器逻辑关系联系紧密</li><li>大规模集成电路出现后<ul><li>两部件集中在同一芯片上</li></ul></li></ul></li></ul></li></ul><h5 id="存储器："><a href="#存储器：" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>功能：<ul><li>存储二进制信息</li></ul></li><li>分类<ul><li>内存储器：<ul><li>又称主存储器</li><li>特点：<ul><li>存取速度快</li><li>存储容量较小</li><li>与CPU直接打交道</li><li>有半导体元器件构成</li></ul></li></ul></li><li>外存储器<ul><li>也称辅助存储器</li><li>特点：<ul><li>存取速度慢</li><li>存储容量较大</li><li>但不能直接与CPU打交道</li><li>必须把其中的信息送到内存后再由CPU处理</li></ul></li><li>eg：<ul><li>磁盘、磁带、光盘</li></ul></li></ul></li></ul></li></ul><h5 id="主机："><a href="#主机：" class="headerlink" title="主机："></a>主机：</h5><ul><li>包含<ul><li>内存储器</li><li>CPU</li></ul></li></ul><h5 id="外部设备："><a href="#外部设备：" class="headerlink" title="外部设备："></a>外部设备：</h5><ul><li><p>包含</p><ul><li><p>输入输出设备</p></li><li><p>外存储器</p></li></ul></li></ul><h4 id="运算器-Arithmetic-Unit"><a href="#运算器-Arithmetic-Unit" class="headerlink" title="运算器 Arithmetic Unit"></a>运算器 Arithmetic Unit</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h5><h6 id="运算器定义："><a href="#运算器定义：" class="headerlink" title="运算器定义："></a>运算器定义：</h6><ul><li>是进行数据处理</li><li>即执行<ul><li>算术运算</li><li>逻辑运算<ul><li>的部件</li></ul></li></ul></li></ul><h6 id="算术运算："><a href="#算术运算：" class="headerlink" title="算术运算："></a>算术运算：</h6><ul><li>是按照算数规则进行的运算</li><li>eg：<ul><li>加减乘除</li><li>及它们的复合运算等</li></ul></li></ul><h6 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h6><ul><li>即非算数性运算<ul><li>eg：<ul><li>比较</li><li>移位</li><li>逻辑加、逻辑乘</li><li>异或操作等</li></ul></li></ul></li></ul><h6 id="带输入锁存器的运算器"><a href="#带输入锁存器的运算器" class="headerlink" title="带输入锁存器的运算器"></a>带输入锁存器的运算器</h6><ul><li><p>含有：</p><ul><li>算术逻辑单元</li><li>内部总线</li><li>通用寄存器组</li><li>锁存器</li><li>标志寄存器</li><li>移位器</li></ul></li><li><p>结构图：</p><ul><li><img src="/posts/7573/%E5%B8%A6%E8%BE%93%E5%85%A5%E9%94%81%E5%AD%98%E5%99%A8%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8.png" alt="带输入锁存器的运算器"></li></ul></li></ul><h6 id="1-算数逻辑单元"><a href="#1-算数逻辑单元" class="headerlink" title="1.算数逻辑单元"></a>1.算数逻辑单元</h6><ul><li>Arithmetic and logic unit</li><li>功能：<ul><li>是具体完成算术逻辑运算的部件</li></ul></li><li>包含：<ul><li>加法器</li><li>逻辑运算器件</li></ul></li><li>地位：<ul><li>是运算器的核心</li></ul></li></ul><h6 id="2-内部总线"><a href="#2-内部总线" class="headerlink" title="2.内部总线"></a>2.内部总线</h6><ul><li>连接：<ul><li>ALU</li><li>通用寄存器组</li><li>锁存器</li><li>标志寄存器Flag</li><li>移位器</li></ul></li><li>地位：<ul><li>是CPU内部的数据通路</li></ul></li><li>与系统总线的区别：<ul><li>内部总线 仅用来传送数据</li></ul></li></ul><h6 id="3-通用寄存器组R0-R-n-1）"><a href="#3-通用寄存器组R0-R-n-1）" class="headerlink" title="3.通用寄存器组R0-R(n-1）"></a>3.通用寄存器组R0-R(n-1）</h6><ul><li>功能：<ul><li>用于存放参与运算的操作数<ul><li>eg：<ul><li>加、减、乘、被除数、积、商等</li></ul></li></ul></li><li>连续运算中，还存放<ul><li>中间结果</li><li>最终结果</li></ul></li><li>通用寄存器中的数据<ul><li>均从存储器中取得</li><li>最终结果也存放到存储器中</li></ul></li></ul></li></ul><h6 id="4-锁存器"><a href="#4-锁存器" class="headerlink" title="4.锁存器"></a>4.锁存器</h6><ul><li>位置：<ul><li>ALU的两个输入端各有一个锁存器<ul><li>用来暂存要参与运算的操作数</li></ul></li></ul></li><li>实现R0&lt;-(R0)+(R2)的方法：<ol><li>通过内部总线 将R0中的数据送入锁存器1</li><li>通过内部总线将R2中的数据送入锁存器2</li><li>再在ALU中相加</li><li>将结果通过内部总线送入R0</li></ol></li></ul><h6 id="5-标志寄存器Flag"><a href="#5-标志寄存器Flag" class="headerlink" title="5.标志寄存器Flag"></a>5.标志寄存器Flag</h6><ul><li>寄存运算的状态信息<ul><li>eg：<ul><li>结果是否为0</li><li>是正数还是负数</li><li>溢出与否</li></ul></li></ul></li></ul><h6 id="6-移位器："><a href="#6-移位器：" class="headerlink" title="6.移位器："></a>6.移位器：</h6><ul><li><p>是一个多路开关</p></li><li><p>可对ALU的加工结果进行辅助操作</p></li><li><p>eg：</p><ul><li><p>可实现</p><ul><li><p>左移</p></li><li><p>右移</p></li><li><p>直接传送</p><ul><li>等功能</li></ul></li></ul></li></ul></li></ul><h6 id="带多路选择器的运算器"><a href="#带多路选择器的运算器" class="headerlink" title="带多路选择器的运算器"></a>带多路选择器的运算器</h6><ul><li>除了带输入所存期的运算器外</li><li>还有带多路选择器的运算器<ul><li>相似点：<ul><li>基本组成相同</li></ul></li><li>差异点：<ul><li>通用寄存器与ALU的连接方式不同</li></ul></li></ul></li></ul><h4 id="控制器-Control-Unit"><a href="#控制器-Control-Unit" class="headerlink" title="控制器 Control Unit"></a>控制器 Control Unit</h4><h5 id="地位："><a href="#地位：" class="headerlink" title="地位："></a>地位：</h5><ul><li>是计算机的管理机构和指挥中心</li><li>协调计算机的各部件自动地工作</li></ul><h5 id="完成的工作："><a href="#完成的工作：" class="headerlink" title="完成的工作："></a>完成的工作：</h5><ul><li>实质上是 解释程序<ul><li>每次从存储器中读取一条指令</li><li>经过<ul><li>分析译码</li><li>产生一系列控制信号</li></ul></li><li>发往各个部件以控制他们的操作</li></ul></li><li>连续不断地继续上述动作<ul><li>即所谓执行程序</li></ul></li></ul><h5 id="控制器的结构图："><a href="#控制器的结构图：" class="headerlink" title="控制器的结构图："></a>控制器的结构图：</h5><p><img src="/posts/7573/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%84%E6%88%90.png" alt="控制器结构图"></p><h5 id="控制器的类别："><a href="#控制器的类别：" class="headerlink" title="控制器的类别："></a>控制器的类别：</h5><ul><li>组合逻辑控制器</li><li>微程序控制器</li></ul><h5 id="组合逻辑控制器："><a href="#组合逻辑控制器：" class="headerlink" title="组合逻辑控制器："></a>组合逻辑控制器：</h5><h6 id="结构组成："><a href="#结构组成：" class="headerlink" title="结构组成："></a>结构组成：</h6><ul><li><p>指令控制部件</p></li><li><p>地址形成部件</p></li><li><p>定时部件</p></li><li><p>微操作控制部件</p></li></ul><h5 id="1-指令控制部件"><a href="#1-指令控制部件" class="headerlink" title="1.指令控制部件"></a>1.指令控制部件</h5><h6 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h6><ul><li>程序计数器 Program Counter ,PC</li><li>指令寄存器 Instruction Register,IR</li><li>指令译码器 Instruction Decoder,ID</li></ul><h6 id="程序计数器PC："><a href="#程序计数器PC：" class="headerlink" title="程序计数器PC："></a>程序计数器PC：</h6><ul><li>又叫指令计数器</li><li>作用：<ul><li>给出程序中指令在存储器中的单位地址</li><li>兼有<ul><li>指令地址寄存器</li><li>计数器<ul><li>的功能</li></ul></li></ul></li></ul></li><li>工作过程：<ul><li>取指令时，PC指向要取指令的地址</li><li>当一条指令执行完毕时<ul><li>pc作为指令地址寄存器</li><li>其内容已变成下一条指令的地址</li></ul></li><li>控制器依据PC的内容从存储器取出指令到IR后<ul><li>pc将自动加1</li><li>指向下一条指令的地址</li></ul></li><li>假定一个存储单元存储一条指令<ul><li>若非顺序执行</li><li>只要将pc的内容作相应改变</li><li>就可以按新的序列顺序执行</li></ul></li></ul></li></ul><h6 id="指令寄存器IR"><a href="#指令寄存器IR" class="headerlink" title="指令寄存器IR:"></a>指令寄存器IR:</h6><ul><li>保存当前正在执行的指令代码</li><li>在指令执行过程中由它决定指令的<ul><li>操作性质</li><li>参与操作的操作数地址</li></ul></li></ul><h6 id="指令译码器ID："><a href="#指令译码器ID：" class="headerlink" title="指令译码器ID："></a>指令译码器ID：</h6><ul><li>也称操作码译码器</li><li>将指令的操作码转换为相应的控制电位信号<ul><li>只是各部件做什么操作</li></ul></li></ul><h5 id="2-地址形成部件"><a href="#2-地址形成部件" class="headerlink" title="2.地址形成部件"></a>2.地址形成部件</h5><ul><li>包括：<ul><li>地址寄存器Address Register AR</li><li>变址寄存器Index Register XR</li><li>地址计算部件</li></ul></li><li>功能：<ul><li>依据<ul><li>指令的寻址方式</li><li>指令的地址码部分<ul><li>生成实际的操作数地址</li></ul></li></ul></li></ul></li></ul><h5 id="3-定时部件"><a href="#3-定时部件" class="headerlink" title="3.定时部件"></a>3.定时部件</h5><ul><li>又称时序部件</li></ul><h6 id="组成：-1"><a href="#组成：-1" class="headerlink" title="组成："></a>组成：</h6><ul><li>时钟 Clock Pulses,CP</li><li>时序信号产生器 Timing Signal Generator ,TSG</li></ul><h6 id="时钟-CP："><a href="#时钟-CP：" class="headerlink" title="时钟 CP："></a>时钟 CP：</h6><ul><li>是协调计算机各部件进行操作的同步时钟</li><li>其工作频率<ul><li>成为计算机的 <strong>主频</strong></li><li><strong>主频</strong>的高低直接影响计算机的工作速度</li></ul></li></ul><h6 id="时序信号产生器TSG："><a href="#时序信号产生器TSG：" class="headerlink" title="时序信号产生器TSG："></a>时序信号产生器TSG：</h6><ul><li>功能：<ul><li>按时间顺序<ul><li>周而复始地发出若干节拍信号和脉冲</li></ul></li></ul></li><li>节拍：<ul><li>即相邻两个时钟脉冲的时间间隔</li><li>即主频周期</li></ul></li></ul><h6 id="定时部件工作特点："><a href="#定时部件工作特点：" class="headerlink" title="定时部件工作特点："></a>定时部件工作特点：</h6><ul><li>根据机器的时钟脉冲<ul><li>发出全机所需的<ul><li>定时节拍信号</li><li>脉冲</li></ul></li></ul></li><li>各部件在不同的节拍信号控制下依次进行工作</li></ul><h5 id="4-微操作控制器"><a href="#4-微操作控制器" class="headerlink" title="4.微操作控制器"></a>4.微操作控制器</h5><h6 id="微操作的定义："><a href="#微操作的定义：" class="headerlink" title="微操作的定义："></a>微操作的定义：</h6><ul><li>Micro-operation</li><li>是指计算机各部件在一个节拍内能完成的基本操作</li></ul><h6 id="微操作的意义："><a href="#微操作的意义：" class="headerlink" title="微操作的意义："></a>微操作的意义：</h6><ul><li>计算机任意一条指令的执行都需要分解成许多微操作来执行</li></ul><h6 id="微操作控制部件："><a href="#微操作控制部件：" class="headerlink" title="微操作控制部件："></a>微操作控制部件：</h6><ul><li>是控制器的<ul><li>核心部件</li><li>最复杂的部件</li></ul></li><li>工作过程：<ul><li>根据<ul><li>指令控制部件给出的指令译码电位信号（进行什么操作）</li><li>时序部件给出的节拍信号和脉冲（指令执行到那一步）</li><li>运算器Flag提供的状态信息</li></ul></li><li>产生 计算机指令系统中所有指令所需的各种微操作控制信号</li><li>再讲这些控制信号发送给<ul><li>运算器</li><li>存储器</li><li>输入、输出设备</li><li>控制其本身</li></ul></li></ul></li><li>与组合逻辑控制器关系：<ul><li>除将微操作控制部件用微程序库代替外</li><li>其他部件和组合逻辑控制器相似</li></ul></li></ul><h4 id="内存储器"><a href="#内存储器" class="headerlink" title="内存储器"></a>内存储器</h4><h5 id="存储器：-1"><a href="#存储器：-1" class="headerlink" title="存储器："></a>存储器：</h5><ul><li>主要功能：<ul><li>存放<ul><li>数据</li><li>程序</li></ul></li></ul></li><li>数据：<ul><li>是计算机操作的对象</li></ul></li><li>程序：<ul><li>是计算机指令的有序集合</li></ul></li><li>数据与程序必须存放在内存储器中原因：<ul><li>数据与程序均以二进制的形式表示</li><li>为实现自动运行程序</li></ul></li></ul><h5 id="内存储器的构成："><a href="#内存储器的构成：" class="headerlink" title="内存储器的构成："></a>内存储器的构成：</h5><ul><li>存储体</li><li>选址系统</li><li>读写系统</li><li>存储时序控制线路</li></ul><h5 id="存储体："><a href="#存储体：" class="headerlink" title="存储体："></a>存储体：</h5><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><ul><li>被分成一个一个存储单元</li><li>每个存储单元存放多位二进制信息</li><li>通常每个单元存放一个数据或一条指令</li></ul><h6 id="信息的特点："><a href="#信息的特点：" class="headerlink" title="信息的特点："></a>信息的特点：</h6><ul><li>信息的位数通常是计算机的字长</li><li>一般字长为字节的整数倍</li></ul><h6 id="存储体的定义："><a href="#存储体的定义：" class="headerlink" title="存储体的定义："></a>存储体的定义：</h6><ul><li>即存储单元的集合</li></ul><h6 id="存储单元的特点："><a href="#存储单元的特点：" class="headerlink" title="存储单元的特点："></a>存储单元的特点：</h6><ul><li><p>按顺序编号</p></li><li><p>每个存储单元对应一个编号</p><ul><li>此编号为存储单元地址<ul><li>简称地址</li></ul></li></ul></li><li><p>只要给定一个地址</p><ul><li>就可以通过地址译码器译码</li><li>找到对应的存储单元</li><li>从而可<ul><li>从该单元读取信息</li><li>或将信息写入该单元</li></ul></li></ul></li><li><p>地址与存储单元的关系：</p><ul><li><p>地址与存储单元一一对应</p></li><li><p>每个存储单元只有一个地址</p></li></ul></li></ul><h5 id="选址系统：Addressing-System"><a href="#选址系统：Addressing-System" class="headerlink" title="选址系统：Addressing System"></a>选址系统：Addressing System</h5><h6 id="包含："><a href="#包含：" class="headerlink" title="包含："></a>包含：</h6><ul><li>存储地址寄存器 Memory Address Register ,MAR</li><li>地址译码器</li><li>地址驱动器</li></ul><h6 id="访问存储器过程："><a href="#访问存储器过程：" class="headerlink" title="访问存储器过程："></a>访问存储器过程：</h6><ul><li>CPU或I/O与内存储器交换信息以存储单元为单位</li><li>访问存储器：<ul><li>即向存储单元存入或从存储单元取出信息</li></ul></li></ul><h6 id="CPU或i-o访存过程："><a href="#CPU或i-o访存过程：" class="headerlink" title="CPU或i/o访存过程："></a>CPU或i/o访存过程：</h6><ul><li>先将访存地址送MAR</li><li>经地址译码器找到被访问的存储单元</li><li>最后由地址驱动器驱动该存储单元以实现读和写</li></ul><h5 id="读写系统-Read-and-Write-System"><a href="#读写系统-Read-and-Write-System" class="headerlink" title="读写系统 Read and Write System"></a>读写系统 Read and Write System</h5><ul><li>包含：<ul><li>存储缓冲寄存器 Mcmory Buffer Register ,MBR</li><li>读写线路</li></ul></li><li>工作过程：<ul><li>读出时：<ul><li>控制器发出读控制信号</li><li>借助于读出线路<ul><li>将由选址系统确定的存储单元内容<ul><li>读出送至MBR</li></ul></li></ul></li><li>以供I/O或CPU使用</li></ul></li><li>写入时：<ul><li>先将要写入的数据送至MBR</li><li>控制器发出写控制信号</li><li>借助于写入线路<ul><li>将BMR内容写入<ul><li>由选址系统确定的存储单元</li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="存储时序控制线路-Memory-Sequential-Control-Circuit"><a href="#存储时序控制线路-Memory-Sequential-Control-Circuit" class="headerlink" title="存储时序控制线路 Memory Sequential Control Circuit"></a>存储时序控制线路 Memory Sequential Control Circuit</h5><ul><li>包含：<ul><li>控制触发器</li><li>各种门电路</li><li>延迟线路</li></ul></li><li>工作过程：<ul><li>接收来自I/O或CPU的<ul><li>启动</li><li>读写</li><li>清除<ul><li>等命令</li></ul></li></ul></li><li>产生一系列控制内存储器<ul><li>完成读写等操作的信号</li></ul></li></ul></li></ul><h4 id="输入设备和输出设备"><a href="#输入设备和输出设备" class="headerlink" title="输入设备和输出设备"></a>输入设备和输出设备</h4><h5 id="输入设备："><a href="#输入设备：" class="headerlink" title="输入设备："></a>输入设备：</h5><ul><li>作用：<ul><li>将<ul><li>数据</li><li>程序<ul><li>送入计算机</li></ul></li></ul></li></ul></li><li>常见的输入设备：<ul><li>键盘</li><li>鼠标</li><li>数字化仪</li><li>扫描仪</li><li>摄像机</li></ul></li><li>特点：<ul><li>多是电子和机电混合的装置</li><li>一般需要通过被称之为接口的电子部件与<ul><li>运算器</li><li>控制器</li><li>存储器相连接<ul><li>原因：<ul><li>与运算器、控制器、内存储器等纯电子部件相比<ul><li>速度较慢</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备:"></a>输出设备:</h5><h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><ul><li>将计算处理的结果转化为<ul><li>人或其它设备</li><li>所能识别或接收的信息形式的装置</li></ul></li></ul><h6 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h6><ul><li>显示器能将信息转化为字符、图像、图形，并在屏幕上显示</li><li>打印机能将文件打印出来</li><li>绘图机可将图形绘制出来</li></ul><h6 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h6><ul><li><p>与输入设备一样</p><ul><li><p>输出设备也多为机电装置</p></li><li><p>也需要通过接口与</p><ul><li><p>运算器</p></li><li><p>控制器</p></li><li><p>存储器</p><ul><li>相连接</li></ul></li></ul></li></ul></li></ul><h4 id="互连结构"><a href="#互连结构" class="headerlink" title="互连结构"></a>互连结构</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><ul><li>计算机的五大部件<ul><li>需通过互连结构Interconnection Structure<ul><li>连接成一个有机的整体</li></ul></li></ul></li></ul><h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><ul><li>现代计算机通常采用 <strong>总线</strong>互连结构</li></ul><h5 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h5><ul><li>是连接计算机各部件进行信息传送的一组共同传输线</li><li>其类型和结构形式繁多</li></ul><h2 id="1-3-计算机的工作过程"><a href="#1-3-计算机的工作过程" class="headerlink" title="1.3 计算机的工作过程"></a>1.3 计算机的工作过程</h2><h3 id="1-3-1-使用计算机求解一个简单例子"><a href="#1-3-1-使用计算机求解一个简单例子" class="headerlink" title="1.3.1 使用计算机求解一个简单例子"></a>1.3.1 使用计算机求解一个简单例子</h3><h4 id="计算机求解问题步骤："><a href="#计算机求解问题步骤：" class="headerlink" title="计算机求解问题步骤："></a>计算机求解问题步骤：</h4><ul><li>首先，由用户提出任务并建立数学模型</li><li>确定便于计算机实现的算法</li><li>选择合适的语言编写程序</li><li>上机调试运行</li><li>不论采用哪种程序设计语言编写源程序<ul><li>都必需转换为机器语言程序</li><li>即目标程序</li><li>然后计算机才能执行</li></ul></li></ul><h4 id="机器语言程序的定义："><a href="#机器语言程序的定义：" class="headerlink" title="机器语言程序的定义："></a>机器语言程序的定义：</h4><ul><li>是机器指令（简称指令）的有序集合</li></ul><h4 id="计算机的工作过程："><a href="#计算机的工作过程：" class="headerlink" title="计算机的工作过程："></a>计算机的工作过程：</h4><ul><li>就是执行指令的过程</li></ul><h4 id="简单例子-1-1"><a href="#简单例子-1-1" class="headerlink" title="简单例子 1.1"></a>简单例子 1.1</h4><p>用计算机求解代数多项式：x=ax^3+bx^2+cx+d,其中a,b,c,d,x为已知数</p><ul><li>对该代数多项式可直接进行四则运算<ul><li>先求出x^2和x^3</li><li>然后计算每项乘积ax^3,bx^2和cx</li><li>最后两两相加求得y值<ul><li>此算法需要5次乘法和3次加法</li><li>共8次运算</li></ul></li></ul></li><li>如果将多项式的幂、乘加形式 变换为 乘、加迭代形式<ul><li>即：y=((ax+b)x+c)x+d<ul><li>此时计算需要乘、加各3次</li><li>共6次计算</li></ul></li></ul></li><li>更改后：<ul><li>8次运算减少到了6次</li><li>运算次数减少了四分之一</li></ul></li><li>运算的操作对象：<ul><li>有两个<ul><li>一个为寄存器中的操作数</li><li>一个为存储器中的操作数</li></ul></li><li>能完成计算任务的指令字格式为：<ul><li><img src="/posts/7573/%E6%8C%87%E4%BB%A4%E5%AD%97%E6%A0%BC%E5%BC%8F.png" alt="指令字格式"></li></ul></li></ul></li></ul><h4 id="指令与指令系统简介："><a href="#指令与指令系统简介：" class="headerlink" title="指令与指令系统简介："></a>指令与指令系统简介：</h4><h5 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h5><ul><li>是计算机设计者赋予计算机实现某种基本操作的命令</li><li>一般包含两个字段：<ul><li>操作码字段</li><li>地址码字段</li></ul></li></ul><h5 id="操作码字段："><a href="#操作码字段：" class="headerlink" title="操作码字段："></a>操作码字段：</h5><ul><li>指出计算机要执行什么类型的操作</li><li>即决定了指令的功能</li></ul><h5 id="地址码字段："><a href="#地址码字段：" class="headerlink" title="地址码字段："></a>地址码字段：</h5><ul><li>指出参与操作的操作数或操作数的地址</li><li>即规定了指令的操作对象</li><li>地址码字段的操作对象可以是零个到多个</li></ul><h5 id="指令字："><a href="#指令字：" class="headerlink" title="指令字："></a>指令字：</h5><ul><li>由操作码和地址码共同构成</li></ul><h5 id="指令系统："><a href="#指令系统：" class="headerlink" title="指令系统："></a>指令系统：</h5><ul><li><p>特点：</p><ul><li>包含一台计算机所能执行的所有指令</li><li>表征着计算机的基本功能和使用属性</li><li>计算机只能执行自己指令系统中的指令</li></ul></li><li><p>包括：</p><ul><li>算术运算</li><li>数据传送</li><li>处理机控制</li></ul></li><li><p>假如在某32位字长，设有16个通用寄存器的计算机上进行例1.1要求的计算机</p><ul><li>其指令格式如下：</li><li><img src="/posts/7573/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="指令格式"></li><li>OP<ul><li>操作码，占八位</li><li>表示该机指令系统中最多包含256条指令</li><li>这些指令包括<ul><li>算术运算，例如加，乘</li><li>数据传送，例如存数、取数</li><li>处理机控制，例如停机</li></ul></li></ul></li><li>Ri：<ul><li>操作数在寄存器中的地址</li><li>指向某通用寄存器，用4位表示</li><li>16个通用寄存器的地址（编号）可以分别用16进制的0~F来表示</li></ul></li><li>D：<ul><li>操作数在存储器中的地址</li><li>指向内存储器某存储单元</li><li>用20位表示</li><li>表示该计算机最多能访问2^20个存储单元</li></ul></li><li>该计算机的地址码：<ul><li>由Ri和D共同构成</li></ul></li><li>计算机的指令字:<ul><li>由OP,Ri，D构成</li></ul></li></ul></li><li><p>为完成例1.1工作，该计算机提供5条指令</p><ul><li><p>他们的操作码和指令功能见表1.1</p></li><li><p><img src="/posts/7573/%E8%A1%A81-1.png" alt="表1.1"></p></li><li><p>根据此表</p><ul><li>该指令将寄存器R8中的数据<ul><li>与地址为04000H的存储单元中的数据做加法</li></ul></li><li>结果放入寄存器R8中</li></ul></li><li><p>对于同一条指令的表示，可采用两种方法：</p><ul><li>二进制<ul><li>在计算机中存储的指令为二进制形式</li></ul></li><li>十六进制<ul><li>只是为了方便人们的书写和阅读</li></ul></li></ul></li></ul></li></ul><h4 id="编写求Y的机器语言程序"><a href="#编写求Y的机器语言程序" class="headerlink" title="编写求Y的机器语言程序"></a>编写求Y的机器语言程序</h4><h5 id="编写机器语言程序之前："><a href="#编写机器语言程序之前：" class="headerlink" title="编写机器语言程序之前："></a>编写机器语言程序之前：</h5><ul><li>必须进行存储单元分配</li></ul><h5 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h5><ul><li><p>假定将初始数据x,a,b,c,d分别存放在地址为</p><ul><li>00B00H~00B04H的存储单元中</li></ul></li><li><p>计算结果y存储到地址为00B05H的存储单元</p></li><li><p>程序存放在以00A00H为始地址的存储单元中</p></li><li><p>过程如表：</p></li><li><img src="/posts/7573/求y程序.png" alt="求y程序" style="zoom:60%;"></li><li><p>存储形式：</p><ul><li>如上图，指令和数据<ul><li>都是以代码形式存储在同一存储器的</li><li>计算机在执行时才加以区分</li></ul></li><li>这是冯诺依曼计算机最基本的原理</li></ul></li></ul><h3 id="1-3-2-指令执行过程"><a href="#1-3-2-指令执行过程" class="headerlink" title="1.3.2 指令执行过程"></a>1.3.2 指令执行过程</h3><h4 id="计算机总体框图"><a href="#计算机总体框图" class="headerlink" title="计算机总体框图"></a>计算机总体框图</h4><img src="/posts/7573/计算机总体框图.png" alt="计算机总体框图" style="zoom:67%;"><ul><li>实线箭头：<ul><li>代表数据信号</li></ul></li><li>虚线箭头<ul><li>代表控制信号</li></ul></li></ul><h4 id="指令工作过程简介："><a href="#指令工作过程简介：" class="headerlink" title="指令工作过程简介："></a>指令工作过程简介：</h4><h5 id="计算机工作过程："><a href="#计算机工作过程：" class="headerlink" title="计算机工作过程："></a>计算机工作过程：</h5><ul><li>实质是执行程序的过程<ul><li>执行程序的过程实质是<ul><li>逐条执行指令的过程</li></ul></li></ul></li></ul><h5 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h5><ul><li>取指令过程</li><li>执行指令过程</li></ul><h5 id="取指令过程"><a href="#取指令过程" class="headerlink" title="取指令过程"></a>取指令过程</h5><ul><li>程序计数器PC内容送往内存储器选址系统的MAR，即MAR&lt;-PC</li><li>控制器向内存储器发出读命令<ul><li>内存储器把MAR所指存储单元的内容读出送MBR</li><li>即MBR&lt;-M(MAR)</li><li>注意：此时MBR存放的是指令</li></ul></li><li>程序计数器内容加1<ul><li>为下一条指令准备好地址</li><li>即PC&lt;-PC+1</li></ul></li><li>经系统总线<ul><li>把MBR中的指令送控制器的指令寄存器IR</li><li>即IR&lt;-MBR</li></ul></li></ul><h5 id="执行指令过程"><a href="#执行指令过程" class="headerlink" title="执行指令过程"></a>执行指令过程</h5><ul><li>指令送到IR之后，计算机就进入执行指令过程</li><li>指令操作码经ID译码后<ul><li>确定执行操作的内容</li><li>然后将操作控制信号送入微操作控制部件</li></ul></li><li>在时序部件和运算状态的配合下<ul><li>由微操作控制部件向相关部件</li><li>发送执行该指令需要的所有 <strong>微操作控制信号</strong></li></ul></li><li>指令不同，微操作控制信号序列也不同<ul><li>执行不同的指令，涉及和使用的部件也不相同</li></ul></li><li>有些指令<ul><li>仅涉及和使用控制器部件</li><li>有些既涉及和使用控制器<ul><li>也涉及和使用内存储器、运算器、I/O等部件</li></ul></li></ul></li><li>但无论执行什么部件<ul><li>执行完最后一个微操作后，</li><li>都会返回到取指令的公共操作阶段</li></ul></li></ul><h5 id="以执行加法指令为例说明指令执行过程："><a href="#以执行加法指令为例说明指令执行过程：" class="headerlink" title="以执行加法指令为例说明指令执行过程："></a>以执行加法指令为例说明指令执行过程：</h5><ul><li>当ID译码后，加法控制电位为有效</li><li>在TSG配合下，微操作控制部件首先发出控制信号MAR&lt;-D<ul><li>将存储器操作数的地址送至MAR</li></ul></li><li>然后读存储器<ul><li>并将读出的数据送至MBR</li><li>即MBR&lt;-M(MAR)</li></ul></li><li>接着分别将加数、被加数送往两个锁存器</li><li>最后完成加法操作<ul><li>并将结果送回Ri</li><li>即Ri&lt;-锁存器1+锁存器2</li></ul></li><li>加法指令执行完成后，又回到下一条指令的取指令过程</li><li>如此周而复始执行程序中的每条指令，直至程序执行完毕</li></ul><img src="/posts/7573/指令执行过程.png" alt="指令执行过程" style="zoom:60%;"><h3 id="1-3-3-计算机工作的过程"><a href="#1-3-3-计算机工作的过程" class="headerlink" title="1.3.3 计算机工作的过程"></a>1.3.3 计算机工作的过程</h3><h4 id="程序设计好后如何装入内存储器？"><a href="#程序设计好后如何装入内存储器？" class="headerlink" title="程序设计好后如何装入内存储器？"></a>程序设计好后如何装入内存储器？</h4><ul><li>通过操作系统下的调试程序<ul><li>送到内存储器指令存储区域</li></ul></li><li>同时通过它把机器语言程序的始地址送给程序计数器PC</li></ul><h4 id="例1-1计算机工作过程"><a href="#例1-1计算机工作过程" class="headerlink" title="例1.1计算机工作过程"></a>例1.1计算机工作过程</h4><h5 id="启动计算机："><a href="#启动计算机：" class="headerlink" title="启动计算机："></a>启动计算机：</h5><ul><li>把程序始地址00A00H送PC</li><li>然后可启动计算机工作<ul><li>计算机开始执行程序<ul><li>即开始了指令执行的过程</li></ul></li></ul></li></ul><h5 id="指令执行的过程："><a href="#指令执行的过程：" class="headerlink" title="指令执行的过程："></a>指令执行的过程：</h5><ul><li>从00A00H存储单元取出指令10800B01H放入IR</li><li>PC内容加1变为00A01H</li><li>IR的内容经ID译码发现是取数指令</li><li>于是在执行指令阶段<ul><li>将存储单元00B01H中的数a读到R8寄存器中</li></ul></li><li>接着又进入取指令阶段<ul><li>从00A01H存储单元取出指令08800 B00H放入IR</li><li>PC内容加1变为00A02H</li><li>IR的内容经ID译码发现是乘法指令</li></ul></li><li>于是在执行指令阶段<ul><li>从00B00H存储单元取出乘数</li><li>将它与R8中的被乘数a进行乘法运算</li><li>乘积存入R8</li></ul></li><li>接着又从00A02H存储单元取出指令02800B02H放入IR<ul><li>PC内容加1变成00A03H</li><li>IR的内容经ID译码发现是加法指令</li><li>执行加法指令</li></ul></li><li>如果此执行程序中的每条指令<ul><li>直至从00A08H存储单元取出停机指令并执行</li><li>停机指令使TSG不再发出节拍信号</li><li>计算机也停止了指令执行过程</li><li>该程序执行完毕</li></ul></li></ul><h2 id="1-4-计算机的性能指标和分类"><a href="#1-4-计算机的性能指标和分类" class="headerlink" title="1.4 计算机的性能指标和分类"></a>1.4 计算机的性能指标和分类</h2><h3 id="1-4-1-计算机的性能指标"><a href="#1-4-1-计算机的性能指标" class="headerlink" title="1.4.1 计算机的性能指标"></a>1.4.1 计算机的性能指标</h3><h4 id="与硬件相关的几个性能指标："><a href="#与硬件相关的几个性能指标：" class="headerlink" title="与硬件相关的几个性能指标："></a>与硬件相关的几个性能指标：</h4><ul><li>主频</li><li>运算速度</li><li>运算精度</li><li>主存存储容量</li><li>主存存储周期</li></ul><h4 id="主频："><a href="#主频：" class="headerlink" title="主频："></a>主频：</h4><h5 id="主频（或时钟周期）："><a href="#主频（或时钟周期）：" class="headerlink" title="主频（或时钟周期）："></a>主频（或时钟周期）：</h5><ul><li>是计算机的主要性能指标之一</li><li>很大程度上决定计算机的运行速度</li></ul><h5 id="主频的特点："><a href="#主频的特点：" class="headerlink" title="主频的特点："></a>主频的特点：</h5><ul><li>主频越高<ul><li>CPU的工作节拍就越快</li><li>运算速度就越高</li></ul></li><li>主频通常用一秒钟内处理器能发出电子脉冲数来表示<ul><li>单位一般为兆赫兹MHZ</li></ul></li></ul><h5 id="时钟CP："><a href="#时钟CP：" class="headerlink" title="时钟CP："></a>时钟CP：</h5><ul><li>CPU的工作节拍是由时钟CP控制的</li><li>时钟不断产生固定频率的时钟脉冲</li><li>这个脉冲就是 CPU的 <strong>主频f</strong></li></ul><h5 id="以Intel系列微型计算机为例："><a href="#以Intel系列微型计算机为例：" class="headerlink" title="以Intel系列微型计算机为例："></a>以Intel系列微型计算机为例：</h5><ul><li>最早8086的主频为5MHZ</li><li>80386的主频为16MHZ</li><li>586的主频可达到266MHZ</li><li>奔腾二代的主频可达450MHZ</li><li>奔腾三代的主频可达1.2GHZ</li><li>奔腾四代的主频现已达3GHZ甚至更高</li></ul><h4 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h4><h5 id="运算速度的概念："><a href="#运算速度的概念：" class="headerlink" title="运算速度的概念："></a>运算速度的概念：</h5><ul><li>是计算机工作能力和工作效率的主要表征</li><li>取决于在给定时间内处理器所能处理的数据量以及处理器的时钟频率</li></ul><h5 id="运算速度的表示："><a href="#运算速度的表示：" class="headerlink" title="运算速度的表示："></a>运算速度的表示：</h5><ul><li>通常用每秒执行指令的条数来表示</li><li>计量单位：<ul><li>MIPS 百万条指令每秒<ul><li>用来描述计算机的定点运算速度</li></ul></li><li>MFLOPS 百万次浮点预算每秒<ul><li>用来描述计算机的浮点运算速度</li></ul></li></ul></li></ul><h5 id="运算速度的计算方法："><a href="#运算速度的计算方法：" class="headerlink" title="运算速度的计算方法："></a>运算速度的计算方法：</h5><h6 id="吉普森混合法："><a href="#吉普森混合法：" class="headerlink" title="吉普森混合法："></a>吉普森混合法：</h6><ul><li>也称 混合比率计算法</li><li>原理<ul><li>从应用课题程序中统计各类指令所占百分比</li><li>然后用指令混合比计算指令的平均执行速度</li></ul></li><li>具体计算方法：<ul><li>假定第i类指令(i=1,2,…,n)在使用过程中<ul><li>出现的概率为P</li><li>执行时间为ti</li><li>则指令的平均执行时间tE为：<ul><li><img src="/posts/7573/%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4.png" alt="执行时间"></li><li>tE的倒数是 吉布森混合法平均执行速度<ul><li>其中Pi的集合即为混合比</li></ul></li></ul></li></ul></li></ul></li><li>缺陷：<ul><li>现代计算机的指令系统十分复杂<ul><li>不少指令执行时间不固定</li><li>采用固定比例可能脱离实际</li><li>所以这种方法较少采用</li></ul></li></ul></li></ul><h6 id="计算各种指令的执行速度"><a href="#计算各种指令的执行速度" class="headerlink" title="计算各种指令的执行速度"></a>计算各种指令的执行速度</h6><ul><li>原理：<ul><li>根据计算机的主频f（MHZ）</li><li>求出处理器的基本节拍周期T=1/f（ns）</li><li>再根据处理器结构模型和指令操作流程</li><li>可推算出 <ul><li>执行各种指令的基本节拍数 和每秒执行指令的条数</li></ul></li></ul></li><li>缺陷：<ul><li>这种方法得到的性能并不十分精确<ul><li>有时甚至做了一些理想化的假定<ul><li>例如：假定全部功能部件都处在满负荷的最佳工作状态下</li></ul></li><li>这种在理想状态下得到的最佳性能被称为 <strong>峰值执行速度</strong><ul><li>在实际指令执行时是不可能出现的</li></ul></li></ul></li></ul></li></ul><h6 id="计算典型程序的运算速度"><a href="#计算典型程序的运算速度" class="headerlink" title="计算典型程序的运算速度"></a>计算典型程序的运算速度</h6><ul><li>选取应用中具有代表性的课题<ul><li>eg：<ul><li>快速傅里叶变换FFT</li><li>图形图像的处理</li><li>等等</li></ul></li><li>计算这些典型程序的运算速度</li></ul></li></ul><h6 id="计算计算机运算速度其他方法："><a href="#计算计算机运算速度其他方法：" class="headerlink" title="计算计算机运算速度其他方法："></a>计算计算机运算速度其他方法：</h6><ul><li>模型分析与模型模拟</li><li>实际测量</li><li>等等</li></ul><h4 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a>运算精度</h4><h5 id="衡量标准："><a href="#衡量标准：" class="headerlink" title="衡量标准："></a>衡量标准：</h5><ul><li>运算精度通常用计算机能直接处理的 <strong>二进制信息位数</strong> 来衡量</li></ul><h5 id="二进制信息位数："><a href="#二进制信息位数：" class="headerlink" title="二进制信息位数："></a>二进制信息位数：</h5><ul><li>特点：<ul><li>一般与CPU中存储数据寄存器的位数相同</li><li>位数越多，精度越高</li></ul></li></ul><h5 id="基本字长："><a href="#基本字长：" class="headerlink" title="基本字长："></a>基本字长：</h5><ul><li>定义：<ul><li>参与运算操作数的基本位数成为 <strong>基本字长</strong></li></ul></li><li>特点：<ul><li>在一定情况下标志着计算精度</li><li>决定着<ul><li>寄存器</li><li>加法器</li><li>数据总线<ul><li>等的位数</li></ul></li></ul></li><li>直接影响着硬件的造价</li></ul></li></ul><h5 id="变字长计算："><a href="#变字长计算：" class="headerlink" title="变字长计算："></a>变字长计算：</h5><ul><li>原因：<ul><li>为适应不同类型计算的需要</li><li>并较好地协调精度与造价的关系</li></ul></li><li>eg：<ul><li>半字长</li><li>全字长</li><li>双字长</li><li>等等</li></ul></li></ul><h5 id="计算机字长："><a href="#计算机字长：" class="headerlink" title="计算机字长："></a>计算机字长：</h5><ul><li>早期微型计算机<ul><li>字长多为 <strong>8位</strong> 和 <strong>16</strong>位</li><li>现在多为 <strong>32</strong>位</li></ul></li><li>大中型计算机<ul><li>多为 <strong>32</strong>位 和 <strong>64位</strong></li></ul></li><li>巨型计算机<ul><li>一般都是 <strong>64</strong>位</li></ul></li></ul><h4 id="主存存储容量"><a href="#主存存储容量" class="headerlink" title="主存存储容量"></a>主存存储容量</h4><h5 id="主存储器作用："><a href="#主存储器作用：" class="headerlink" title="主存储器作用："></a>主存储器作用：</h5><ul><li>用来存储数据和程序</li><li>直接与CPU交换信息</li></ul><h5 id="主存储器特点："><a href="#主存储器特点：" class="headerlink" title="主存储器特点："></a>主存储器特点：</h5><ul><li>主存容量越大<ul><li>可存储的数据和程序就越多</li><li>处理问题的能力也就越强</li></ul></li><li>主存与外存储器的<ul><li>信息交换次数越少</li><li>系统的效率就越高</li></ul></li></ul><h5 id="主存容量的地位"><a href="#主存容量的地位" class="headerlink" title="主存容量的地位;"></a>主存容量的地位;</h5><ul><li>是衡量计算机的主要性能指标之一</li></ul><h5 id="主存容量的表示："><a href="#主存容量的表示：" class="headerlink" title="主存容量的表示："></a>主存容量的表示：</h5><ul><li>以字为单位的计算机<ul><li>常用 <strong>字数</strong> 乘以 <strong>字长</strong> 表示主存容量</li><li>eg：<ul><li>4K x 16位<ul><li>表示主存有4096个存储单元</li><li>每个单元字长16位</li></ul></li></ul></li></ul></li><li>以字节为单位的计算机<ul><li>以 <strong>字节数</strong> 表示主存容量</li><li>eg：<ul><li>32KB</li><li>表示主存容量为<ul><li>32768x8位</li></ul></li></ul></li></ul></li></ul><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><ul><li>现在的高档微机<ul><li>主存容量从128MB,256MB不等</li><li>有的为2GB甚至更高</li></ul></li></ul><h4 id="主存存取周期"><a href="#主存存取周期" class="headerlink" title="主存存取周期"></a>主存存取周期</h4><h5 id="“写入”的定义："><a href="#“写入”的定义：" class="headerlink" title="“写入”的定义："></a>“写入”的定义：</h5><ul><li>将信息存入主存</li></ul><h5 id="“读出”的定义："><a href="#“读出”的定义：" class="headerlink" title="“读出”的定义："></a>“读出”的定义：</h5><ul><li>将信息从主存中取出</li></ul><h5 id="“访存”的定义："><a href="#“访存”的定义：" class="headerlink" title="“访存”的定义："></a>“访存”的定义：</h5><ul><li>对主存的读写</li></ul><h5 id="存取周期："><a href="#存取周期：" class="headerlink" title="存取周期："></a>存取周期：</h5><ul><li>定义：<ul><li>对主存连续两次访存所允许的最小时间间隔</li></ul></li><li>地位：<ul><li>既是 表征主存性能的基本参数</li><li>也是反应计算机整机性能的重要参数</li></ul></li><li>特点：<ul><li>存取周期越小<ul><li>表明从主存存取信息的时间越短</li><li>计算机系统性能越高</li></ul></li></ul></li><li>数值：<ul><li>现代 计算机主存存取周期 一般在<ul><li>几十纳秒</li><li>有时甚至几个纳秒</li></ul></li></ul></li></ul><h5 id="计算机技术性能评价的因素："><a href="#计算机技术性能评价的因素：" class="headerlink" title="计算机技术性能评价的因素："></a>计算机技术性能评价的因素：</h5><ul><li><p>计算机技术性能高低好坏，考虑因素应多方面：</p><ul><li>如<ul><li>系统结构、硬件组成、外设配置</li><li>软件种类、吞吐率、响应时间</li><li>可靠性、可用性、可维性</li><li>完整性、安全性</li></ul></li><li>不能片面强调一项指标，应综合全面考虑</li></ul></li><li><p>综合性指标：</p><ul><li>通常以 <strong>性能价格比</strong> 为综合性指标</li><li>性能：<ul><li>指机器的综合性能</li><li>包括：<ul><li>硬件、软件的各种性能</li></ul></li></ul></li><li>价格：<ul><li>指的是整个系统的价格</li></ul></li><li>性能价格比 <strong>越大越好</strong><ul><li>它是选择和设计计算机的重要依据</li></ul></li></ul></li></ul><h3 id="1-4-2-计算机的分类"><a href="#1-4-2-计算机的分类" class="headerlink" title="1.4.2 计算机的分类"></a>1.4.2 计算机的分类</h3><h4 id="电子计算机的定义："><a href="#电子计算机的定义：" class="headerlink" title="电子计算机的定义："></a>电子计算机的定义：</h4><ul><li>是一种由电子线路构成的设备</li><li>能对信息进行记忆、传送、处理<ul><li>从而实现计算的功能</li></ul></li></ul><h4 id="计算机常见分类方法："><a href="#计算机常见分类方法：" class="headerlink" title="计算机常见分类方法："></a>计算机常见分类方法：</h4><ul><li>按计算机用途分类：<ul><li>通用计算机</li><li>专用计算机</li></ul></li><li>按计算机规模分类：<ul><li>巨型机</li><li>大型计算机</li><li>小型计算机</li><li>微型计算机</li><li>单片机</li></ul></li></ul><h4 id="专用计算机："><a href="#专用计算机：" class="headerlink" title="专用计算机："></a>专用计算机：</h4><ul><li><p>定义：</p><ul><li>是针对某一特定应用领域<ul><li>或面向某种算法</li><li>的计算机</li></ul></li></ul></li><li><p>eg：</p><ul><li>工业过程中的控制计算机</li><li>军事上武器设备的控制指挥仪</li><li>卫星图像处理和天气预报使用的大型并行处理机</li><li>等等</li></ul></li><li><p>特点：</p><ul><li>专用机的结构和软件是专门针对其应用领域设计的</li><li>因而对该领域的应用是高效的</li></ul></li><li><p>缺点：</p><ul><li>若用于其他领域<ul><li>则效率较低甚至无法运行</li></ul></li></ul></li><li><p>优点：</p><ul><li>功能单一、结构较简单</li><li>成本较低、可靠性较高</li></ul></li></ul><h4 id="通用计算机"><a href="#通用计算机" class="headerlink" title="通用计算机"></a>通用计算机</h4><ul><li>定义：<ul><li>即人们常说的计算机</li></ul></li><li>配置:<ul><li>通常根据不同计算机系列型号配备一定外设</li><li>它配备多种系统软件<ul><li>eg：<ul><li>操作系统</li><li>数据库管理软件</li><li>多种工具软件</li></ul></li></ul></li><li>只要再配备相应应用软件<ul><li>就可以应用于各种领域</li></ul></li></ul></li><li>特点：<ul><li>通用性强</li><li>功能全</li></ul></li></ul><h4 id="规模："><a href="#规模：" class="headerlink" title="规模："></a>规模：</h4><ul><li>是综合计算机多方面因素而言</li><li>通常涉及<ul><li>计算机的运算速度、字长、存储容量、外部设备等硬件配置</li><li>以及软件、价格等诸多方面</li></ul></li><li>按规模分类实际是<ul><li>按计算机性能分类</li></ul></li><li>变化：<ul><li>随计算机科学技术飞速发展<ul><li>这种规模或性能的概念也在不断变化</li></ul></li><li>昔日超级计算机<ul><li>可能赶不上现在的微型机</li></ul></li></ul></li></ul><h4 id="巨型机："><a href="#巨型机：" class="headerlink" title="巨型机："></a>巨型机：</h4><ul><li>名称：<ul><li>Supercomputer</li><li>也称 超级计算机</li></ul></li><li>地位：<ul><li>是一个国家科技水平、经济水平、军事威力的象征<ul><li>目前只有美英俄法日等少数几个国家拥有巨型机</li></ul></li></ul></li><li>优点：<ul><li>速度最快、性能最高</li><li>功能最强、技术最复杂</li></ul></li><li>作用：<ul><li>拥有巨大的数值计算和信息处理能力</li><li>是计算机高精尖技术的集中代表</li></ul></li><li>特点：<ul><li>一般字长为64位</li><li>每秒平均执行百亿次以上的浮点运算</li><li>主存容量1~4百万字以上</li><li>其高速数据通道每秒可传送数据几千万个字以上</li><li>具有丰富的系统软件</li></ul></li><li>举例：<ul><li>IBM公司SP2系列<ul><li>速度可达每秒3万亿次浮点运算</li></ul></li><li>Intel公司使用Pentium Pro构成的巨型计算机Paragon<ul><li>速度可达到每秒1万亿次</li></ul></li><li>我国自行研制的<ul><li>银河二型巨型机<ul><li>运算速度达到每秒10亿次</li></ul></li><li>银河三型巨型机<ul><li>运算速度达到每秒130亿次</li></ul></li><li>曙光巨型机<ul><li>运算速度达到每秒3000亿次</li></ul></li></ul></li></ul></li></ul><h4 id="大型计算机"><a href="#大型计算机" class="headerlink" title="大型计算机"></a>大型计算机</h4><ul><li>名称：<ul><li>Large Scale Computer/Mainframe</li></ul></li><li>地位：<ul><li>是计算机家族中 通用性最强、功能很强的计算机</li><li>是体现所在时代计算机科技水平的一类高性能大容量计算机</li></ul></li><li>特点：<ul><li>一般字节32~64位</li><li>每秒执行数百万到数千万条指令</li><li>主存容量几十万到几百万字</li><li>有较多的外设和通信接口</li><li>有很强的I/O处理能力和丰富的系统软件及应用软件</li></ul></li><li>典型机种：<ul><li>20世纪<ul><li>60年代的IBM360系列</li><li>70年代的IBM370系列</li><li>80年代的IBM 370-XA系列</li><li>90年代的IBM390系列</li></ul></li></ul></li></ul><h4 id="小型计算机"><a href="#小型计算机" class="headerlink" title="小型计算机"></a>小型计算机</h4><ul><li>名称：<ul><li>Minicomputer</li></ul></li><li>优点：<ul><li>性能较好</li><li>价格便宜</li><li>应用领域广泛</li></ul></li><li>特点：<ul><li>一般字长32位</li><li>速度每秒几十万到几百万次</li><li>内存容量几万到几十万字</li><li>配有一定数量的外设与通信接口</li><li>有汇编语言和多种高级语言</li><li>有功能较强的操作系统</li></ul></li><li>超级小型计算机：<ul><li>Super Minicomputer</li><li>处理能力、内存容量、操作系统功能远超一般小型计算机</li></ul></li><li>典型机种：（包括小型与超级小型)<ul><li>NOVA系列</li><li>PDP-11系列</li><li>VAX-11系列</li><li>MicroVAX系列</li><li>王安VS系列</li></ul></li></ul><h4 id="微型计算机"><a href="#微型计算机" class="headerlink" title="微型计算机"></a>微型计算机</h4><ul><li>简称：<ul><li>微型机</li><li>微机</li></ul></li><li>特点：<ul><li>以微处理器为中央处理器</li></ul></li><li>优点：<ul><li>性能价格比最高</li><li>应用领域最广</li></ul></li><li>发展状况：<ul><li>发展最快、市场占有率最高</li><li>许多性能达到甚至超过小型机水平</li><li>正不断向微型化、网络化、高性能、多用途方向发展</li></ul></li><li>分类方法：<ul><li>按字长分：<ul><li>8位</li><li>16位</li><li>32位</li></ul></li><li>按组装形式分：<ul><li>非便携式<ul><li>eg：台式机</li></ul></li><li>便携式<ul><li>eg：可移动的微型机<ul><li>笔记本型或掌上型计算机</li></ul></li></ul></li></ul></li><li>按最终是否由用户使用分：<ul><li>独立式<ul><li>可由最终用户直接使用</li><li>eg：个人计算机 PC Personal Computer</li></ul></li><li>嵌入式<ul><li>将其作为一个信息处理部件装入一个应用设备</li><li>最终用户不直接使用计算机，而使用该设备</li><li>eg：<ul><li>包含计算机的医疗设备、家用电器等</li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="单片机："><a href="#单片机：" class="headerlink" title="单片机："></a>单片机：</h4><ul><li>定义：<ul><li>将中央处理器、存储器、输入输出接口集成在一块芯片上的微型计算机<ul><li>简称：<ul><li>单片机 Single Chip Computer</li></ul></li></ul></li><li>由于主要应用于控制系统，所以又通常称：<ul><li>微控制器 Micro Control Unit ,MCU</li></ul></li></ul></li><li>特点：<ul><li>一般采用 <strong>面向控制</strong> 的系统结构和指令系统</li><li>字长<ul><li>从4位、8位、到16位</li><li>20世纪90年代推出32位单片机</li></ul></li><li>显著特点：<ul><li>多功能的输入、输出结构</li></ul></li></ul></li><li>常有：<ul><li>定时计数器</li><li>并行接口</li><li>串行接口</li><li>数模转换器</li><li>模数转换器</li></ul></li><li>地位：<ul><li>与个人计算器一样，是目前应用最广、产量最高的两种计算机</li></ul></li><li>应用：<ul><li>单片机 多作为MCU装入各种设备<ul><li>是嵌入式微型化计算机最主要的形式</li></ul></li><li>通常在家用电器、一般控制及高速控制等应用领域</li><li>家用电器中：<ul><li>多采用4位单片机或低档8位单片机</li></ul></li><li>在一般控制应用中：<ul><li>多采用高性能8位或16位单片机</li></ul></li><li>在高速控制应用中：<ul><li>多采用高性能16位或32位单片机</li></ul></li></ul></li></ul><h2 id="1-5-计算机应用与发展"><a href="#1-5-计算机应用与发展" class="headerlink" title="1.5 计算机应用与发展"></a>1.5 计算机应用与发展</h2><h3 id="1-5-1-计算机的应用"><a href="#1-5-1-计算机的应用" class="headerlink" title="1.5.1 计算机的应用"></a>1.5.1 计算机的应用</h3><h4 id="大体分类："><a href="#大体分类：" class="headerlink" title="大体分类："></a>大体分类：</h4><ul><li><p>科学计算</p></li><li><p>数据处理</p></li><li><p>实时控制</p></li><li><p>辅助设计</p></li><li><p>智能模拟</p><p>（虽覆盖计算机大多数领域，但未能包括全部）</p></li></ul><h4 id="1-科学计算"><a href="#1-科学计算" class="headerlink" title="1.科学计算"></a>1.科学计算</h4><ul><li>是计算机一个重要领域</li><li>有效地使用数字计算机<ul><li>来求解数学问题的近似解的理论、方法和过程<ul><li>已形成专门的学科：</li><li>数值计算 Numerical Computation</li></ul></li></ul></li><li>eg:<ul><li>求解上千阶微分方程组</li></ul></li><li>大大促进科学研究与国民经济发展</li></ul><h4 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2.数据处理"></a>2.数据处理</h4><ul><li>主要功能：<ul><li>将输入设备送来的数据及时记录、整理、分类、加工<ul><li>以得到需要的信息</li></ul></li><li>eg：<ul><li>企业管理、库存管理、账目计算、情报检索、图像处理等等</li></ul></li></ul></li><li>特点：<ul><li>原始数据量大、算数运算比较简单、有大量逻辑与判断</li><li>处理的结果多以报表或文件形式存储或输出</li><li>对于这些工作，人力无法完成，采用计算机可很快得出结果</li></ul></li><li>实例：<ul><li>利用数据库系统软件，如Sybase,Oracle,Access等开发的各种应用软件系统<ul><li>eg：<ul><li>财务管理系统、交通客票预定系统、人事管理系统</li><li>办公自动化系统、数字地图系统、情报分析与检测系统</li></ul></li></ul></li></ul></li><li>优点：<ul><li>使人们从大量繁杂的数据统计与管理事务中解脱出来<ul><li>大大提高了工作效率与质量</li></ul></li><li>利用计算机网络与通信技术<ul><li>实现资源共享与远程信息传输</li><li>更使数据处理这类应用焕发生机</li></ul></li></ul></li></ul><h4 id="3-实时控制："><a href="#3-实时控制：" class="headerlink" title="3.实时控制："></a>3.实时控制：</h4><ul><li>是计算机在过程控制中的重要应用</li><li>“实时”的定义：<ul><li>就是指计算机的运算和控制时间与被控制过程的实际时间相适应</li></ul></li><li>“实时性”<ul><li>是以计算机速度为基础的</li><li>不同受控对象其物理过程的时间参数是不同的</li><li>eg：<ul><li>生产过程控制时间参数较大<ul><li>对计算机速度要求不高</li></ul></li><li>对武器发射过程控制时间参数较小<ul><li>对计算机速度要求高</li></ul></li></ul></li></ul></li><li>过程控制应用：<ul><li>最初：<ul><li>主要应用于导弹、卫星、飞船等</li><li>现代化武器系统和航空航天等领域</li></ul></li><li>现在：<ul><li>已广泛运用于工业生产过程</li><li>过程控制发挥神经系统功能<ul><li>由于高灵敏度、高精确度控制</li><li>使得上述领域工作能在人的意志控制下准确无误完成</li></ul></li></ul></li></ul></li></ul><h4 id="4-辅助设计"><a href="#4-辅助设计" class="headerlink" title="4.辅助设计"></a>4.辅助设计</h4><ul><li>定义：<ul><li>Computer Aided Design,CAD</li><li>是利用计算机能帮助设计人员进行工程、产品等设计工作的过程和技术</li></ul></li><li>应用：<ul><li>在航天航空、船舶交通、机械电子、基建和化工等部门</li><li>由计算机辅助产生的设计结果通过图形设备与设计人员交互<ul><li>可及时对设计进行判断和修改</li><li>最终完成设计工作</li></ul></li></ul></li><li>优点：<ul><li>提高了设计的自动化水平</li><li>缩短了设计周期</li><li>减轻了设计人员的劳动</li><li>大大提高了设计质量</li></ul></li><li>计算机辅助制造CAM：<ul><li>CAD发展带动了CAM进步</li><li>定义：<ul><li>CAM是在制造业中<ul><li>利用计算机辅助各种设备完成产品的加工、装配、检测、和包装等的过程和技术</li></ul></li></ul></li><li>优点：<ul><li>显著提高了企业的生产效率</li><li>缩短了工作周期</li><li>降低了产品成本</li><li>提高了产品质量</li></ul></li><li>CAD/CAM系统：<ul><li>有CAD与CAM紧密结合一起而构成</li></ul></li></ul></li><li>计算机辅助教学CAI：<ul><li>定义：<ul><li>是利用计算机辅助教师对学生进行教学的过程和技术</li></ul></li><li>最大特点：<ul><li>在计算机和学生之间实现对话</li><li>学生可以根据个人特点进行学习，变被动为主动</li><li>生动直观形象，极大提高学习兴趣与效果</li></ul></li></ul></li></ul><h4 id="5-智能模拟"><a href="#5-智能模拟" class="headerlink" title="5.智能模拟"></a>5.智能模拟</h4><h5 id="人工智能："><a href="#人工智能：" class="headerlink" title="人工智能："></a>人工智能：</h5><ul><li>地位：<ul><li>是计算机应用研究最前沿的学科</li></ul></li><li>定义：<ul><li>是采用计算机来研究开发用于模拟、延伸和扩展人的只能</li><li>eg：智能、推理、学习、理解</li><li>是在质的方面扩充计算机的能力<ul><li>提高它的智能水平</li></ul></li></ul></li><li>研究与应用：<ul><li>已在模式识别、景物分析、自然语言的理解与生成</li><li>博弈、自动定理证明、自动程序设计、专家系统</li><li>模拟训练系统、智能决策系统以及机器人领域得到发展</li></ul></li></ul><h5 id="智能模拟："><a href="#智能模拟：" class="headerlink" title="智能模拟："></a>智能模拟：</h5><ul><li>优点：<ul><li>将计算机的应用提高到了一个更高的阶段</li><li>为计算机的推广应用开拓出一个全新的领域</li></ul></li></ul><h3 id="1-5-2-计算机发展前景"><a href="#1-5-2-计算机发展前景" class="headerlink" title="1.5.2 计算机发展前景"></a>1.5.2 计算机发展前景</h3><h4 id="趋势："><a href="#趋势：" class="headerlink" title="趋势："></a>趋势：</h4><ul><li>巨型化</li><li>微型化</li><li>网络化</li><li>智能化</li></ul><h4 id="1-巨型化："><a href="#1-巨型化：" class="headerlink" title="1.巨型化："></a>1.巨型化：</h4><ul><li>原因：<ul><li>航空航天、气象预报、地震分析、原子裂变、生物工程等领域中<ul><li>大型科学计算和数据处理的需要</li><li>对超大规模、高性能巨型计算机提出永无止境的性能要求</li></ul></li></ul></li><li>实例：<ul><li>日本NEC公司2002年制造的Earth-Simulator超级计算机<ul><li>由5120个处理器构成</li><li>每秒能完成35亿次的浮点运算</li><li>它是世界上最快的计算机</li></ul></li></ul></li></ul><h4 id="2-微型化："><a href="#2-微型化：" class="headerlink" title="2.微型化："></a>2.微型化：</h4><ul><li>计算机向微型化、高性能、多用途方向发展</li><li>原因：<ul><li>微处理器芯片性能不断提高<ul><li>eg：奔腾4芯片主频已达到3GHz以上</li><li>目前微处理器芯片计算能力已经超过早期巨型机计算能力</li></ul></li><li>微型机所需的配套期间的性能也在不断提高<ul><li>如：<ul><li>主存芯片的集成度、读写速度和数据传输率</li><li>光盘、移动硬盘和硬盘的容量、速度和数据传输率</li><li>显示器的综合性能</li><li>各种多媒体和大量预装软件等</li></ul></li></ul></li></ul></li></ul><h4 id="3-网络化："><a href="#3-网络化：" class="headerlink" title="3.网络化："></a>3.网络化：</h4><ul><li>原因：<ul><li>Internet建立与信息高速公路崛起<ul><li>使人类社会处理和传播信息能力大大增强</li></ul></li><li>为适应网络化需要<ul><li>可移动式计算机及网络配套用的硬件与软件不断推出新产品<ul><li>eg：<ul><li>调制解调器，声卡</li><li>视频卡，电源等装置</li></ul></li></ul></li></ul></li></ul></li><li>将成为 信息时代和知识经济时代强大的助推器</li></ul><h4 id="4-智能化："><a href="#4-智能化：" class="headerlink" title="4.智能化："></a>4.智能化：</h4><ul><li><p>应用：</p><ul><li>计算机科学与控制论、仿生学、心理学等等相结合</li><li>用计算机模拟人类的某些智能行为<ul><li>如触觉、嗅觉、视觉等感觉功能</li><li>对声音、图像、图形及其他模式的识别能力</li><li>提供只是进行推理和自我学习的能力等等</li></ul></li></ul></li><li><p>优点：</p><ul><li><p>使计算机不但能储存、计算和处理数据</p></li><li><p>而且在模式识别、定理证明、学习研究、联想探索、语言理解等领域都成为人类助手</p></li></ul></li></ul><h4 id="计算机发展特点："><a href="#计算机发展特点：" class="headerlink" title="计算机发展特点："></a>计算机发展特点：</h4><ul><li><p>新型元器件、体系结构及实现技术的发展，将大大提高计算机系统性能及性能价格比</p><ul><li>eg：<ul><li>集成电路纳米极微细加工技术<ul><li>促使提高半导体各种芯片集成度、速度</li></ul></li><li>光电子器件与生物器件若产生<ul><li>将提高计算机运算速度</li></ul></li><li>计算机辅助技术及信息工艺技术应用<ul><li>将使计算机整体性能大幅提高</li></ul></li></ul></li></ul></li><li><p>计算机与通信技术融合与渗透，将加速人类社会信息化进程</p><ul><li>全球性计算机联网<ul><li>促进信息资源的开发与利用</li></ul></li><li>计算机成为人类生活必需品<ul><li>计算机科学与技术成为人类必须学习与具备基础知识</li></ul></li></ul></li><li><p>以智能化、集成化、自动化、并行化、开放化、自然化为标志的</p><ul><li>计算机软件新技术的而深入研究、开发与利用</li><li>不但将软件的功能与性能迅速提高</li><li>还将解决软件生产率低下的问题<ul><li>软件理论与软件工程发展<ul><li>将从理论与实践两方面解决计算机系统开发的软件瓶颈问题</li></ul></li><li>信息产业与软件产业将成为新的经济增长点<ul><li>成为国民经济的支柱产业</li></ul></li></ul></li></ul></li><li><p>在Internet与信息高速公路迅速发展普及形势下</p><ul><li>为保证信息资源共享</li><li>计算机系统与网络的互操作性、开放性、标准化将受到高度重视</li></ul></li><li><p>完全新型的计算机不断问世</p><ul><li>传统计算机：<ul><li>基本工作方式：<ul><li>是顺序执行指令的串行工作方式</li></ul></li><li>将导致传统计算机在并行处理、字符处理、知识处理等方面的低效能</li></ul></li><li>为突破传统的存储程序计算机结构的局限性<ul><li>人们研究开发了一些非传统计算机</li><li>例如：<ul><li>数据流计算机、归约机、</li><li>逻辑推理机、神经计算机等</li></ul></li></ul></li><li>为进一步提高计算机系统的性能<ul><li>研究开发不采用传统电子器件的计算机也是一个重要方向与课题</li><li>eg：<ul><li>光计算机</li><li>生物计算机</li><li>量子计算机</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 绿皮书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-10-可靠性测试</title>
      <link href="/posts/41234.html"/>
      <url>/posts/41234.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件可靠性定义"><a href="#软件可靠性定义" class="headerlink" title="软件可靠性定义"></a>软件可靠性定义</h2><ul><li>软件可靠性<ul><li>是软件系统在规定的时间内及规定的环境条件下</li><li>完成规定功能的能力</li></ul></li></ul><h2 id="软件可靠性三要素"><a href="#软件可靠性三要素" class="headerlink" title="软件可靠性三要素"></a>软件可靠性三要素</h2><ul><li>规定的时间</li><li>规定的运行环境条件</li><li>规定的功能</li></ul><h2 id="可靠性的度量"><a href="#可靠性的度量" class="headerlink" title="可靠性的度量"></a>可靠性的度量</h2><ul><li>可靠性的最常用的度量<ul><li>是平均无故障时间</li></ul></li><li>例如：<ul><li>通过压力测试</li><li>并借助<ul><li>软件失效模式</li><li>影响分析<ul><li>来获得有关可靠性数据</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.9 容错性测试</title>
      <link href="/posts/54896.html"/>
      <url>/posts/54896.html</url>
      
        <content type="html"><![CDATA[<h2 id="容错性测试的分类"><a href="#容错性测试的分类" class="headerlink" title="容错性测试的分类"></a>容错性测试的分类</h2><ul><li>负面测试</li><li>故障转移测试</li></ul><h2 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h2><ul><li><p>容错性测试就是</p><ul><li>在各种异常条件下对系统的功能进行测试</li><li>以检验系统是否具有防护性的举措或者某种灾难性恢复的手段或能力</li></ul></li><li><p>容错性可分为两个层次：</p><ul><li>功能层次的容错性测试<ul><li>也称 <strong>负面</strong> 测试<ul><li>negative test</li></ul></li><li>或 <strong>例外</strong> 测试<ul><li>exception test</li></ul></li></ul></li><li>系统层次的容错性测试<ul><li>主要是<ul><li>灾难恢复性测试</li><li>故障转移测试</li></ul></li></ul></li></ul></li></ul><h2 id="负面测试"><a href="#负面测试" class="headerlink" title="负面测试"></a>负面测试</h2><ul><li><p>负面测试</p><ul><li>是从<strong>逆向思维</strong>出发</li><li>检查系统在 <strong>异常条件</strong> 下或用户的 <strong>非法操作</strong> 下系统是如何 <strong>响应</strong> 的</li><li>是否有 <strong>异常行为</strong> 或执行了 <strong>不应该执行的动作</strong></li></ul></li><li><p>无效等价类的测试用例就是一种 <strong>负面的测试</strong></p></li><li><p>在一些 <strong>异常的</strong> 或 <strong>恶劣</strong>的条件下进行操作</p></li><li><p><strong>探索式</strong> 测试</p></li></ul><h2 id="故障转移机制"><a href="#故障转移机制" class="headerlink" title="故障转移机制"></a>故障转移机制</h2><p><img src="/posts/54896/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6.jpg" alt="故障转移机制"></p><h2 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h2><ul><li>故障转移测试<ul><li>就是验证 <strong>故障转移机制</strong> 能否 <strong>正常实现</strong>，满足事先的设计要求</li><li>是在 <strong>软件系统发生故障</strong> 的情况下<ul><li>去检验系统的恢复能力</li><li>验证系统已保存的用户数据是否丢失</li><li>系统和数据是否能尽快恢复或在指定时间内恢复</li><li>包括<ul><li>验证重新初始化</li><li>检查点</li><li>数据恢复</li><li>重新启动<ul><li>等机制的正确性</li></ul></li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美国文学绪论</title>
      <link href="/posts/28139.html"/>
      <url>/posts/28139.html</url>
      
        <content type="html"><![CDATA[<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ol><li>The Literature of Colonial America<ul><li>Puritan Thoughts</li></ul></li><li>The Literature of Reason and Revolution<ul><li>American Enlightenment</li><li>Benjamin Franklin: The Autobiography</li><li>Philip Freneau:The Wild Honey Suckle </li></ul></li><li>The Literature of Romanticism<ul><li>American Romanticism</li><li>Washington Irving: The Legend of Sleepy Hollow</li><li>William Cullen Bryant:To a Waterfowl</li><li>Edgar Allan Poe: To Helen; Annabel Lee;The Fall of the House of Usher</li><li>Transcendentalism</li><li>Henry David Thoreau:Walden</li><li>Nathaniel Hawthorne :The Scarlet Letter</li><li>Herman Melville:Moby Dick</li><li>Henry Wadsworth Longfellow:A Psalm of Life</li></ul></li><li>The Literature of Realism<ul><li>American Realism</li><li>free verse</li><li>Walt Whitman: Song of Myself</li><li>Emily Dickinson:I heard a Fly buzz—when I died</li><li>Mark Twain:The Adventures of Tom Sawyer</li><li>Henry James:The Portrait of a Lady</li><li>American Naturalism</li><li>Jack London:The Sea-Wolf,Martin Eden</li><li>Theodore Dreiser:Sister Carrie</li></ul></li><li>Twentieth-Century Literature<ul><li>Modernism</li><li>Imagism</li><li>Ezra Pound:In a Station of the Metro</li><li>Robert Frost:The Road Not Taken;Stopping by Woods on a Snowy Evening</li><li>Carl Sandburg:Chicago</li><li>F.Scott Fitzgerald:The Great Gatsby</li><li>Ernest Hemingway:A Farewell to Arms</li><li>John Steinbeck:The Grapes of Wrath</li><li>William Faulkner:A Rose for Emily</li></ul></li></ol><h2 id="The-Literature-of-Colonial-America"><a href="#The-Literature-of-Colonial-America" class="headerlink" title="The Literature of Colonial America"></a>The Literature of Colonial America</h2><h3 id="historical-introduction"><a href="#historical-introduction" class="headerlink" title="historical introduction"></a>historical introduction</h3><ul><li><p>The colonial period stretched roughly from the settlement of America in the early 17th century through the end of the 18th.</p><ul><li>The first permanent settlement in America was established by English in 1607.</li><li>(A group of people was sent by the English <strong>King James I</strong> to hunt for <strong>gold</strong>.They arrived at Virginia in 1607.They named the <strong>James River</strong> and bulid the <strong>James town</strong>.)</li></ul></li><li><p>The pre-revolutionary writing in the colonies was essentially of two kinds:   分为两类</p><ol><li>Practical matter-of-fact accounts of farming,hunting,travel,etc.designed to inform people “at home” what life was like in the new world,and,often,to induce their immigration</li><li>Highly theoretical,generally polemical,discussions of religious questions</li></ol></li></ul><h3 id="The-first-American-writer"><a href="#The-first-American-writer" class="headerlink" title="The first American writer"></a>The first American writer</h3><ul><li><p>The first writings that we call American were the narratives and journals of these settlements.They wrote about their voyage to the new land,their lives in the new land,their dealings with indians.</p></li><li><p>Captain John Smith is the first American writer.</p></li><li><p>A true Relation of such Occurrences and Accidents of Note as Hath Happened in verginia since the First Planting of That Colony.(1608)</p></li><li><p>A Map of virginia: A Description of the Country(1612)</p></li><li><p>General History of Virginia(1624):the Indian princess Pocahontas.</p></li><li><p><strong>Captain John Smith</strong></p><ul><li>was one of the first early 17th century British settlers in North America.</li><li>One of the things he wrote about that has become an American legend was his capture by the Indians and his rescue by the famous Indian Princess,Pocahontas.</li><li>宝嘉康蒂</li></ul></li></ul><h3 id="Puritan-Thoughts-（重点）"><a href="#Puritan-Thoughts-（重点）" class="headerlink" title="Puritan Thoughts   （重点）"></a>Puritan Thoughts   （重点）</h3><ul><li>the origin of puritan<ul><li>in the mediaeval Europe,there was widespread religious revolution.In the 16th Century,the English King Henry VIII(At that time)，the Catholics were not allowed to divorce unless they have the Pope’s permission.</li><li>Henry VIII wanted to divorce his wife because she couldn‘t bear him a son.But the pope didn’t allow him    to divorce,so he broke away the roman catholics Church&amp;established the Church of England.</li><li>But there was no radical difference between the doctrines of the Church of England and the Catholic Church.A group of people thought the church of England was too Catholic and wanted to purify the church.</li><li>Then came the name Puritans.</li></ul></li></ul><ul><li>Puritanism is the practises and beliefs on the Puritans.<ul><li>The puritans were originally members of a division of the Protestant Church,who came into existence in the reigns of Queen Elizabeth and King James I.</li><li>The first settlers who became the founding fathers of the American nation were quite a few of them Puritans.</li><li>They came to America out of various reasons,but it should be remembered that they were a group of serious,religious people,advocating highly religious and moral principles.As the word itself hints,Puritans wanted to purify their religous beliefs and practices.They felt that the Church of England was too close to the Church of Rome in doctrine from worship,and organization of authority.</li></ul></li></ul><p>主要教义 predestination</p><ol><li>God’s elect<ul><li>Puritans believed they are predestined before they were born.</li><li>Nothing or no good work can change their fate.</li><li>They believed the success of one’s business is the sign to show he is the God‘s elect.So the Puritans works very hard,spend very little and invest more for the future business.They lived a very frugal life.This is their ethics.</li></ul></li><li>Original sin and total depravity<ul><li>Man is born sinful.This determines some puritans pessimistic attitude towards life.</li></ul></li><li>Limited atonement(the salvation of a selected few)</li><li>theocracy  政教合一<ul><li>They combined state with religion.Their government is at least not a liberal one</li><li>The puritans established American tradition–intolerant moralism.They strictly punished drunks,adultery&amp;heretics</li><li>Puritans changed gradually due to the severity of frontier environment.</li></ul></li></ol><h4 id="影响Influence"><a href="#影响Influence" class="headerlink" title="影响Influence"></a>影响Influence</h4><ol><li>its optimism<ul><li>American literature was from the outset conditioned by the Puritan heritage.It can be said American literature is based on the Biblical myth.After Adam and Eve were driven out of the Garden of Eden,man have on illusion to restore the paradise.The puritans,after arriving at America,believing that God must have sent them to this new land to restore the lost paradise,to build the wildness into a new Garden of Eden.Fired with such a strong sense of mission,they treated life with a tremendous amount of optimism.The optimistic Puritans has exerted a great influence on American literature.</li></ul></li><li>Puritan’s metaphorical mode of perception changed gradually into a literary symbolism.</li></ol><h3 id="American-Dream"><a href="#American-Dream" class="headerlink" title="American Dream"></a>American Dream</h3><ul><li><p>The <strong>American</strong> <strong>Dream</strong> is a national ethos of the United States,a set of ideals in which freedom includes….</p></li><li><p>The idea of the American Dream is rooted in the United States Declaration of Independence which proclaims that”all men are created equal” and that they are “endowed by their Creator with certain inalienable Rights”including “life,Liberty and the pursuit of Happiness.”</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 英语二专 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美国文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.8 安全性测试</title>
      <link href="/posts/41073.html"/>
      <url>/posts/41073.html</url>
      
        <content type="html"><![CDATA[<h2 id="安全性测试定义"><a href="#安全性测试定义" class="headerlink" title="安全性测试定义"></a>安全性测试定义</h2><h3 id="软件安全性测试就是"><a href="#软件安全性测试就是" class="headerlink" title="软件安全性测试就是"></a>软件安全性测试就是</h3><ul><li>检验系统权限设置有效性</li><li>防范违法入侵的能力</li><li>数据备份和恢复能力等</li><li>设法找出各种安全性漏洞</li></ul><h3 id="漏洞举例："><a href="#漏洞举例：" class="headerlink" title="漏洞举例："></a>漏洞举例：</h3><ul><li>跨站点脚本(cross-site scripting , XSS)攻击</li><li>SQL注入式漏洞</li><li>缓冲区溢出</li><li>不安全的数据存储或传递</li><li>不安全的配置管理</li><li>有问题的访问控制、权限分配有问题</li><li>口令设置不严、包括长度、构成和更新频</li><li>暴露的端口或入口</li></ul><h2 id="安全性测试的范围"><a href="#安全性测试的范围" class="headerlink" title="安全性测试的范围"></a>安全性测试的范围</h2><ul><li>系统级别的安全性</li><li>应用程序级别的安全性（important）<ul><li>用户权限</li><li>数据输入验证</li><li>敏感数据加密</li><li>数据存储安全性</li><li>用户口令</li><li>验证系统的日志文件是否得到保护</li></ul></li></ul><h2 id="web安全性测试"><a href="#web安全性测试" class="headerlink" title="web安全性测试"></a>web安全性测试</h2><ul><li>跨站脚本攻击</li><li>SQL注入式攻击</li><li>URL和API的身份验证</li><li>其他</li></ul><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><ul><li>在页面某些输入域中使用跨站脚本（写入一段javascript）来发送恶意代码给没有发觉的用户，让浏览器执行document.write等危险指令<ul><li>窃取用户的资料或者信息</li></ul></li></ul><h2 id="输入域验证"><a href="#输入域验证" class="headerlink" title="输入域验证"></a>输入域验证</h2><ul><li>防止<ul><li>HTML标签：&lt;…&gt;…&lt;/…&gt;</li><li>转义字符：&amp;amp(&amp;);&amp;lt(&lt;);&amp;gt(&lt;);&amp;nbsp(空格)</li><li>脚本语言，如javascript <script language="javascript">......</script></li><li>特殊字符： ‘ ‘ &lt;&gt; /</li></ul></li><li>最好进行更严格的保护和验证</li></ul><h2 id="SQL注入式攻击"><a href="#SQL注入式攻击" class="headerlink" title="SQL注入式攻击"></a>SQL注入式攻击</h2><ul><li>根据SQL语句的编写规则，附加一个永远为”真”的条件<ul><li>使系统中的某个认证条件总是成立</li><li>从而欺骗系统、躲过认证</li><li>进而侵入系统</li></ul></li></ul><h2 id="安全性测试工具的评估标准"><a href="#安全性测试工具的评估标准" class="headerlink" title="安全性测试工具的评估标准"></a>安全性测试工具的评估标准</h2><ul><li>支持常见的web服务器平台</li><li>能同时提供对源代码和二进制文件进行扫描的功能</li><li>漏洞检测和纠正分析</li><li>检测实时系统的问题</li><li>不改变被测试的软件，不影响代码</li><li>良好的报告</li><li>非安全专业认识也易于上手</li><li>可管理部署的多种扫描器、尽可能小的错误误差等</li></ul><h2 id="常见的安全性测试工具"><a href="#常见的安全性测试工具" class="headerlink" title="常见的安全性测试工具"></a>常见的安全性测试工具</h2><p><img src="/posts/41073/%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.jpg" alt="安全性测试工具"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7 兼容性测试</title>
      <link href="/posts/14844.html"/>
      <url>/posts/14844.html</url>
      
        <content type="html"><![CDATA[<h2 id="兼容性测试的定义"><a href="#兼容性测试的定义" class="headerlink" title="兼容性测试的定义"></a>兼容性测试的定义</h2><p>兼容性测试</p><ul><li>是在 <strong>不同软硬件环境</strong> 下，验证软件系统能否正常地运行</li><li>这些软硬件一般有但不限于以下种类：<ul><li>硬件 hardware</li><li>操作系统 </li><li>数据库 </li><li>浏览器 </li><li>第三方系统</li><li>内部业务系统</li><li>自身系统的不同版本的用户数据</li></ul></li></ul><h2 id="兼容性测试的内容"><a href="#兼容性测试的内容" class="headerlink" title="兼容性测试的内容"></a>兼容性测试的内容</h2><ul><li>硬件兼容性的测试</li><li>数据兼容性的测试</li><li>系统版本之间的兼容性</li></ul><ul><li>向后兼容：<ul><li>指新发布的软件版本可以使用该软件的以前版本所产生的数据</li></ul></li><li>向前兼容：<ul><li>指在设计和开发一个新版本时，考虑如何和未来版本的数据兼容</li></ul></li></ul><h2 id="系统兼容性测试"><a href="#系统兼容性测试" class="headerlink" title="系统兼容性测试"></a>系统兼容性测试</h2><ul><li>B/S系统兼容性测试（考虑兼容哪个浏览器）</li><li>C/S系统兼容性测试（考虑兼容哪个客户端）</li></ul><h2 id="数据兼容性测试"><a href="#数据兼容性测试" class="headerlink" title="数据兼容性测试"></a>数据兼容性测试</h2><ul><li>是否遵守统一的国际标准、国家标准或业界认可的事实标准等</li><li>提供相应的导入、导出功能</li><li>剪贴板或ODBC等类似方法</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 性能测试工具</title>
      <link href="/posts/30377.html"/>
      <url>/posts/30377.html</url>
      
        <content type="html"><![CDATA[<h1 id="特性及其使用"><a href="#特性及其使用" class="headerlink" title="特性及其使用"></a>特性及其使用</h1><ul><li>能模拟实际用户的 <strong>操作行为</strong>，<ul><li><strong>记录和回放</strong> <strong>多用户</strong> 测试中的 <strong>事务处理过程</strong></li><li><strong>自动生成</strong>相应的 <strong>测试脚本</strong></li></ul></li><li>能针对 <strong>脚本</strong> 进行修改<ul><li>增加 <strong>逻辑控制</strong></li><li>完成 <strong>参数化</strong> 和 <strong>数据关联</strong></li></ul></li><li>可以设置不同的 <strong>应用环境和场景</strong>，通过 <strong>虚拟用户</strong> 执行相应的测试脚本</li><li>通过 <strong>系统监控工具</strong> 获得系统性能的相关指标的值</li></ul><h1 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h1><h2 id="nGrinder"><a href="#nGrinder" class="headerlink" title="nGrinder"></a>nGrinder</h2><ul><li>是一个基于Grinder 开发的、易于管理和使用的、分布式性能测试系统</li></ul><h2 id="Flood"><a href="#Flood" class="headerlink" title="Flood"></a>Flood</h2><ul><li>是人们经常使用的一个Web性能测试工具</li></ul><h2 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h2><ul><li>是一个开源的web压力测试和评测系统</li></ul><h2 id="openSTA"><a href="#openSTA" class="headerlink" title="openSTA"></a>openSTA</h2><ul><li>可以模拟大量的虚拟用户来完成性能测试</li><li>并通过script来完成丰富的自定义设置</li></ul><h2 id="DBMonster"><a href="#DBMonster" class="headerlink" title="DBMonster"></a>DBMonster</h2><ul><li>是一个生成随机数据</li><li>用来测试SQL数据库的压力测试工具</li></ul><h2 id="LoadSim"><a href="#LoadSim" class="headerlink" title="LoadSim"></a>LoadSim</h2><ul><li>网络应用程序的负载模拟器</li></ul><h1 id="商业工具"><a href="#商业工具" class="headerlink" title="商业工具"></a>商业工具</h1><ul><li>HP LoadRunner</li><li>IBM Rational performance Tester</li><li>Radview webload</li><li>compuware QA Load</li><li>Quest Benchmark Factory</li><li>微软WAS (web access stress test)</li><li>Paessler Webserver Stress Tool</li><li>MINQ PureLoad</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 压力测试</title>
      <link href="/posts/27406.html"/>
      <url>/posts/27406.html</url>
      
        <content type="html"><![CDATA[<h1 id="压力测试的定义"><a href="#压力测试的定义" class="headerlink" title="压力测试的定义"></a>压力测试的定义</h1><ul><li>是在系统（eg：CPU、内存、网络带宽等）处于 <strong>饱和</strong> 状态下</li><li>测试系统<ul><li>是否还具有正常的 <strong>会话</strong> 能力、<strong>数据处理</strong> 能力</li><li>或 是否会 <strong>出现错误</strong></li></ul></li><li>以检查软件系统对 <strong>异常情况的抵抗</strong> 能力</li><li>找出 <strong>性能瓶颈</strong>、<strong>功能不稳定性</strong> 等问题</li></ul><h1 id="压力测试的类型"><a href="#压力测试的类型" class="headerlink" title="压力测试的类型"></a>压力测试的类型</h1><h2 id="稳定性压力测试"><a href="#稳定性压力测试" class="headerlink" title="稳定性压力测试"></a>稳定性压力测试</h2><ul><li>高负载下持续运行24小时以上的压力测试</li></ul><h2 id="破坏性压力测试"><a href="#破坏性压力测试" class="headerlink" title="破坏性压力测试"></a>破坏性压力测试</h2><ul><li>通过不断加载的手段</li><li>快速总成系统的崩溃</li><li>让问题尽快地暴露出来</li></ul><h2 id="渗入测试"><a href="#渗入测试" class="headerlink" title="渗入测试"></a>渗入测试</h2><ul><li><p><strong>soak</strong> <strong>test</strong></p></li><li><p>通过长时间运行</p></li><li><p>使问题逐渐渗透出来</p></li><li><p>从而发现</p><ul><li><p>内存泄漏</p></li><li><p>垃圾收集 <strong>GC</strong></p></li><li><p>或系统的其他问题</p><p>以检验系统的 <strong>健壮性</strong></p></li></ul></li></ul><h2 id="峰谷测试"><a href="#峰谷测试" class="headerlink" title="峰谷测试"></a>峰谷测试</h2><ul><li><strong>peak-rest test</strong></li><li>采用 <strong>高低突变加载方式</strong> 进行<ul><li>先加载到 <strong>高水平</strong> 的负载</li><li>然后 <strong>急剧降低</strong> 负载</li><li><strong>稍微平息</strong> 一段时间</li><li>再加载到 <strong>高水平</strong> 的负载</li></ul></li><li><strong>重复</strong> 这样的过程</li><li>容易发现问题的 <strong>蛛丝马迹</strong></li><li>最终找到问题的 <strong>根源</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 性能测试</title>
      <link href="/posts/11040.html"/>
      <url>/posts/11040.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何确定性能需求"><a href="#如何确定性能需求" class="headerlink" title="如何确定性能需求"></a>如何确定性能需求</h1><h2 id="性能指标预期来源"><a href="#性能指标预期来源" class="headerlink" title="性能指标预期来源"></a>性能指标预期来源</h2><ol><li><strong>最终用户的体验</strong>      eg:2-5-10原则</li><li><strong>商业需求</strong>        eg：”比竞争对手的产品好”</li><li><strong>技术需求</strong>        eg：”cpu使用率不超过70%”</li><li><strong>标准要求</strong></li></ol><h2 id="包含下列性能指标："><a href="#包含下列性能指标：" class="headerlink" title="包含下列性能指标："></a>包含下列性能指标：</h2><ol><li><strong>时间</strong> time<ul><li>响应时间</li><li>页面下载时间等等</li></ul></li><li><strong>容量</strong> capacity<ul><li>正常工作能承受的最大负载</li><li>eg：<ul><li>最大并发用户数</li><li>最大数据容量</li><li>最大在线用户数</li></ul></li></ul></li><li><strong>吞吐量</strong> throughput<ul><li>eg：<ul><li>每秒请求数RPS</li><li>每秒点击数HPS</li><li>每秒事务数TPS</li><li>每秒接受或发送的数据量等</li></ul></li></ul></li><li><strong>系统资源利用率</strong> utilization<ul><li>eg：<ul><li>cpu</li><li>memory<ul><li>使用率</li></ul></li><li>等等</li></ul></li></ul></li></ol><h2 id="不同角色对于性能指标关注什么"><a href="#不同角色对于性能指标关注什么" class="headerlink" title="不同角色对于性能指标关注什么"></a>不同角色对于性能指标关注什么</h2><h3 id="用户："><a href="#用户：" class="headerlink" title="用户："></a>用户：</h3><ul><li>响应时间</li></ul><h3 id="产品市场团队"><a href="#产品市场团队" class="headerlink" title="产品市场团队"></a>产品市场团队</h3><ul><li>容量</li><li>数据吞吐量</li></ul><h3 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h3><ul><li>系统资源占用率</li></ul><h1 id="性能测试类型"><a href="#性能测试类型" class="headerlink" title="性能测试类型"></a>性能测试类型</h1><h2 id="性能验证测试"><a href="#性能验证测试" class="headerlink" title="性能验证测试"></a>性能验证测试</h2><ul><li>验证事先已定义的系统性能指标、系统能否满足系统的性能需求</li></ul><h2 id="性能基准测试"><a href="#性能基准测试" class="headerlink" title="性能基准测试"></a>性能基准测试</h2><ul><li>在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基准线</li></ul><h2 id="性能规划测试"><a href="#性能规划测试" class="headerlink" title="性能规划测试"></a>性能规划测试</h2><ul><li>在多种 <strong>特定</strong> 的环境下，获得 <strong>不同配置</strong> 的系统的 <strong>性能指标</strong> ，从而决定在系统部署时采用什么样的 <strong>软</strong>、<strong>硬件配置</strong></li></ul><h2 id="容量测试"><a href="#容量测试" class="headerlink" title="容量测试"></a>容量测试</h2><ul><li>可以看作是 <strong>性能</strong> 的测试的一种</li><li>因为系统的容量可以看作 <strong>系统性能指标</strong> 之一</li></ul><h1 id="性能测试步骤"><a href="#性能测试步骤" class="headerlink" title="性能测试步骤"></a>性能测试步骤</h1><ol><li>确定性能测试 <strong>需求</strong></li><li><strong>计划和设计测试</strong> ；包括确定关键业务流程、测试类型和测试方法，选择合适的测试工具、设计测试场景等等</li><li><strong>测试工具</strong> 的选择</li><li>配置 <strong>测试环境</strong>、尽量接近实际运行环境、即建立仿真环境作为性能测试环境，测试结果才能可信</li><li>实现 <strong>测试设计</strong>（开发测试脚本）</li><li><strong>执行测试</strong></li><li><strong>分析</strong> 测试结果</li><li>重复4-6步骤，直至 <strong>测试计划完成</strong> ，结果 <strong>满意</strong></li><li>提交 <strong>性能测试报告</strong></li></ol><h1 id="一些常见的性能问题"><a href="#一些常见的性能问题" class="headerlink" title="一些常见的性能问题"></a>一些常见的性能问题</h1><ul><li><strong>资源泄漏</strong>，包括内存泄漏</li><li><strong>资源瓶颈</strong>，内部资源（线程、放入池的对象）变得稀疏</li><li>cpu使用率达到<strong>100</strong>%、系统 <strong>被锁定</strong> （eg：鼠标键盘不响应）等等</li><li>线程 <strong>死锁</strong>、线程 <strong>阻塞</strong> 等等</li><li><strong>数据库连接</strong> 成为性能瓶颈（数据库连接时间过长）</li><li>查询 <strong>速度慢</strong> 或 列表 <strong>效率低</strong>（eg:没用上索引）</li><li>受 <strong>外部系统影响</strong> 越来越大</li></ul><h1 id="容量测试-1"><a href="#容量测试-1" class="headerlink" title="容量测试"></a>容量测试</h1><h2 id="容量测试的定义"><a href="#容量测试的定义" class="headerlink" title="容量测试的定义"></a>容量测试的定义</h2><ul><li><p><strong>capacity</strong> test</p></li><li><p>通过负载测试或其它测试方法，预先分析出反应软件系统应用特征的某项指标的极限值（eg：最大并发用户数、数据库记录数等等）</p></li><li><p>在其极限值状态下系统主要功能还能保持正常运行</p></li></ul><h2 id="与其他测试的关系"><a href="#与其他测试的关系" class="headerlink" title="与其他测试的关系"></a>与其他测试的关系</h2><ul><li>属于性能测试的一种</li></ul><h2 id="采用的方法"><a href="#采用的方法" class="headerlink" title="采用的方法"></a>采用的方法</h2><ul><li>一般采用 逐步加载 的负载测试方法</li><li>也可以<ul><li>先采用 <strong>逐步加载</strong> 的方式</li><li>获得一个 基本的 <strong>容量值或容量范围</strong></li><li>再考虑用 <strong>一次性加载方式</strong></li><li>来决定 <strong>实际可支持</strong> 的 <strong>容量值</strong></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 负载测试技术</title>
      <link href="/posts/19168.html"/>
      <url>/posts/19168.html</url>
      
        <content type="html"><![CDATA[<h1 id="pre：演示一个使用JMETER的例子"><a href="#pre：演示一个使用JMETER的例子" class="headerlink" title="pre：演示一个使用JMETER的例子"></a>pre：演示一个使用JMETER的例子</h1><h2 id="背景要求："><a href="#背景要求：" class="headerlink" title="背景要求："></a>背景要求：</h2><p>当120个用户同时访问ecshop,其中所有的用户会访问首页并搜索商品</p><p>要求平均响应时间&lt;=2000ms,并且cpu的利用率&lt;=75%</p><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>先启动xapp，把apache和mysql打开</p><p><img src="/posts/19168/Xapp.png" alt="Xapp"></p><p>jmeter启动测试计划 <code>pre7.3</code></p><p><img src="/posts/19168/jmeter.png" alt="jmeter"></p><ul><li><code>User</code> <code>Defined</code> <code>Variable</code><ul><li>用户定义变量</li></ul></li><li><code>HTTP Request Defaults</code><ul><li>HTTP请求的默认值</li></ul></li><li><code>HTTP Cookie Manager</code><ul><li>http cookie管理器</li></ul></li><li><code>Thread Group</code><ul><li>线程</li><li>模仿用户给服务器发请求</li><li>![thread group](7-3-负载测试技术/thread group.png)<ul><li><code>number of threads</code>:<ul><li>线程数</li></ul></li><li><code>ramp-up preriod</code><ul><li>执行完这些线程所用的时间 （秒数）</li></ul></li><li><code>loop</code> <code>count</code><ul><li>循环次数</li><li>infinite:无限循环</li></ul></li></ul></li></ul></li></ul><p><img src="/posts/19168/%E9%87%87%E6%A0%B7%E5%99%A8.png" alt="采样器"></p><p><code>uniform random timer</code></p><p><img src="/posts/19168/%E5%AE%9A%E6%97%B6%E5%99%A8.png" alt="定时器"></p><ul><li>采样器 就是发请求出去</li><li>有请求发出去，则自然要有监听器</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 负载测试 压力测试 性能测试</title>
      <link href="/posts/60505.html"/>
      <url>/posts/60505.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景及其分析"><a href="#背景及其分析" class="headerlink" title="背景及其分析"></a>背景及其分析</h1><h2 id="性能调优："><a href="#性能调优：" class="headerlink" title="性能调优："></a>性能调优：</h2><ul><li>指系统性能改善是<ul><li>测试</li><li>调整</li><li>再测试</li><li>再调整</li><li>…<ul><li>一个持续改进的过程</li></ul></li></ul></li><li>需要借助负载测试方法</li></ul><h2 id="负载测试-load-test"><a href="#负载测试-load-test" class="headerlink" title="负载测试 load test"></a>负载测试 load test</h2><ul><li>可看成是 <strong>性能测试</strong> 采用的一种技术</li></ul><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>可看作 <strong>负载测试</strong> 的一种</li><li>即  <strong>高负载</strong> 下的 <strong>负载测试</strong></li></ul><h2 id="容量测试-capacity-test"><a href="#容量测试-capacity-test" class="headerlink" title="容量测试 capacity test"></a>容量测试 capacity test</h2><ul><li>用 <strong>负载测试</strong> 技术来实现</li><li><strong>压力测试</strong> 可附带做 <strong>容量测试</strong></li></ul><h2 id="负载测试与性能测试相似性"><a href="#负载测试与性能测试相似性" class="headerlink" title="负载测试与性能测试相似性"></a>负载测试与性能测试相似性</h2><ul><li>测试方法接近</li><li>都关注系统性能</li><li>多数情况下用相同测试工具</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="负载测试-load-rest"><a href="#负载测试-load-rest" class="headerlink" title="负载测试 load rest"></a>负载测试 load rest</h2><ul><li>通过模拟实际软件系统所承受的<ul><li>负载条件</li><li>改变系统负载大小</li><li>负载方式<ul><li>来发现系统中所存在的问题</li></ul></li></ul></li><li>负载大小可以是<ul><li>并发请求的数量(RPS 每秒请求数)</li><li>并发用户数量</li><li>数据库大小</li><li>收发数据大小</li><li>等等</li></ul></li></ul><h2 id="压力测试-1"><a href="#压力测试-1" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>是在 <strong>强负载</strong> 情况下稳定性进行测试</li><li>查看应用系统在 <strong>峰值</strong>（瞬间使用高峰）使用情况下的行为表现</li><li>更有效地发现系统 <strong>稳定性的隐患</strong> 和系统在负载峰值的条件下 <strong>功能隐患</strong> 等</li><li>确认系统是否具有良好的 <strong>容错</strong> 能力和 <strong>可恢复</strong> 能力</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>是为了 <strong>获取</strong> 或 <strong>验证</strong> 系统性能指标</li><li>或为了发现 <strong>性能瓶颈</strong> 而进行的测试</li></ul><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><h2 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h2><ul><li>测试被测系统是否满足 <strong>预期性能目标</strong></li></ul><h2 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h2><ul><li>测试被测试系统</li><li>在 <strong>服务器安全范围</strong> 内的 <strong>最大负载值</strong></li></ul><h2 id="压力测试-2"><a href="#压力测试-2" class="headerlink" title="压力测试"></a>压力测试</h2><ul><li>测试被测试系统</li><li>在 <strong>超过服务器安全范围</strong> 所能承受的 <strong>最大压力值</strong></li></ul><h2 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h2><ul><li>测试被测系统在 <strong>长时间的压力</strong> 下的 <strong>稳定性</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程基础知识简介</title>
      <link href="/posts/18088.html"/>
      <url>/posts/18088.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h2><ul><li>包括：<ul><li>需求分析</li><li>系统设计</li><li>系统实现</li><li>测试</li><li>发布</li><li>运行和维护</li><li>升级</li><li>淘汰</li></ul></li></ul><h2 id="软件主要的测试工作"><a href="#软件主要的测试工作" class="headerlink" title="软件主要的测试工作"></a>软件主要的测试工作</h2><ul><li>随着 <strong>系统实现阶段</strong> 的展开而开始</li><li>一直持续到 <strong>产品发布</strong> 之后</li></ul><h2 id="软件的质量保证活动QA"><a href="#软件的质量保证活动QA" class="headerlink" title="软件的质量保证活动QA"></a>软件的质量保证活动QA</h2><ul><li>伴随着软件整个生命周期</li><li>原因：<ul><li>为了度量、跟踪、控制软件产品的质量</li></ul></li></ul><h1 id="2-软件开发流程简述"><a href="#2-软件开发流程简述" class="headerlink" title="2 软件开发流程简述"></a>2 软件开发流程简述</h1><h2 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h2><h3 id="需求分析的定义"><a href="#需求分析的定义" class="headerlink" title="需求分析的定义"></a>需求分析的定义</h3><ul><li>是开发人员经过深入细致的调研和分析，准确理解用户和项目的<ul><li>功能</li><li>性能</li><li>可靠性<ul><li>等具体要求</li></ul></li></ul></li><li>将用户 <strong>非形式的需求</strong> 转化为 <strong>完整的需求定义</strong> </li><li>从而确定系统 <strong>必须做什么</strong> 的过程</li></ul><h3 id="需求分析中需明白的几个概念"><a href="#需求分析中需明白的几个概念" class="headerlink" title="需求分析中需明白的几个概念"></a>需求分析中需明白的几个概念</h3><h4 id="业务需求："><a href="#业务需求：" class="headerlink" title="业务需求："></a>业务需求：</h4><ul><li>是由高层领导提出的业务上要满足的需求</li><li>目的：<ul><li>解决业务通电</li></ul></li><li>通常比较宏观</li></ul><h4 id="用户需求："><a href="#用户需求：" class="headerlink" title="用户需求："></a>用户需求：</h4><ul><li>使用户从自身角度出发，自己所认为的需求</li><li>也可以看作将业务需求具体化之后的需求</li></ul><h4 id="产品需求："><a href="#产品需求：" class="headerlink" title="产品需求："></a>产品需求：</h4><ul><li>是通过分析提炼得到的用户的真实需求</li><li>且符合产品定位的解决方案</li><li>一般来说，产品需求等同于系统需求</li></ul><h2 id="2-2-系统设计"><a href="#2-2-系统设计" class="headerlink" title="2.2 系统设计"></a>2.2 系统设计</h2><h3 id="系统设计的定义："><a href="#系统设计的定义：" class="headerlink" title="系统设计的定义："></a>系统设计的定义：</h3><ul><li>是根据需求分析的结果</li><li>是对软件的技术实现由粗到细进行设计的过程</li></ul><h3 id="系统设计的两个阶段："><a href="#系统设计的两个阶段：" class="headerlink" title="系统设计的两个阶段："></a>系统设计的两个阶段：</h3><ul><li>概要设计</li><li>详细设计</li></ul><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><h4 id="概要设计的任务："><a href="#概要设计的任务：" class="headerlink" title="概要设计的任务："></a>概要设计的任务：</h4><ul><li>根据系统需求分析得到的系统用例转换为软件结构和数据结构</li></ul><h4 id="概要设计的内容："><a href="#概要设计的内容：" class="headerlink" title="概要设计的内容："></a>概要设计的内容：</h4><ul><li>系统技术架构设计</li><li>功能模块划分和功能设计</li><li>数据库设计</li><li>接口设计</li><li>界面设计</li></ul><h3 id="详细设计："><a href="#详细设计：" class="headerlink" title="详细设计："></a>详细设计：</h3><h4 id="详细设计的定义："><a href="#详细设计的定义：" class="headerlink" title="详细设计的定义："></a>详细设计的定义：</h4><ul><li>对概要设计的细化</li></ul><h4 id="详细设计的内容："><a href="#详细设计的内容：" class="headerlink" title="详细设计的内容："></a>详细设计的内容：</h4><ul><li>算法设计</li><li>函数流程设计</li><li>等等</li></ul><h2 id="2-3-系统实现"><a href="#2-3-系统实现" class="headerlink" title="2.3 系统实现"></a>2.3 系统实现</h2><h3 id="系统实现的定义："><a href="#系统实现的定义：" class="headerlink" title="系统实现的定义："></a>系统实现的定义：</h3><ul><li>即编码</li><li>根据系统设计来进行实际的编码工作</li><li>并得到可以运行的软件产品</li></ul><h2 id="2-4-系统测试"><a href="#2-4-系统测试" class="headerlink" title="2.4 系统测试"></a>2.4 系统测试</h2><h3 id="系统测试的定义："><a href="#系统测试的定义：" class="headerlink" title="系统测试的定义："></a>系统测试的定义：</h3><ul><li>对源代码或可以运行的程序进行检查或执行</li><li>判断被测系统事都存在与需求中的预期不一致的地方</li><li>并加以记录的过程</li></ul><h2 id="2-5-产品发布和运维"><a href="#2-5-产品发布和运维" class="headerlink" title="2.5 产品发布和运维"></a>2.5 产品发布和运维</h2><p>原因：</p><ul><li>软件发布后，可能会产生问题：<ul><li>用户对产品不熟悉造成使用问题</li><li>开发测试不彻底遗留缺陷</li></ul></li></ul><p>因此：</p><ul><li>要对产品运行<ul><li>进行维护</li><li>进行用户培训</li><li>修复缺陷</li><li>等等</li></ul></li></ul><h2 id="2-6-产品升级"><a href="#2-6-产品升级" class="headerlink" title="2.6 产品升级"></a>2.6 产品升级</h2><p>原因：</p><ul><li>随着用户使用的深入</li><li>软件产品可能无法继续使用用户要求</li></ul><p>因此需要：</p><ul><li>对产品进行升级</li><li>增加新的功能和特性</li><li>优化产品性能</li><li>等等</li></ul><h2 id="2-7-产品淘汰"><a href="#2-7-产品淘汰" class="headerlink" title="2.7 产品淘汰"></a>2.7 产品淘汰</h2><p>原因：</p><ul><li>随着技术不断发展，软件产品可能无法适应业务发展</li></ul><p>因此：</p><ul><li>不得不将产品彻底报废、淘汰</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 质量保证与测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 认识软件测试管理</title>
      <link href="/posts/40593.html"/>
      <url>/posts/40593.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-软件质量与测试"><a href="#1-1-软件质量与测试" class="headerlink" title="1.1 软件质量与测试"></a>1.1 软件质量与测试</h2><h3 id="软件质量的概念"><a href="#软件质量的概念" class="headerlink" title="软件质量的概念"></a>软件质量的概念</h3><ul><li>软件质量越来越受到重视</li><li>ANSI/IEEE&lt;软件工程术语的IEEE标准术语表&gt;定义软件质量为<ul><li>“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”</li></ul></li></ul><h3 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h3><ul><li><p>软件产品各种质量特性的组合称为软件质量模型</p></li><li><p>常见的软件质量模型</p><ul><li>Boehm模型 1976年</li><li>MCCALL模型 1978年</li><li>ISO9126软件质量模型 1993年</li></ul></li></ul><h3 id="Boehm质量模型"><a href="#Boehm质量模型" class="headerlink" title="Boehm质量模型"></a>Boehm质量模型</h3><ul><li>1976年由Boehm等提出的分层方案</li><li>将软件的质量定义为分层的模型</li></ul><h4 id="boehm质量模型内容"><a href="#boehm质量模型内容" class="headerlink" title="boehm质量模型内容"></a>boehm质量模型内容</h4><ul><li><strong>可维护性</strong><ul><li><strong>可修改性</strong><ul><li><strong>可扩充性</strong></li><li><strong>结构化性</strong></li></ul></li><li><strong>可理解性</strong><ul><li><strong>清晰性</strong></li><li><strong>简单性</strong></li><li><strong>结构化性</strong></li><li><strong>自描述性</strong> 不需要其他培训 软件上的说明足以指引完成使用</li></ul></li><li><strong>可测试性</strong><ul><li><strong>结构化性</strong></li><li><strong>自描述性</strong></li><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>可测试性</strong></li></ul></li></ul></li><li><strong>可用性</strong><ul><li><strong>人类工程</strong><ul><li><strong>通信性</strong></li><li><strong>可存取性</strong></li><li><strong>健壮性</strong></li></ul></li><li><strong>效率</strong><ul><li><strong>可存取性</strong></li><li><strong>设备效率</strong></li><li><strong>可测试性</strong></li></ul></li><li><strong>可靠性</strong><ul><li><strong>一致性</strong></li><li><strong>健壮性</strong></li><li><strong>完备性</strong></li><li><strong>正确性</strong></li><li><strong>自包含性</strong></li></ul></li></ul></li><li><strong>可移植性</strong><ul><li><strong>自包含性</strong></li><li><strong>设备独立性</strong></li></ul></li></ul><h3 id="MCCALL质量模型"><a href="#MCCALL质量模型" class="headerlink" title="MCCALL质量模型"></a>MCCALL质量模型</h3><ul><li>1979年由McCall等人提出的软件质量模型</li><li>将软件质量的概念建立在11个质量特性之上</li><li>这些质量特性分别是面向软件产品的运行、修正和转移的</li></ul><h3 id="ISO9126质量模型"><a href="#ISO9126质量模型" class="headerlink" title="ISO9126质量模型"></a>ISO9126质量模型</h3><ul><li>软件质量模型可以分为：<ul><li>内部质量和外部质量模型、<ul><li>功能性</li><li>可靠性</li><li>易用性</li><li>效率</li><li>可维护性</li><li>可移植性</li></ul></li><li>使用质量模型<ul><li>有效性</li><li>生产性</li><li>安全性</li><li>满意度</li></ul></li></ul></li></ul><h3 id="常见的软件质量特性"><a href="#常见的软件质量特性" class="headerlink" title="常见的软件质量特性"></a>常见的软件质量特性</h3><ol><li>性能Performance<ol><li>系统的响应能力</li><li>即 要经过多长时间才能对某个时间做出响应</li><li>或者在某段时间内系统所能处理的事件个数</li></ol></li><li>可用性Availability<ol><li>系统能正常运行的时间比例</li></ol></li><li>可靠性Rvailability<ol><li>系统在应用或错误面前，在意外或者错误使用的情况下维持软件系统功能特性的能力</li></ol></li><li>健壮性Robustness<ol><li>在处理或者环境中系统能够承受的压力或者变更能力</li></ol></li><li>安全性Security<ol><li>系统向合法用户提供服务的同时能够阻止非授权用户使用企图或拒绝服务的能力</li></ol></li></ol><h3 id="软件质量保证的手段"><a href="#软件质量保证的手段" class="headerlink" title="软件质量保证的手段"></a>软件质量保证的手段</h3><ul><li>软件测试</li><li>软件研发过程保证</li><li>软件研发配置管理</li><li>…</li></ul><h3 id="软件测试-vs-软件质量"><a href="#软件测试-vs-软件质量" class="headerlink" title="软件测试 vs 软件质量"></a>软件测试 vs 软件质量</h3><ul><li>软件测试是保证软件质量的重要手段之一</li><li>软件测试是有计划有组织的活动</li><li>软件测试管理确保测试活动的顺利开展</li></ul><h2 id="1-2-软件测试管理概述"><a href="#1-2-软件测试管理概述" class="headerlink" title="1.2 软件测试管理概述"></a>1.2 软件测试管理概述</h2><h3 id="项目与项目管理"><a href="#项目与项目管理" class="headerlink" title="项目与项目管理"></a>项目与项目管理</h3><ul><li>项目：<ul><li>一系列复杂的并相互关联的活动</li><li>有着一个明确的目标</li><li>必须在特定的时间、预算、资源限定内，依据规范完成</li></ul></li><li>项目管理：<ul><li>在项目活动中运用专门的知识、技能、工具或方法</li><li>使项目能够在有限资源限定条件下，实现预定的目标</li></ul></li><li>范畴：<ul><li>范围管理</li><li>时间管理</li><li>费用管理</li><li>质量管理</li><li>人力资源管理</li><li>风险管理</li><li>沟通管理</li><li>采购与合同管理</li></ul></li></ul><h3 id="软件测试管理-vs-软件项目管理"><a href="#软件测试管理-vs-软件项目管理" class="headerlink" title="软件测试管理 vs 软件项目管理"></a>软件测试管理 vs 软件项目管理</h3><ul><li>软件测试管理是忒数的软件项目管理<ul><li>与软件项目管理密切相关，有时从属于软件项目管理的一部分</li><li>可以借用软件项目管理的办法</li><li>因任务特点有自身特殊的知识、流程、方法、工具</li></ul></li></ul><h3 id="软件测试管理的要素"><a href="#软件测试管理的要素" class="headerlink" title="软件测试管理的要素"></a>软件测试管理的要素</h3><ul><li>测试过程与测试资产管理<ul><li>建立并维护测试的过程</li><li>建立并维护测试过程中建立的指南、模板、评审单等</li><li>管理测试工作相关的资产</li></ul></li><li>测试需求管理<ul><li>收集需求</li><li>分析需求</li><li>测试需求跟踪</li></ul></li><li>测试计划管理<ul><li>制定计划</li><li>执行计划</li><li>监控计划</li></ul></li><li>测试缺陷管理<ul><li>报告测试缺陷</li><li>回归测试发现的缺陷</li><li>缺陷分析</li></ul></li><li>测试工具管理<ul><li>选择测试工具</li><li>维护测试工具</li></ul></li><li>测试团队管理<ul><li>建立并维护测试团队</li><li>团队日常管理</li><li>团队绩效管理</li></ul></li></ul><h2 id="1-3-软件测试管理工具"><a href="#1-3-软件测试管理工具" class="headerlink" title="1.3 软件测试管理工具"></a>1.3 软件测试管理工具</h2><h3 id="软件测试工具"><a href="#软件测试工具" class="headerlink" title="软件测试工具"></a>软件测试工具</h3><ul><li>自动化测试工具<ul><li>单元测试工具</li><li>性能测试工具</li><li>功能测试工具</li><li>…</li></ul></li><li>软件测试管理工具<ul><li>ALM</li><li>BUGzilla：<a href="https://www.bugzilla.org/" target="_blank" rel="noopener">https://www.bugzilla.org/</a></li><li>Jira</li><li>禅道：<a href="https://www.zentao.net/" target="_blank" rel="noopener">https://www.zentao.net/</a></li><li>…</li></ul></li></ul><h3 id="软件测试管理工具的分类"><a href="#软件测试管理工具的分类" class="headerlink" title="软件测试管理工具的分类"></a>软件测试管理工具的分类</h3><ul><li>专项测试管理工具<ul><li>只管理软件测试中的某项内容<ul><li>如缺陷管理工具、</li><li>用例管理工具</li></ul></li><li>如BUGzilla是缺陷管理工具</li></ul></li><li>专门测试管理工具<ul><li>对测试的整个流程进行管理</li><li>如IBM Rational Quality Manager</li><li>HP ALM(Application lifecycle Management)等</li></ul></li><li>覆盖开发和测试的项目管理工具<ul><li>覆盖整个研发周期的项目管理工具</li><li>特别适用于研发测试齐全的产品研发团队</li><li>如：禅道项目管理软件</li></ul></li><li>其他<ul><li>借助办公软件和文档管理软件完成测试管理</li><li>办公软件:Office Project\Word\Excel</li><li>文档管理软件：如TortoiseSVN\TortoiseHg</li></ul></li></ul><h3 id="软件测试管理工具的选择"><a href="#软件测试管理工具的选择" class="headerlink" title="软件测试管理工具的选择"></a>软件测试管理工具的选择</h3><ul><li><p>选择测试管理工具应该综合考虑</p><ul><li>项目大小</li><li>团队规模</li><li>团队结构</li><li>成本预算</li></ul></li><li><p>工具是一个载体，</p><ul><li><p>可以提高工作效率，减少错误发生</p></li><li><p>更重要的是，利用知识和规范的流程完成项目，从而灵活运用工具</p></li></ul></li></ul><table><thead><tr><th>团队种类</th><th>建议选择</th><th>特点</th><th>举例</th></tr></thead><tbody><tr><td>小规模初创团队（如创业项目、学生项目等）</td><td>专项管理的开源工具或办公软件</td><td>节省成本、简单易用</td><td>Bugzilla      jira免费版 Office、Wps   文档管理软件TortoiseSVN  各种在线缺陷管理工具</td></tr><tr><td>第三方测试团队（专门提供测试服务的机构）</td><td>专门的测试管理工具</td><td>对测试全流程进行管理</td><td>IBM Rational Quality Manager       Hp ALM (Application Lifecycle Management)</td></tr><tr><td>产品研发团队（包括开发和测试人员）</td><td>软件项目管理工具</td><td>对软件开发进行全流程管理</td><td>有非常多的此类商业软件、不再举例，也有很多公司用的是自己研发的产品</td></tr></tbody></table><h3 id="软件测试管理工具的功能"><a href="#软件测试管理工具的功能" class="headerlink" title="软件测试管理工具的功能"></a>软件测试管理工具的功能</h3><ul><li>用户及权限管理</li><li>测试项目的创建</li><li>测试项目需求管理</li><li>测试任务分配和实施</li><li>测试项目缺陷管理</li><li>测试数据收集</li><li>测试项目数据分析统计和报告生成</li><li>测试项目用例管理</li><li>测试执行管理</li><li>测试文档管理</li></ul><h3 id="软件测试管理工具的发展趋势"><a href="#软件测试管理工具的发展趋势" class="headerlink" title="软件测试管理工具的发展趋势"></a>软件测试管理工具的发展趋势</h3><ul><li>与其他软件自动化测试工具集成<ul><li>如可以直接启动各种自动化测试</li></ul></li><li>与软件研发的其他环节集成越来越紧密<ul><li>如代码审查、产品版本管理等</li></ul></li><li>基于云的测试管理工具<ul><li>比如QASymphony开发的QTest是基于云计算的测试管理工具</li></ul></li></ul><h3 id="HP-ALM-测试管理工具简介"><a href="#HP-ALM-测试管理工具简介" class="headerlink" title="HP ALM 测试管理工具简介"></a>HP ALM 测试管理工具简介</h3><h4 id="ALM简介"><a href="#ALM简介" class="headerlink" title="ALM简介"></a>ALM简介</h4><ul><li>HP公司的软件测试管理工具</li><li>HP Application Lifecycle Management（ALM）<ul><li>可提供用于组织和跟踪应用程序版本的系统</li><li>帮助定义并维护需求及测试的库</li></ul></li><li>ALM具有缺陷跟踪系统<ul><li>能够从初始检测开始监控缺陷</li><li>直到问题解决</li></ul></li><li>ALM可以<ul><li>生成演示业务性能各个方面的叫糊涂</li><li>或使用任何截面数据定义报告</li><li>还可以通过在单个视图中并排排列多个图监控多个业务指标</li></ul></li></ul><h4 id="应用ALM优势"><a href="#应用ALM优势" class="headerlink" title="应用ALM优势"></a>应用ALM优势</h4><ul><li>加强开发人员、测试人员和业务分析师之间的协作</li><li>支持构建多级要求、任务、测试、缺陷、源代码和报告</li><li>任务管理有助于提高开发人员和测试人员的工作效率</li><li>同时支持瀑布式和敏捷式方法</li><li>与常见的开放源、商业开发管理解决方案完美集成</li></ul><h4 id="ALM功能"><a href="#ALM功能" class="headerlink" title="ALM功能"></a>ALM功能</h4><ul><li>版本规范</li><li>需求规范</li><li>测试计划</li><li>测试执行</li><li>缺陷跟踪</li></ul><h4 id="ALM服务器站点管理页面"><a href="#ALM服务器站点管理页面" class="headerlink" title="ALM服务器站点管理页面"></a>ALM服务器站点管理页面</h4><p><img src="/posts/40593/%E6%9C%8D%E5%8A%A1%E7%AB%99%E7%82%B9.PNG" alt="1"></p><h4 id="ALM客户端登录界面"><a href="#ALM客户端登录界面" class="headerlink" title="ALM客户端登录界面"></a>ALM客户端登录界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.PNG" alt="登录界面"></p><p>登录时除了登录名和密码，还要选择登录的项目</p><p>每次只能登录一个固定的项目</p><h4 id="ALM客户端登陆后的界面"><a href="#ALM客户端登陆后的界面" class="headerlink" title="ALM客户端登陆后的界面"></a>ALM客户端登陆后的界面</h4><p><img src="/posts/40593/%E7%99%BB%E5%BD%95%E5%90%8E%E7%95%8C%E9%9D%A2.PNG" alt="登陆后界面"></p><h4 id="ALM客户端-需求管理"><a href="#ALM客户端-需求管理" class="headerlink" title="ALM客户端-需求管理"></a>ALM客户端-需求管理</h4><p>可以创建需求</p><p>右下角为创建好的需求</p><h4 id="ALM客户端-用例管理"><a href="#ALM客户端-用例管理" class="headerlink" title="ALM客户端-用例管理"></a>ALM客户端-用例管理</h4><p>![用例管理](D:/github blog/ischelsea.github.io/source/_posts/第一章-认识软件测试管理/用例管理.PNG)</p><p>ALM客户端的用例管理称为测试计划</p><p>可以以树的形式来展现，也可以以列表的形式</p><p>可以对应到用例、可以对应到需求</p><p>每个用例有详细信息、设计步骤、参数、测试配置、附件等属性</p><h4 id="ALM客户端-测试实验室（执行管理）"><a href="#ALM客户端-测试实验室（执行管理）" class="headerlink" title="ALM客户端-测试实验室（执行管理）"></a>ALM客户端-测试实验室（执行管理）</h4><p><img src="/posts/40593/%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86.PNG" alt="执行管理"></p><p>实际上就是建立一些测试的集合</p><p>然后去执行这个测试集</p><p>测试集里会包含一群测试用例</p><p>之后可以执行并记录测试用例的执行结果，进行一些分析</p><h4 id="ALM客户端-缺陷管理"><a href="#ALM客户端-缺陷管理" class="headerlink" title="ALM客户端-缺陷管理"></a>ALM客户端-缺陷管理</h4><p><img src="/posts/40593/%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86.PNG" alt="缺陷管理"></p><p>因为缺陷有很多字段</p><p>所以缺陷建立后可以以列表的形式进行查看</p><p>缺陷可以向前关联到相应的测试用例</p><ul><li>缺陷的字段可以自己定义<ul><li>比如说缺陷的功能模块</li><li>每个产品的缺陷功能模块都是不同的</li><li>我们可以在客户端通过项目的自定义来定义缺陷的一些字段</li></ul></li></ul><p>综上</p><p>也就是说，ALM可以实现从需求、到用例、到缺陷的关联</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 软件测试过程管理</title>
      <link href="/posts/5418.html"/>
      <url>/posts/5418.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-软件研发中的测试"><a href="#2-1-软件研发中的测试" class="headerlink" title="2.1 软件研发中的测试"></a>2.1 软件研发中的测试</h2><h3 id="1-软件研发中的测试活动"><a href="#1-软件研发中的测试活动" class="headerlink" title="1 软件研发中的测试活动"></a>1 软件研发中的测试活动</h3><h4 id="软件测试与软件研发"><a href="#软件测试与软件研发" class="headerlink" title="软件测试与软件研发"></a>软件测试与软件研发</h4><ul><li>软件测试和软件开发一样，都遵循软件工程的原理</li><li>测试是软件研发的一部分，测试和开发时密切相关的</li><li>测试活动是贯穿于软件项目开发的全过程的，和开发活动交互开展</li></ul><h4 id="软件研发生命周期的瀑布模型"><a href="#软件研发生命周期的瀑布模型" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h4><p><img src="/posts/5418/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><h4 id="尽早测试，越晚发现问题成本越高"><a href="#尽早测试，越晚发现问题成本越高" class="headerlink" title="尽早测试，越晚发现问题成本越高"></a>尽早测试，越晚发现问题成本越高</h4><p><img src="/posts/5418/%E5%8F%98%E5%8C%96.png" alt="变化"></p><h4 id="软件研发中的测试环节与测试活动"><a href="#软件研发中的测试环节与测试活动" class="headerlink" title="软件研发中的测试环节与测试活动"></a>软件研发中的测试环节与测试活动</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8.png" alt="测试活动"></p><h4 id="研发中的测试活动：软件需求评审及i系统测试方案制定"><a href="#研发中的测试活动：软件需求评审及i系统测试方案制定" class="headerlink" title="研发中的测试活动：软件需求评审及i系统测试方案制定"></a>研发中的测试活动：软件需求评审及i系统测试方案制定</h4><ol><li><p>软件需求完成后，需要进行需求的评审，此时测试人员可以：</p><ul><li>参与需求的评审</li><li>需求确定后进行系统测试方案及计划的制订</li></ul></li><li><p>软件总体设计完成后，进行总体设计方案评审，此时测试人员可以：</p><ul><li>参与总体设计方案的评审</li><li>开始进行集成测试方案的制定</li></ul></li><li><p>详细设计完成后，测试人员：</p><ul><li>参与详细设计的评审</li><li>开始进行模块测试方案的制定</li></ul></li><li><p>单元测试和编码一般是同步的，由开发人员自己完成的</p></li><li><p>整个模块开发完成后，测试人员开始进行模块测试，在这之前所有的模块测试用例应当已经准备完毕</p></li><li><p>模块测试后是执行集成测试和系统测试</p></li><li><p>软件运行维护期间则要对运行期间发现的问题进行记录和回归测试</p></li></ol><h3 id="2-按照开发阶段对软件测试分类"><a href="#2-按照开发阶段对软件测试分类" class="headerlink" title="2 按照开发阶段对软件测试分类"></a>2 按照开发阶段对软件测试分类</h3><ul><li><p>按照开发阶段划分，软件测试分为：</p><ul><li><p>单元测试</p></li><li><p>集成测试</p></li><li><p>系统测试</p></li><li><p>确认测试</p></li><li><p>验收测试</p></li></ul></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>单元测试又称为模块测试<ul><li>是针对软件设计的最小单位-程序模块进行正确性验证的测试工作</li></ul></li><li>检查程序单元是否满足详细设计说明中的：<ul><li>模块功能</li><li>性能</li><li>接口和设计约束</li><li>发现模块内部错误</li></ul></li><li>白盒和黑盒都会用到</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>集成测试<ul><li>也叫组装测试</li><li>或者联合测试</li></ul></li><li>每个单元正确<ul><li>组装起来不一定能正确工作</li><li>所以要开展集成测试</li></ul></li><li>主要检测单元的接口关系<ul><li>集成为符合概要设计要求的更大的组件</li></ul></li></ul><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><ul><li>检测软件是否满足软件需求说明书中规定的要求</li></ul><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul><li>将同股集成测试的软件<ul><li>作为整个基于计算机系统的一个元素</li><li>与计算机硬件，外设，某些支持软件、数据和人员等其他元素结合在一起</li><li>在实际或模拟环境下进行测试</li></ul></li><li>目的是：<ul><li>通过与系统的需求定义作比较</li><li>发现与系统定义不一致的地方</li></ul></li></ul><h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul><li>按照项目任务书或合同的验收依据对整个系统进行测试与评审</li><li>决定是否接受系统</li></ul><h2 id="2-2-软件测试模型"><a href="#2-2-软件测试模型" class="headerlink" title="2.2 软件测试模型"></a>2.2 软件测试模型</h2><ul><li><h3 id="软件测试模型背景："><a href="#软件测试模型背景：" class="headerlink" title="软件测试模型背景："></a>软件测试模型背景：</h3><ul><li>测试与开发密切相关，通过实践产生了许多测试模型</li><li>这些模型将测试活动进行了抽象<ul><li>明确了测试与开发之间的关系</li><li>是测试管理的重要参考依据</li></ul></li></ul></li></ul><ul><li><h3 id="常见的软件测试模型"><a href="#常见的软件测试模型" class="headerlink" title="常见的软件测试模型"></a>常见的软件测试模型</h3><ul><li>V模型</li><li>W模型</li><li>H模型</li><li>X模型</li><li>前置测试模型</li></ul></li></ul><ul><li><h3 id="软件研发生命周期的瀑布模型-1"><a href="#软件研发生命周期的瀑布模型-1" class="headerlink" title="软件研发生命周期的瀑布模型"></a>软件研发生命周期的瀑布模型</h3><ul><li>计划时期：<ul><li>问题定义</li><li>可行性研究</li></ul></li><li>开发时期：<ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>测试</li></ul></li><li>运行时期：<ul><li>运行与维护</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：V模型"><a href="#软件测试模型：V模型" class="headerlink" title="软件测试模型：V模型"></a>软件测试模型：V模型</h3><ul><li>来源：<ul><li>软件开发的瀑布模型</li></ul></li><li>特点：<ul><li>说明了基本的开发过程和测试行为</li><li>明确地标识了测试过程中存在的不同级别以及测试阶段和开发各阶段的关系</li></ul></li><li>局限性：<ul><li>测试对象只有程序代码</li><li>测试作为编码后的活动，未体现“尽早测试”的原则</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：W模型"><a href="#软件测试模型：W模型" class="headerlink" title="软件测试模型：W模型"></a>软件测试模型：W模型</h3><ul><li>演化来源：<ul><li>V模型</li></ul></li><li>与V模型区别：<ul><li>增加了与软件开发阶段同步进行的测试</li></ul></li><li>强调：<ul><li>测试伴随整个软件开发周期</li><li>测试对象不仅是程序，需求、功能和设计同样要测试</li><li>测试与开发同步进行，有利于尽早发现问题</li></ul></li><li>局限性：<ul><li>W与V模型<ul><li>均把软件开发视为需求、设计、编码等一系列串行的活动</li><li>无法支持迭代以及变更调整</li></ul></li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：H模型"><a href="#软件测试模型：H模型" class="headerlink" title="软件测试模型：H模型"></a>软件测试模型：H模型</h3><ul><li>强调：<ul><li>测试活动<ul><li>独立</li><li>贯穿于整个产品周期</li><li>与研发流程并发</li></ul></li><li>循环：<ul><li>测试点准备就绪即可执行测试</li></ul></li><li>测试<ul><li>可尽早进行</li><li>可对被测对象分层次、反复测试</li></ul></li></ul></li><li>某一次测试过程：<ul><li>测试准备</li><li>测试就绪点</li><li>其他流程</li><li>测试执行</li><li>测试流程</li></ul></li></ul></li></ul><ul><li><h3 id="软件测试模型：其他测试模型"><a href="#软件测试模型：其他测试模型" class="headerlink" title="软件测试模型：其他测试模型"></a>软件测试模型：其他测试模型</h3><ul><li>X测试模型:<ul><li>特点：<ul><li>认为”学院派的V模型“不能处理开发的实际时间过程</li><li>比如：<ul><li>频繁重复的集成</li><li>需求文档的缺乏</li></ul></li></ul></li><li>内容：<ul><li>针对单独程序片段所进行的相互分离的编码和测试</li><li>此后进行贫乏明年的交接</li><li>通过集成最终成为可执行的程序</li><li>然后再对这些可执行程序进行测试</li></ul></li></ul></li><li>前置测试模型：<ul><li>测试与开发紧密结合</li><li>对每个交付内容进行测试<ul><li>eg：<ul><li>设计文档</li><li>可行性报告</li></ul></li></ul></li><li>交付内容一旦完成，立即进行测试</li></ul></li></ul></li></ul><ul><li><h3 id="测试模型的使用："><a href="#测试模型的使用：" class="headerlink" title="测试模型的使用："></a>测试模型的使用：</h3><ul><li>模型对工作开展有重要意义<ul><li>但每个模型都不是完美的</li></ul></li><li>灵活运用各个模型的优点<ul><li>还要考虑项目的实际情况</li></ul></li></ul></li></ul><h2 id="2-3-软件测试的流程"><a href="#2-3-软件测试的流程" class="headerlink" title="2.3 软件测试的流程"></a>2.3 软件测试的流程</h2><h3 id="1-软件测试的流程"><a href="#1-软件测试的流程" class="headerlink" title="1.软件测试的流程"></a>1.软件测试的流程</h3><h4 id="测试流程内容："><a href="#测试流程内容：" class="headerlink" title="测试流程内容："></a>测试流程内容：</h4><ul><li>测试过程定义了<ul><li>企业在产品开发过程中在<ul><li>设计</li><li>开发与实现</li><li>维护</li><li>退出</li></ul></li><li>等阶段 与测试相关活动的<ul><li>内容</li><li>流程</li><li>规范</li></ul></li></ul></li><li>测试过程指导：<ul><li>项目如何开展各项测试活动</li><li>以及各项活动的输入输出</li></ul></li><li>测试过程<ul><li>约定活动中所设计的角色与职责</li><li>规范各个活动的内容和章程<ul><li>以及所使用到的统一的<ul><li>模版</li><li>表单</li><li>指导书</li><li>检查单</li></ul></li></ul></li></ul></li></ul><h4 id="测试流程的作用"><a href="#测试流程的作用" class="headerlink" title="测试流程的作用"></a>测试流程的作用</h4><ul><li>给公司在产品开发过程中测试相关的活动<ul><li>提供指导</li><li>确保产品可以真正满足用户要求</li></ul></li></ul><h4 id="测试与开发关系"><a href="#测试与开发关系" class="headerlink" title="测试与开发关系"></a>测试与开发关系</h4><ul><li>软件项目中测试与开发相互配合、同步推进<ul><li>软件项目的复杂性被测对象往往不断变化</li><li>实际项目中测试与开发的关系更加复杂</li></ul></li><li>虽然测试与开发关系复杂，但测试工作的开展有自己的过程要遵循</li><li>对单次测试来说，存在一个一般性的过程</li></ul><h4 id="软件测试一般性过程"><a href="#软件测试一般性过程" class="headerlink" title="软件测试一般性过程"></a>软件测试一般性过程</h4><ol><li>需求分析阶段<ul><li>收集相关资料</li><li>学习业务（测试对象）</li><li>分析测试需求点</li></ul></li><li>测试计划阶段：<ul><li>测试主管<ul><li>组织编写《测试计划》</li><li>该文档指明<ul><li>测试范围</li><li>方法</li><li>资源</li><li>相应测试活动人员时间进度安排</li></ul></li></ul></li><li>测试计划<ul><li>需要进行评审</li><li>测试计划一旦开始执行<ul><li>就要定期监控计划的执行情况</li></ul></li></ul></li></ul></li><li>测试设计与开发<ul><li>测试设计<ul><li>一般由对需求熟悉的资深测试工程师设计</li><li>为每个测试点设计出包括<ul><li>需求点简介</li><li>测试思路</li><li>详细测试方法</li></ul></li><li>三部分的方法</li></ul></li><li>测试开发主要完成：<ul><li>测试用例编写</li><li>测试数据准备</li><li>测试环境准备</li></ul></li><li>测试设计与测试用例完成后需要进行评审</li></ul></li><li>测试执行及报告<ul><li>执行测试用例</li><li>及时提交<ul><li>有质量的bug</li><li>测试阶段报告<ul><li>反馈测试情况</li></ul></li></ul></li></ul></li><li>软件评估报告及批准<ul><li>根据测试结果给出<ul><li>对软件的整体评估</li><li>是否通过测的建议</li></ul></li><li>一般决策部门<ul><li>会根据这份评估报告决定产品是否可以发布vy</li></ul></li></ul></li><li>测试总结及资产归档<ul><li>结项阶段<ul><li>对整个过程进行回顾总结</li><li>将项目相关资源进行整理归档</li></ul></li></ul></li></ol><h3 id="2-软件测试流程的建立和维护"><a href="#2-软件测试流程的建立和维护" class="headerlink" title="2 软件测试流程的建立和维护"></a>2 软件测试流程的建立和维护</h3><h4 id="创建软件测试流程注意事项"><a href="#创建软件测试流程注意事项" class="headerlink" title="创建软件测试流程注意事项"></a>创建软件测试流程注意事项</h4><ul><li>从实际情况出发<ul><li>优化流程</li><li>解决问题u</li></ul></li><li>重点考虑四个问题：<ul><li>哪些测试要做</li><li>谁做</li><li>什么时间做</li><li>如何做</li></ul></li></ul><h4 id="创建测试流程步骤"><a href="#创建测试流程步骤" class="headerlink" title="创建测试流程步骤"></a>创建测试流程步骤</h4><ul><li>对当前存在的问题进行收集、诊断分析</li><li>根据实际情况建立新的流程</li><li>流程发布和试运行</li><li>促进流程的执行、收集问题</li><li>流程更新和发布</li></ul><h4 id="测试执行-VS-测试过程执行"><a href="#测试执行-VS-测试过程执行" class="headerlink" title="测试执行 VS 测试过程执行"></a>测试执行 VS 测试过程执行</h4><ul><li>测试执行<ul><li>按照测试计划去执行测试活动</li></ul></li><li>测试过程执行<ul><li>是严格按照测试的过程去开展测试活动</li></ul></li></ul><h4 id="测试流程不是静止的"><a href="#测试流程不是静止的" class="headerlink" title="测试流程不是静止的"></a>测试流程不是静止的</h4><ul><li>测试过程创建后不是一成不变</li><li>而是根据实际实践情况不断改进和完善</li><li>进行修订后要及时进行过程发布</li></ul><h4 id="促进测试过程的执行"><a href="#促进测试过程的执行" class="headerlink" title="促进测试过程的执行"></a>促进测试过程的执行</h4><ul><li>一般在测试过程执行中<ul><li>要设置一定的机制</li><li>去保证测试人员按照测试过程开展测试活动</li></ul></li><li>促进测试的执行<ul><li>QA人员对项目的监督和指导</li><li>组织级审计</li></ul></li></ul><h4 id="测试流程的改进"><a href="#测试流程的改进" class="headerlink" title="测试流程的改进"></a>测试流程的改进</h4><ul><li>测试流程<ul><li>在每一轮执行完毕后</li><li>根据所执行情况对流程进行更新和完善</li><li>用好的实践去更新完善流程</li></ul></li></ul><h4 id="测试过程中涉及的文档等资产"><a href="#测试过程中涉及的文档等资产" class="headerlink" title="测试过程中涉及的文档等资产"></a>测试过程中涉及的文档等资产</h4><ul><li>测试计划文档</li><li>测试方案文档</li><li>测试用例</li><li>测试报告</li><li>测试缺陷库</li><li>其他<ul><li>新开发或引入的测试工具</li><li>测试工作会议记录<ul><li>测试计划</li><li>测试方案</li><li>测试用例<ul><li>的评审报告</li></ul></li></ul></li><li>测试总结</li><li>测试原始数据以及度量数据</li><li>测试日志<ul><li>每天测试日程记录</li></ul></li><li>周期性测试报告</li><li>任务报告：<ul><li>任务完成情况报告</li></ul></li></ul></li></ul><h4 id="测试方案文档"><a href="#测试方案文档" class="headerlink" title="测试方案文档"></a>测试方案文档</h4><ul><li>描述<ul><li>为完成软件特性的测试而采用的测试方法的细节</li></ul></li><li>主要内容：<ul><li>概述</li><li>被测对象</li><li>应测试的特性</li><li>不被测试的特性</li><li>测试模型</li><li>测试需求</li><li>测试设计</li></ul></li></ul><h4 id="测试用例文档"><a href="#测试用例文档" class="headerlink" title="测试用例文档"></a>测试用例文档</h4><ul><li>测试用例表描述测试用例<ul><li>测试项目</li><li>用例编号</li><li>用例级别：测试用例重要程度</li><li>用例可用性</li><li>输入值</li><li>预期输出</li><li>实测结果</li><li>特殊环境需求（可选）</li><li>特殊测试步骤（可选）</li></ul></li></ul><h4 id="测试报告文档"><a href="#测试报告文档" class="headerlink" title="测试报告文档"></a>测试报告文档</h4><ul><li>描述测试结果的文档</li><li>主要内容：<ul><li>概述</li><li>测试时间、地点、人员</li><li>测试环境</li><li>测试结果统计分析</li><li>测试评估</li><li>测试总结与改进</li><li>测试缺陷列表</li></ul></li></ul><h4 id="测试缺陷："><a href="#测试缺陷：" class="headerlink" title="测试缺陷："></a>测试缺陷：</h4><ul><li>描述测试缺陷</li><li>主要内容：<ul><li>缺陷简述</li><li>缺陷描述</li><li>缺陷级别</li><li>缺陷分析与对策</li></ul></li></ul><h3 id="企业测试流程样例"><a href="#企业测试流程样例" class="headerlink" title="企业测试流程样例"></a>企业测试流程样例</h3><h4 id="某企业测试过程样例-概览"><a href="#某企业测试过程样例-概览" class="headerlink" title="某企业测试过程样例-概览"></a>某企业测试过程样例-概览</h4><p><img src="/posts/5418/%E6%A6%82%E8%A7%88.PNG" alt="概览"></p><h4 id="测试过程描述"><a href="#测试过程描述" class="headerlink" title="测试过程描述"></a>测试过程描述</h4><p><img src="/posts/5418/%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0.PNG" alt="测试过程描述"></p><h4 id="活动流程定义"><a href="#活动流程定义" class="headerlink" title="活动流程定义"></a>活动流程定义</h4><p><img src="/posts/5418/%E6%B4%BB%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89.PNG" alt="活动流程定义"></p><h4 id="测试相关的文档模版"><a href="#测试相关的文档模版" class="headerlink" title="测试相关的文档模版"></a>测试相关的文档模版</h4><p><img src="/posts/5418/%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF.PNG" alt="文档模版"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试实训 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1-非功能性的系统测试需求</title>
      <link href="/posts/14723.html"/>
      <url>/posts/14723.html</url>
      
        <content type="html"><![CDATA[<h2 id="典型的遇到的问题"><a href="#典型的遇到的问题" class="headerlink" title="典型的遇到的问题"></a>典型的遇到的问题</h2><ol><li>系统性能问题</li><li>软件系统安全性受到挑战</li></ol><h2 id="什么是系统非功能性测试？"><a href="#什么是系统非功能性测试？" class="headerlink" title="什么是系统非功能性测试？"></a>什么是系统非功能性测试？</h2><ul><li><p>用户的需求</p><ul><li>分类：<ul><li>功能性需求</li><li>非功能性需求</li></ul></li></ul></li><li><p>非功能性需求：</p><ul><li>被归纳为：<ul><li>软件产品的各种质量特性</li><li>eg：<ul><li>安全性</li><li>兼容性</li><li>可靠性</li></ul></li></ul></li></ul></li><li><p>系统非功能性测试：</p><ul><li>针对于以上非功能特性展开</li><li>验证软件产品符合这些质量特性的要求<ul><li>从而满足用户和软件企业自身的非功能性需求</li></ul></li></ul></li><li><p>系统测试</p><ul><li>分类：<ul><li>负载测试</li><li>性能测试</li><li>容量测试</li><li>安全性测试</li><li>兼容性测试</li><li>可靠性测试</li></ul></li></ul></li></ul><h2 id="系统非功能特性"><a href="#系统非功能特性" class="headerlink" title="系统非功能特性"></a>系统非功能特性</h2><ul><li><p><strong>性能</strong></p><ul><li>指按用户负载条件对<ul><li>响应时间</li><li>吞吐量<ul><li>所做的度量<ul><li>（度量指的是一些指标进行计算后的统计结果）</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>可用性</strong>：</p><ul><li>指对<ul><li>系统资源</li><li>服务<ul><li>可供最终用户使用的程度度量</li></ul></li></ul></li><li>通常以系统的正常运行时间来表示</li></ul></li><li><p><strong>可伸缩性</strong>：</p><ul><li>指随时间推移为部署系统增加容量和用户的能力</li><li>通常涉及向系统添加资源</li><li>但不应要求对部署体系结构进行更改</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>指对系统及用户的完整性进行说明的复杂因素组合</li><li>包括<ul><li>用户的验证和授权</li><li>数据的安全</li><li>对已部署系统的安全访问</li></ul></li></ul></li><li><p><strong>潜在容量</strong>：</p><ul><li>指在不增加资源的情况下，系统处理异常峰值负载的能力</li><li>潜在容量是<ul><li>可用性</li><li>性能</li><li>可伸缩性<ul><li>特性中的一个因素</li></ul></li></ul></li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>指对已部署系统进行维护的难易度</li><li>其中包括：<ul><li>监视系统</li><li>修复出现的故障</li><li>升级硬件和软件组件</li></ul></li></ul></li></ul><h2 id="系统非功能性测试的内容"><a href="#系统非功能性测试的内容" class="headerlink" title="系统非功能性测试的内容"></a>系统非功能性测试的内容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 软件性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter录制脚本</title>
      <link href="/posts/3679.html"/>
      <url>/posts/3679.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>file</code>目录中选择 templates..</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC1.png" alt="1"></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC2.png" alt="2"></p><p><code>select</code> <code>template</code>   中选择  <code>recording</code>  （在要做接口测试时）</p><p>如果要做性能测试，可以选择<code>recording with think time</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC3.png" alt="3"></p><p>选完后，<code>create</code> 确认</p><p>更改 <code>hostToRecord</code></p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC4.png" alt="4"></p><p>因为是要测试自己的网站，而这个网站是部署在自己电脑上的，所以此处<code>hostToRecord</code>更改为<code>127.00.1</code></p><p><code>https</code> 改为 <code>http</code></p><p>再次选择 <code>create</code> 创建</p><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC5.png" alt="5"></p><ul><li><p>知识点：LogicController：</p><ul><li>用来控制TestPlan的执行，如循环、分支等，或者更简单一点，就是为了分组</li></ul></li><li><p>Thread Group下的Recording controller即是用于分组</p></li><li><p>view resultsTree：看执行结果</p></li><li><p>HTTP(S) Test Script Recorder:</p><ul><li>用于代理（浏览器请求需要通过这个代理再到网站，网站返回的相应也要通过这个代理，所以他要把这个请求给记下来）</li></ul></li></ul><p><img src="/posts/3679/%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC6.png" alt="6"></p><p><code>port</code> 端口为8888，因为电脑上没有与这个冲突的，所以不用改</p><p>下面的 <code>Target Controller</code> 是指的存放所录制脚本的地方</p><p> <code>grouping</code>：一秒钟以内的请求</p><p>点击上面的 <code>start</code></p><p>再打开浏览器，打开设置栏，选择管理证书</p><p><img src="/posts/3679/7.png" alt="7"></p><p>选择证书颁发机构，选择导入</p><p><img src="/posts/3679/8.png" alt="8"></p><p>打开jmeter下的bin目录的apachejmetertemporaryrootca</p><p>后面一直点下一步、确定之类的即可</p><p>直到导入成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo s</code></p><p>图片引用：<img src="/posts/16107/%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="你想输入的替代文字"></p><p>emoji-》     ：smile：（冒号两边无空格）</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
